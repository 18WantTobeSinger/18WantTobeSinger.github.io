<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>spring相关知识点 | Halo</title><meta name="description" content="这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。 ​                                                                                                        —– 网易云热评      热身什么是 Spring Framework？ Spring 是一个开源应用框架，旨在降低应用程序开"><meta name="keywords" content="spring,面试题,知识点"><meta name="author" content="Halo"><meta name="copyright" content="Halo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="spring相关知识点"><meta property="og:url" content="penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"><meta property="og:site_name" content="Halo"><meta property="og:description" content="这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。 ​                                                                                                        —– 网易云热评      热身什么是 Spring Framework？ Spring 是一个开源应用框架，旨在降低应用程序开"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/cdadda0eb49689b9248617a1be5e58fd.jpg"><meta property="article:published_time" content="2020-07-06T10:22:17.000Z"><meta property="article:modified_time" content="2020-07-08T07:06:35.763Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="地下城游戏" href="/penghui.club/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"><link rel="next" title="NIO之缓冲区的使用" href="/penghui.club/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"JYM31PI6B3","apiKey":"9e02351fc1fca40e5c6698557702a86e","indexName":"HexoSearch","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/myStyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/flink.min.css"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Halo" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/favicon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">61</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">32</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 修身养性</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/book/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#热身"><span class="toc-number">1.</span> <span class="toc-text">热身</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-Spring-Framework？"><span class="toc-number">1.1.</span> <span class="toc-text">什么是 Spring Framework？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Framework-有哪些不同的功能？"><span class="toc-number">1.2.</span> <span class="toc-text">Spring Framework 有哪些不同的功能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-Spring-配置文件？"><span class="toc-number">1.3.</span> <span class="toc-text">什么是 Spring 配置文件？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖注入（IOC）"><span class="toc-number">2.</span> <span class="toc-text">依赖注入（IOC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-Spring-IOC-容器？"><span class="toc-number">2.1.</span> <span class="toc-text">什么是 Spring IOC 容器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是依赖注入？"><span class="toc-number">2.2.</span> <span class="toc-text">什么是依赖注入？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可以通过多少种方式完成依赖注入？"><span class="toc-number">2.3.</span> <span class="toc-text">可以通过多少种方式完成依赖注入？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区分构造函数注入和-setter-注入。"><span class="toc-number">2.4.</span> <span class="toc-text">区分构造函数注入和 setter 注入。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-中有多少种-IOC-容器？"><span class="toc-number">2.5.</span> <span class="toc-text">spring 中有多少种 IOC 容器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区分-BeanFactory-和-ApplicationContext。"><span class="toc-number">2.6.</span> <span class="toc-text">区分 BeanFactory 和 ApplicationContext。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-IoC-的实现机制。"><span class="toc-number">2.7.</span> <span class="toc-text">Spring IoC 的实现机制。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Beans"><span class="toc-number">3.</span> <span class="toc-text">Beans</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-提供了哪些配置方式？"><span class="toc-number">3.1.</span> <span class="toc-text">spring 提供了哪些配置方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、基于-xml-配置"><span class="toc-number">3.1.1.</span> <span class="toc-text">1、基于 xml 配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、基于注解配置"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、基于注解配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、基于-Java-API-配置"><span class="toc-number">3.1.3.</span> <span class="toc-text">3、基于 Java API 配置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-支持集中-bean-scope？"><span class="toc-number">3.2.</span> <span class="toc-text">spring 支持集中 bean scope？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-bean-容器的生命周期是什么样的？"><span class="toc-number">3.3.</span> <span class="toc-text">spring bean 容器的生命周期是什么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-spring-装配"><span class="toc-number">3.4.</span> <span class="toc-text">什么是 spring 装配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动装配有哪些方式？"><span class="toc-number">3.5.</span> <span class="toc-text">自动装配有哪些方式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注解"><span class="toc-number">4.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是基于注解的容器配置"><span class="toc-number">4.1.</span> <span class="toc-text">什么是基于注解的容器配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在-spring-中启动注解装配？"><span class="toc-number">4.2.</span> <span class="toc-text">如何在 spring 中启动注解装配？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Component-Controller-Repository-Service-有何区别？"><span class="toc-number">4.3.</span> <span class="toc-text">@Component, @Controller, @Repository, @Service 有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Autowired-注解有什么用？"><span class="toc-number">4.4.</span> <span class="toc-text">@Autowired 注解有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RequestMapping-注解有什么用？"><span class="toc-number">4.5.</span> <span class="toc-text">@RequestMapping 注解有什么用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">5.</span> <span class="toc-text">AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-AOP？"><span class="toc-number">5.1.</span> <span class="toc-text">什么是 AOP？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-Aspect？"><span class="toc-number">5.2.</span> <span class="toc-text">什么是 Aspect？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是切点（JoinPoint）"><span class="toc-number">5.3.</span> <span class="toc-text">什么是切点（JoinPoint）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是通知（Advice）？"><span class="toc-number">5.4.</span> <span class="toc-text">什么是通知（Advice）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有哪些类型的通知（Advice）？"><span class="toc-number">5.5.</span> <span class="toc-text">有哪些类型的通知（Advice）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP-有哪些实现方式？"><span class="toc-number">5.6.</span> <span class="toc-text">AOP 有哪些实现方式？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-AOP-and-AspectJ-AOP-有什么区别？"><span class="toc-number">5.7.</span> <span class="toc-text">Spring AOP and AspectJ AOP 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC"><span class="toc-number">6.</span> <span class="toc-text">MVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC-框架有什么用？"><span class="toc-number">6.1.</span> <span class="toc-text">Spring MVC 框架有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC-工作流程"><span class="toc-number">6.2.</span> <span class="toc-text">Spring MVC 工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#描述一下-DispatcherServlet-的工作流程"><span class="toc-number">6.3.</span> <span class="toc-text">描述一下 DispatcherServlet 的工作流程</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/cdadda0eb49689b9248617a1be5e58fd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Halo</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 修身养性</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/book/"><i class="fa-fw fas fa-book"></i><span> 读书</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">spring相关知识点</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-06 18:22:17"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-08 15:06:35"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-08</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 11 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p>这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。</p>
<p>​                                                                                                        —– 网易云热评</p>
</blockquote>
<a id="more"></a>



<h3 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h3><h4 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h4><ul>
<li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li>
<li>它是轻量级、松散耦合的。</li>
<li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li>
<li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li>
</ul>
<h4 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h4><ul>
<li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li>
<li>OC - 控制反转</li>
<li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li>
<li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li>
<li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li>
<li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li>
<li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li>
</ul>
<h4 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h4><p>​        Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。</p>
<h3 id="依赖注入（IOC）"><a href="#依赖注入（IOC）" class="headerlink" title="依赖注入（IOC）"></a>依赖注入（IOC）</h3><h4 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h4><p>​        Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<h4 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h4><p>​        在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<h4 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h4><p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<h4 id="区分构造函数注入和-setter-注入。"><a href="#区分构造函数注入和-setter-注入。" class="headerlink" title="区分构造函数注入和 setter 注入。"></a>区分构造函数注入和 setter 注入。</h4><table>
<thead>
<tr>
<th align="left">构造函数注入</th>
<th align="left">setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">任意修改都会创建一个新实例</td>
<td align="left">任意修改不会创建一个新实例</td>
</tr>
<tr>
<td align="left">适用于设置很多属性</td>
<td align="left">适用于设置少量属性</td>
</tr>
</tbody></table>
<h4 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h4><ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<h4 id="区分-BeanFactory-和-ApplicationContext。"><a href="#区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="区分 BeanFactory 和 ApplicationContext。"></a>区分 BeanFactory 和 ApplicationContext。</h4><table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>它使用懒加载</td>
<td>它使用即时加载</td>
</tr>
<tr>
<td>它使用语法显式提供资源对象</td>
<td>它自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody></table>
<h4 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h4><p>​        Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射机制</strong>。</p>
<h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h3><h4 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h4><h5 id="1、基于-xml-配置"><a href="#1、基于-xml-配置" class="headerlink" title="1、基于 xml 配置"></a>1、基于 xml 配置</h5><p>​        bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentbean"</span> <span class="attr">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Edureka"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、基于注解配置"><a href="#2、基于注解配置" class="headerlink" title="2、基于注解配置"></a>2、基于注解配置</h5><p>​        您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3、基于-Java-API-配置"><a href="#3、基于-Java-API-配置" class="headerlink" title="3、基于 Java API 配置"></a>3、基于 Java API 配置</h5><p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h4><p> Spring bean 支持 5 种 scope： </p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。</li>
</ul>
<p>常用的有<code>Singleton</code>、<code>Prototype</code>。 仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。 </p>
<h4 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h4><p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 <code>BeanNameAware</code> 接口，则工厂通过传递 bean 的 ID 来调用 <code>setBeanName()</code>。</li>
<li>如果 bean 实现 <code>BeanFactoryAware</code> 接口，工厂通过传递自身的实例来调用 <code>setBeanFactory()</code>。</li>
<li>如果为 bean 指定了 <code>init</code> 方法（<bean> 的 <code>init-method</code> 属性），那么将调用它。</li>
<li>如果存在与 bean 关联的任何 <code>BeanPostProcessors</code>，则调用 <code>postProcessBeforeInitialization()</code> 方法。</li>
<li>如果存在与 bean 关联的任何 <code>BeanPostProcessors</code>，则将调用 <code>postProcessAfterInitialization()</code> 方法。</li>
<li>如果 bean 实现 <code>DisposableBean</code> 接口，当 spring 容器关闭时，会调用 <code>destory()</code>。</li>
<li>如果为 bean 指定了 <code>destroy</code> 方法（<bean> 的 <code>destroy-method</code> 属性），spring 容器关闭时，那么将调用它。</li>
</ol>
<h4 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h4><p>​        当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<h4 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h4><p>​        Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ol>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ol>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h4><p>​        不使用 XML 来描述 bean 装配，开发人员通过在相关的类，<strong>方法或字段</strong>声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p>
<p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p>
<ul>
<li><code>@Bean</code> 注解扮演与 元素相同的角色。</li>
<li><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ul>
<p><em>可以这么来说，当一个类使用 <code>@Configuration</code> 注解标注时，那么该类相当于一个 spring的 xml 配置文件</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h4><p>​        默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p>
<h4 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h4><ul>
<li><strong>@Component</strong>：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li><strong>@Controller</strong>：这将一个类标记为 <code>Spring Web MVC</code> 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li><strong>@Service</strong>：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 <code>@Service</code> 而不是 <code>@Component</code>，因为它以更好的方式指定了意图。</li>
<li><strong>@Repository</strong>：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<h4 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h4><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是<span style="background-color: yellow;color: red;">类型驱动</span>的注入。</p>
<h4 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h4><p><code>@RequestMapping</code> 注解用于将特定 HTTP 请求方法映射到将处理相应请求的<strong>控制器</strong>中的<strong>特定类/方法</strong>。此注释可应用于两个级别：</p>
<ul>
<li>类级别（注解标注在类上）：映射请求的 URL</li>
<li>方法级别（注解标注在方法上）：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是-AOP？"><a href="#什么是-AOP？" class="headerlink" title="什么是 AOP？"></a>什么是 AOP？</h4><p> AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong> </p>
<h4 id="什么是-Aspect？"><a href="#什么是-Aspect？" class="headerlink" title="什么是 Aspect？"></a>什么是 Aspect？</h4><p>​        <code>aspect</code> 由 <code>Pointcut</code> 和 <code>Advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</p>
<p> <strong>可以简单地认为, 使用 @Aspect 注解的类就是一个切面.</strong> </p>
<h4 id="什么是切点（JoinPoint）"><a href="#什么是切点（JoinPoint）" class="headerlink" title="什么是切点（JoinPoint）"></a>什么是切点（JoinPoint）</h4><p>​        程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理，在 Spring AOP 中, <code>join point</code> 就是方法的执行点。</p>
<h4 id="什么是通知（Advice）？"><a href="#什么是通知（Advice）？" class="headerlink" title="什么是通知（Advice）？"></a>什么是通知（Advice）？</h4><p>​        特定 <code>JoinPoint</code> 处的 <code>Aspect</code> 所采取的动作称为 <code>Advice</code>。Spring AOP 使用一个 <code>Advice</code> 作为拦截器，在 <code>JoinPoint</code> “周围”维护一系列的拦截器。</p>
<h4 id="有哪些类型的通知（Advice）？"><a href="#有哪些类型的通知（Advice）？" class="headerlink" title="有哪些类型的通知（Advice）？"></a>有哪些类型的通知（Advice）？</h4><ul>
<li><strong>Before</strong> - 这些类型的 <code>Advice</code> 在 <code>joinpoint</code> 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li>
<li><strong>After Returning</strong> - 这些类型的 <code>Advice</code> 在连接点方法正常执行后执行，并使用<code>@AfterReturning</code> 注解标记进行配置。</li>
<li><strong>After Throwing</strong> - 这些类型的 <code>Advice</code> 仅在 <code>joinpoint</code> 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li>
<li><strong>After (finally)</strong> - 这些类型的 <code>Advice</code> 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li>
<li><strong>Around</strong> - 这些类型的 <code>Advice</code> 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li>
</ul>
<h4 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h4><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li><strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为<strong>编译时增强</strong>；<ul>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
</ul>
</li>
<li><strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为<strong>运行时增强</strong>。<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h4><p>​        Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p>
<h4 id="Spring-MVC-工作流程"><a href="#Spring-MVC-工作流程" class="headerlink" title="Spring MVC 工作流程"></a>Spring MVC 工作流程</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1159443997.jpg" alt="1159443997"></p>
<p>1、用户发送请求至前端控制器<code>DispatcherServlet</code>。</p>
<p>2、<code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code><strong>处理器映射器。</strong></p>
<p>3、<strong>处理器映射器</strong>找到具体的处理器(可以根据<strong>xml</strong>配置或者<strong>注解</strong>进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<code>DispatcherServlet</code>。</p>
<p>4、 <code>DispatcherServlet</code>调用<code>HandlerAdapter</code><strong>处理器适配器。</strong></p>
<p>5、<code>HandlerAdapter</code>经过适配调用具体的处理器(<code>Controller</code>，也叫<strong>后端控制器</strong>)。</p>
<p>6、<code>Controller</code>执行完成返回<code>ModelAndView</code>。</p>
<p>7、<code>HandlerAdapter</code>将<code>controller</code>执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code>。</p>
<p>8、<code>DispatcherServlet</code>将<code>ModelAndView</code>传给<code>ViewReslover</code><strong>视图解析器</strong>。</p>
<p>9、<code>ViewReslove</code>r解析后返回具体<strong>View</strong>。</p>
<p>10、<code>DispatcherServlet</code>根据<strong>View</strong>进行渲染视图（即将模型数据填充至视图中）。 </p>
<p>11、<code>DispatcherServlet</code>响应用户。</p>
<h4 id="描述一下-DispatcherServlet-的工作流程"><a href="#描述一下-DispatcherServlet-的工作流程" class="headerlink" title="描述一下 DispatcherServlet 的工作流程"></a>描述一下 DispatcherServlet 的工作流程</h4><ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 <code>DispatcherServlet</code> 捕获。</li>
<li><code>DispatcherServlet</code> 根据 <code>servlet.xml</code> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以<code>HandlerExecutionChain</code> 对象的形式返回。</li>
<li><code>DispatcherServlet</code> 根据获得的<code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。（附注：如果成功获得<code>HandlerAdapter</code>后，此时将开始执行拦截器的 <code>preHandler(...)</code>方法）。</li>
<li>提取<code>Request</code>中的模型数据，填充<code>Handler</code>入参，开始执行<code>Handler（Controller)</code>。 在填充<code>Handler</code>的入参过程中，根据你的配置，<code>Spring</code> 将帮你做一些额外的工作：<ol>
<li><code>HttpMessageConveter</code>： 将请求消息（如 <code>Json、xml</code> 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如<code>String</code>转换成<code>Integer、Double</code>等。</li>
<li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</li>
</ol>
</li>
<li><code>Handler(Controller)</code>执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code> 对象；</li>
<li>根据返回的<code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>（必须是已经注册到 Spring 容器中的<code>ViewResolver</code>)返回给<code>DispatcherServlet</code>。</li>
<li><code>ViewResolver</code> 结合<code>Model</code>和<code>View</code>，来渲染视图。</li>
<li>视图负责将渲染结果返回给客户端。</li>
</ol>
<p>原文链接：<a href="https://blog.csdn.net/qq_41701956/article/details/81389067" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81389067</a></p>
<p>部分内容原文链接：<a href="https://blog.csdn.net/floating_dreaming/article/details/89089214" target="_blank" rel="noopener">https://blog.csdn.net/floating_dreaming/article/details/89089214</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Halo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/">penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="penghui.club" target="_blank">Halo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/LeetCode-cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"><img class="prev-cover" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/LeetCode-cover.webp" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">地下城游戏</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/"><img class="next-cover" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/a8a487ba40d2e40da83ec34063590cd8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">NIO之缓冲区的使用</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '5IRF1lSADFgeMvDm3da0QQ5p-gzGzoHsz',
  appKey: '8Uwe9FOtEhx9Yc2QDJOomONl',
  placeholder: '请在此输入您的留言...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Halo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/algolia.js"></script><script src="/js/myJs.js"></script></body></html>