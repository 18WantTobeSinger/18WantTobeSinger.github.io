<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Halo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="penghui.club/"/>
  <updated>2020-07-14T14:08:56.413Z</updated>
  <id>penghui.club/</id>
  
  <author>
    <name>Halo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell脚本命令</title>
    <link href="penghui.club/2020/07/14/Shell%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>penghui.club/2020/07/14/Shell%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2020-07-14T12:30:47.000Z</published>
    <updated>2020-07-14T14:08:56.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我们都太懦弱 民国时期不敢做军阀 战乱时期不敢去起义 太平盛世不敢说我爱你</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><p>原文链接：<a href="https://blog.csdn.net/CSDN___LYY/article/details/100584638" target="_blank" rel="noopener">https://blog.csdn.net/CSDN___LYY/article/details/100584638</a></p><h2 id="shell脚本？"><a href="#shell脚本？" class="headerlink" title="shell脚本？"></a>shell脚本？</h2><p><strong>在说什么是shell脚本之前，先说说什么是shell。</strong></p><p>shell是外壳的意思，就是操作系统的外壳。我们可以通过shell命令来操作和控制操作系统，比如Linux中的Shell命令就包括ls、cd、pwd等等。总结来说，Shell是一个命令解释器，它通过接受用户输入的Shell命令来启动、暂停、停止程序的运行或对计算机进行控制。</p><p>shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。</p><p>shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序。</p><p><strong>那么什么是shell脚本呢？</strong></p><p>shell脚本就是由Shell命令组成的执行文件，将一些命令整合到一个文件中，进行处理业务逻辑，脚本不用编译即可运行。它通过解释器解释运行，所以速度相对来说比较慢。</p><p>shell脚本中最重要的就是对shell命令的使用与组合，再使用shell脚本支持的一些语言特性，完成想要的功能。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>“# ”开头的就是注释，被编译器忽略</p><ul><li>单行注释： #</li><li>多行注释： :&lt;&lt;EOF … EOF 或者 :&lt;&lt;! … ! （:&lt;&lt; 标识多行注释开始，并指定一个标识符作为开始结束的标志）</li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>局部变量</strong>：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong>：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>shell变量</strong>：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h4 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h4><ul><li>创建普通变量： name=“test” （=两边不可有空格）</li><li>创建只可函数体中使用的局部变量： local name=“test” （使用local修饰的变量在函数体外无法访问，并且local只能在函数体内使用）</li><li>使用变量： echo $name 或者 echo ​${name} （推荐使用大括号版）</li><li>变量重新赋值： name=“new_test” （将原值覆盖）</li><li>只读变量： name=“only_read” -&gt; readonly name（使用readonly标识后的变量，不可被修改）</li><li>删除变量： <code>unset name</code>; （删除之后不可访问，删除不掉只读变量）</li></ul><h4 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h4><h5 id="1）单引号"><a href="#1）单引号" class="headerlink" title="1）单引号"></a>1）单引号</h5><ul><li>单引号变量<span>var=’test’ </span>，只能原样输出，变量无效</li><li>单引号中不能出现一个单独的单引号，转义也不可以</li></ul><h5 id="2）双引号"><a href="#2）双引号" class="headerlink" title="2）双引号"></a>2）双引号</h5><ul><li>双引号变量var=”my name is ${name}”，变量有效</li><li>可出现转义符</li></ul><h5 id="3）拼接字符串"><a href="#3）拼接字符串" class="headerlink" title="3）拼接字符串"></a>3）拼接字符串</h5><ul><li>中间无任何+，之类的字符</li><li>name=“this is”” my name”; name=“this is my name”; name=“this” is “my name” 等效</li><li>name=‘this is’’ my nam’; name=‘this is my name’; name=‘this’ is ‘my name’ 等效</li></ul><h5 id="4）获取字符串长度"><a href="#4）获取字符串长度" class="headerlink" title="4）获取字符串长度"></a>4）获取字符串长度</h5><ul><li><p>在${}中使用“#”获取长度</p></li><li><p>name=“test”;</p></li><li><p>echo ${#name}; # 输出为4</p></li></ul><h5 id="5）提取子字符串"><a href="#5）提取子字符串" class="headerlink" title="5）提取子字符串"></a>5）提取子字符串</h5><ul><li>1:4 从第2个开始 往后截取4个字符</li><li>::4 从第一个字符开始 往后截取4个字符</li><li>name=“this is my name”;</li><li>echo ${name:1:4} #输出 is i</li><li>echo ${name::4}   #输出 this</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>bash只支持一维数组，不支持多维数组</p><ul><li>定义数组：array_name=(li wang xiang zhang) （小括号做边界、使用空格分离）</li><li>单独定义数组的元素： array_para[0]=“w”; array_para[3]=“s” （定义时下标不连续也可以）</li><li>赋值数组元素：array_name[0]=“zhao”;</li><li>获取数组元素：<ul><li>array_name[0]=“li”</li><li>array_name[3]=“zhang”</li><li>echo ${array_name[0]} # 输出”li”</li><li>echo ${array_name[1]} # 输出” “</li><li>echo ${array_name[3]} # 输出”zhang”</li><li>echo ${array_name[@]} # 输出”li zhang” 输出数组所有元素，没有元素的下标省略</li></ul></li><li>取得元素个数：${#array_name[@]} 或者 ${#array_name[*]}</li><li>取得单个元素长度：${#array_name[1]}</li></ul><hr><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><ul><li><p>获取参数值：</p><ul><li>$0 ： 固定，代表执行的文件名 </li></ul></li><li><p>$1 ： 代表传入的第1个参数</p><ul><li>$n ： 代表传入的第n个参数</li><li>$#：参数个数</li></ul></li><li><p>$*： 以一个单字符串显示所有向脚本传递的参数。如”$*“用「”」括起来的情况、以”$1 $2 … ​$n”的形式输出所有参数</p></li><li><p>$@：与$*相同，但是使用时加引号，并在引号中返回每个参数。</p></li><li><p>$$：脚本运行的当前进程号</p></li><li><p>$！：后台运行的最后一个进程的ID</p></li><li><p>$?： 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p></li><li><p>$* 与 $@ 区别<br><strong>相同点</strong>：都是引用所有参数。<br><strong>不同点</strong>：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</p></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><ul><li><code>+、-、*、\</code> ： 乘号前必须加\进行转义才可以进行乘法运算</li><li>加法运算</li><li>val=<code>expr 2 + 2</code> （使用<code>linux</code>命令<code>expr</code>进行辅助运算）</li><li>val=$[2+2] （4个空格不是必要的，不同于条件判断）</li><li>val=$((2+2))</li></ul><h4 id="数字关系运算符"><a href="#数字关系运算符" class="headerlink" title="数字关系运算符"></a>数字关系运算符</h4><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。<br>下面假定变量 a 为 10，变量 b 为 20</p><ul><li><code>-eq</code> ：检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。</li><li><code>-ne</code>： 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。</li><li><code>-gt</code>： 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。</li><li><code>-lt</code> ： 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。</li><li><code>-ge</code>： 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。</li><li><code>-le</code> ： 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。</li></ul><h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><ul><li><code>=</code> ：检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。</li><li><code>!=</code> ：检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。</li><li><code>-z</code> ：检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。</li><li><code>-n</code> ：检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。</li><li>$ ：检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。</li></ul><h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><ul><li><code>!</code> ：非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。</li><li><code>-o</code> ：或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。</li><li><code>-a</code> ：与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。</li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p><ul><li><code>&amp;&amp;</code> ：逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</li><li><code>||</code> ：逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true</li></ul><h4 id="文件运算符"><a href="#文件运算符" class="headerlink" title="文件运算符"></a>文件运算符</h4><ul><li><code>-b file</code> ：检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ]`返回 false。</li><li><code>-c file</code> ：检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。</li><li><code>-d file</code> ：检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。</li><li><code>-f file</code> ：检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ]返回 true。</li><li><code>-g file</code> ：检测文件是否设置了 SGID 位，如果是，则返回 true。[ -g $file ] 返回 false。</li><li><code>-k file</code> ：检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。</li><li><code>-p file</code> ：检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ]`返回 false。</li><li><code>-u file</code> ：检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ]返回 false。</li><li><code>-r file</code> ：检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。</li><li><code>-w file</code> ：检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。</li><li><code>-x file</code> ：检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。</li><li><code>-s file</code> ：检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。</li><li><code>-e file</code> ：检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。</li></ul><hr><h3 id="执行相关"><a href="#执行相关" class="headerlink" title="执行相关"></a>执行相关</h3><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。<br>执行命令：</p><ol><li>ls /etc ： 反引号 （所有的unix系统都支持）</li><li>$(ls /etc) ： $+() （部分unix系统不支持）<br>多个嵌套使用时，从内向外执行</li></ol><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><ul><li><code>$[ ]</code> : 加减乘除,不必添加空格</li><li><code>$(( ))</code> ：加减乘除等,不必添加空格</li></ul><h4 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h4><ul><li><code>[]</code>： 中括号旁边和运算符两边必须添加空格 （可以使用，不推荐）</li><li><code>[[ ]]</code>：中括号旁边和运算符两边必须添加空格 （字符串验证时，推荐使用）</li><li><code>(())</code> ： 中括号旁边和运算符两边必须添加空格 （数字验证时，推荐使用）</li><li><code>[[]]</code>和 <code>(())</code> 分别是[ ]的针对数学比较表达式和字符串表达式的加强版。</li><li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; ​$a != 2 ]], 如果不适用双括号, 则为if [ ​$a -ne 1] &amp;&amp; [ ​$a != 2 ]或者if [ ​$a -ne 1 -a $a != 2 ]。<br>[[ ]]中增加模式匹配特效；</li></ul><hr><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>仅用于字符串的输出，没有使用printf作为输出的移植性好，建议使用printf</p><h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><blockquote><p>printf 不会像 echo 自动添加换行符，我们可以手动添加 \n<br>无大括号，直接以空格分隔</p></blockquote><ul><li>格式：printf format-string [arguments…] 其中（format-string: 格式控制字符串、arguments: 参数列表）</li><li>案例：printf “%-10s %-8s %-4.2f\n” 郭靖 男 66.1234</li><li>%s %c %d %f 都是格式替代符<ul><li>d：Decimal 十进制整数 对应位置参数必须是十进制整数，否则报错!</li><li>s：String 字符串 对应位置参数必须是字符串或者字符型 否则报错</li><li>c：Char 字符 对应位置参数必须是字符串或者字符型 否则报错</li><li>f：Float 浮点 对应位置参数必须是数字型 否则报错</li></ul></li><li>%-10s ： 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</li><li>%-4.2f ：指格式化为小数，宽度为4个字符，其中.2指保留2位小数。</li><li>转义符：<ul><li>\a ：警告字符，通常为ASCII的BEL字符</li><li>\b ：后退</li><li>\c ：抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</li><li>\f ：换页（formfeed）<br>\n ：换行</li><li>\r ：回车（Carriage return）</li><li>\t ：水平制表符</li><li>\v ：垂直制表符</li><li>\ ：一个字面上的反斜杠字符</li><li>\ddd ：表示1到3位数八进制值的字符。仅在格式字符串中有效</li><li>\0ddd ：表示1到3位的八进制值字符</li></ul></li></ul><hr><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>和Java、PHP等语言不一样，sh的流程控制不可为空，即if或者else的大括号中无任何语句</p><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><ul><li>if</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>if else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>if else-if else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>for</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>while</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>while 无限循环</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>until<br>until 循环执行一系列命令直至条件为 true 时停止。<br>until 循环与 while 循环在处理方式上刚好相反。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。<br>case需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break，其中“;;”不是跳出循环，是不在去匹配下面的模式<br>case语句格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">  模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">  模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h4><ul><li>break ：跳出总循环</li><li>continue：跳出当前循环，继续下一次循环</li></ul><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</p><ul><li>函数定义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname()</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数传递<ul><li>调用函数: <code>fun_name 2 3 4</code></li><li>函数中使用：和<code>shell</code>取用函数相同 <code>$n $# $* $?</code>或者加上<code>{}</code></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第一个参数为 1 !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第二个参数为 2 !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 10 !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 &#123;10&#125; !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十一个参数为 &#123;11&#125; !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数总数有 # 个!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"作为一个字符串输出所有参数 * !"</span>&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"><span class="built_in">echo</span> ?  <span class="comment"># 判断执行是否成功</span></span><br></pre></td></tr></table></figure><ul><li>函数返回值<ul><li>return字样可存在也可不存在</li><li>return 只能为 return [0-255]，此处的返回可作为函数执行的状态，通过<code>$?</code>获取的便是这个返回值</li><li>如果不加return ， 则默认最后一条语句的执行状态所为函数执行状态的返回值，如果最后一条语句执行成功，则<code>$?</code>为0，否则不为0</li></ul></li><li>使用函数返回值（<code>Janusgraph</code>图数据库官方启动服务脚本片段）<ul><li><code>return</code>返回的数字，只是作为函数执行状态的返回值，也就是接下来<code>$?</code>获取的值</li><li>对于类似于下面的<code>BIN=\abs_path</code>语句，获取的是函数体内所有的<code>echo、printf</code>输出组合成的一个字符串</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">abs_path</span></span>() &#123;</span><br><span class="line">    SOURCE=<span class="string">"&#123;BASH_SOURCE[0]&#125;"</span></span><br><span class="line">    <span class="keyword">while</span> [ -h <span class="string">"SOURCE"</span> ]; <span class="keyword">do</span></span><br><span class="line">        DIR=<span class="string">"( cd -P "</span>( dirname <span class="string">"SOURCE"</span> )<span class="string">" &amp;&amp; pwd )"</span></span><br><span class="line">        SOURCE=<span class="string">"(readlink "</span>SOURCE<span class="string">")"</span></span><br><span class="line">        [[ SOURCE != /* ]] &amp;&amp; SOURCE=<span class="string">"DIR/SOURCE"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"test"</span>  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"( cd -P "</span>( dirname <span class="string">"<span class="variable">$SOURCE</span>"</span> )<span class="string">" &amp;&amp; pwd )"</span>  </span><br><span class="line">    此函数的两个<span class="built_in">echo</span>输出会组合成一个字符串作为下述BIN的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BIN=abs_path <span class="comment"># BIN赋值函数返回值，如果没有return，则函数中所有的echo、printf输出组合成一个字符串传入BIN</span></span><br><span class="line">path=<span class="variable">$&#123;BIN&#125;</span>/nodetool <span class="comment"># 可直接使用</span></span><br></pre></td></tr></table></figure><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。<br>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><ul><li>bash.sh &lt; file ： 将脚本的输入重定向到file，由file提供参数</li></ul><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><ul><li>bash.sh &gt; file ： 将脚本的输出数据重定向到file中，覆盖数据</li><li>bash.sh &gt;&gt; file ： 将脚本的输出数据重定向到file中，追加数据</li><li>command &gt;&gt; file 2&gt;&amp;1 ： 将 stdout 和 stderr 合并后重定向到 file</li></ul><h4 id="读取外部输入"><a href="#读取外部输入" class="headerlink" title="读取外部输入"></a>读取外部输入</h4><p>命令：<code>read arg</code> （脚本读取外部输入并赋值到变量上）<br>在shell脚本执行到上述命令时，停止脚本执行并等待外部输入，将外部输入赋值到arg变量上，继续执行脚本</p><h3 id="文件引用"><a href="#文件引用" class="headerlink" title="文件引用"></a>文件引用</h3><p>引用其他的文件之后，可以使用其变量、函数等等，相当于将引用的文件包含进了当前文件<br>两种方式：</p><ul><li><code>. file_path\file_name</code></li><li><code>source file_path\file_name</code></li></ul><h3 id="颜色标识"><a href="#颜色标识" class="headerlink" title="颜色标识"></a>颜色标识</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>  <span class="string">"\033[32m SUCCESS: yay \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span>  <span class="string">"\033[33m WARNING: hmm \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span>  <span class="string">"\033[31m ERROR: fubar \033[0m\n"</span>;</span><br></pre></td></tr></table></figure><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a><strong>输出结果：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUCCESS: yay</span><br><span class="line">WARNING: hmm</span><br><span class="line">ERROR: fubar</span><br></pre></td></tr></table></figure><h3 id="长句换行"><a href="#长句换行" class="headerlink" title="长句换行"></a>长句换行</h3><p>在shell中为避免一个语句过长，可以使用“\”进行换行<br>使用“\”换行，在脚本执行过程中还是当做一行一个语句执行，不同于enter直接换行</p><blockquote><p>注意：\ 前添加一个空格 。 \ 后无空格直接换行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/mysql/bin/mysql \</span><br><span class="line"> -h test_host  -P 000 \</span><br><span class="line"> -u test_user -ptest_password ;</span><br></pre></td></tr></table></figure><h3 id="shell操作mysql"><a href="#shell操作mysql" class="headerlink" title="shell操作mysql"></a>shell操作mysql</h3><p>下面案例为登录mysql，并选择操作数据库，之后进行导入数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/mysql/mysql/bin/mysql \</span><br><span class="line"> -h test_host  -P 000 \</span><br><span class="line"> -u test_user -ptest_password \</span><br><span class="line"> -e<span class="string">"use test_database; source data_faile; "</span> <span class="comment"># -e 代表执行sql语句</span></span><br></pre></td></tr></table></figure><blockquote><p>-u 用户名<br>-p 用户密码<br>-h 服务器ip地址<br>-D 连接的数据库<br>-N 不输出列信息<br>-B 使用tab键 代替 分隔符<br>-e 执行的SQL语句</p></blockquote><h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p><strong>命令：exit</strong></p><p>在退出脚本时使用不同的错误码，这样可以根据错误码来判断发生了什么错误。</p><blockquote><p>在绝大多数 shell 脚本中，exit 0 表示执行成功，exit 1 表示发生错误。<br>对错误与错误码进行一对一的映射，这样有助于脚本调试。</p></blockquote><p><strong>命令：set -e 或者 set +e</strong></p><p>set -e表示从当前位置开始，如果出现任何错误都将触发exit。相反，set +e表示不管出现任何错误继续执行脚本。</p><blockquote><p>如果脚本是有状态的（每个后续步骤都依赖前一个步骤），那么请使用set -e，在脚本出现错误时立即退出脚本。<br>如果要求所有命令都要执行完（很少会这样），那么就使用set +e。</p></blockquote><h3 id="shell脚本调试"><a href="#shell脚本调试" class="headerlink" title="shell脚本调试"></a>shell脚本调试</h3><p>检查是否有语法错误<code>-n</code>：<br><code>bash -n script_name.sh</code><br>使用下面的命令来执行并调试 Shell 脚本<code>-x</code>：<br><code>bash -x script_name.sh</code><br><strong>调试count_odd_number.sh 程序案例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin.env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于计算数组中奇数的和</span></span><br><span class="line"><span class="comment"># @author liyangyang</span></span><br><span class="line"><span class="comment"># @time 2019/09/17</span></span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4;<span class="keyword">do</span></span><br><span class="line">    re=&#123;num&#125;%2</span><br><span class="line">    <span class="keyword">if</span> (( &#123;re&#125; == 1 ));<span class="keyword">then</span></span><br><span class="line">        sum=[&#123;sum&#125;+&#123;num&#125;]</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> &#123;sum&#125;</span><br></pre></td></tr></table></figure><ol><li>首先检查有无语法错误：<br><code>bash -n count_odd_number.sh</code></li><li>没有输出，说明没有错误，开始实际调试：<br><code>bash -x count_odd_number.sh</code></li><li>调试结果如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ sum=0</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=1%2</span><br><span class="line">+ ((  1%2 == 1  ))</span><br><span class="line">+ sum=1</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=2%2</span><br><span class="line">+ ((  2%2 == 1  ))</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=3%2</span><br><span class="line">+ ((  3%2 == 1  ))</span><br><span class="line">+ sum=4</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=4%2</span><br><span class="line">+ ((  4%2 == 1  ))</span><br><span class="line">+ <span class="built_in">echo</span> 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>其中的输出显示了程序执行的每一步，通过观察程序执行的步骤是否满足预期从而达到调试的效果<br>带有 + 表示的是 Shell 调试器的输出，不带 + 表示程序的输出。</p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p>这是es（ElasticSearch）官方启动服务的脚本，看可不可以理解吧~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CONTROLLING STARTUP:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script relies on a few environment variables to determine startup</span></span><br><span class="line"><span class="comment"># behavior, those variables are:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   ES_PATH_CONF -- Path to config directory</span></span><br><span class="line"><span class="comment">#   ES_JAVA_OPTS -- External Java Opts on top of the defaults set</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Optionally, exact memory values can be set using the `ES_JAVA_OPTS`. Note that</span></span><br><span class="line"><span class="comment"># the Xms and Xmx lines in the JVM options file must be commented out. Example</span></span><br><span class="line"><span class="comment"># values are "512m", and "10g".</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   ES_JAVA_OPTS="-Xms8g -Xmx8g" ./bin/elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="string">"`dirname "</span><span class="variable">$0</span><span class="string">"`"</span>/elasticsearch-env</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">parse_jvm_options</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"`grep "</span>^-<span class="string">" "</span><span class="variable">$1</span><span class="string">" | tr '\n' ' '`"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES_JVM_OPTIONS=<span class="string">"<span class="variable">$ES_PATH_CONF</span>"</span>/jvm.options</span><br><span class="line"></span><br><span class="line">ES_JAVA_OPTS=<span class="string">"`parse_jvm_options "</span><span class="variable">$ES_JVM_OPTIONS</span><span class="string">"` <span class="variable">$ES_JAVA_OPTS</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># manual parsing to find out, if process should be detached</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">echo</span> $* | grep -E <span class="string">'(^-d |-d$| -d |--daemonize$|--daemonize )'</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exec</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$JAVA</span>"</span> \</span><br><span class="line">    <span class="variable">$ES_JAVA_OPTS</span> \</span><br><span class="line">    -Des.path.home=<span class="string">"<span class="variable">$ES_HOME</span>"</span> \</span><br><span class="line">    -Des.path.conf=<span class="string">"<span class="variable">$ES_PATH_CONF</span>"</span> \</span><br><span class="line">    -cp <span class="string">"<span class="variable">$ES_CLASSPATH</span>"</span> \</span><br><span class="line">    org.elasticsearch.bootstrap.Elasticsearch \</span><br><span class="line">    <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$JAVA</span>"</span> \</span><br><span class="line">    <span class="variable">$ES_JAVA_OPTS</span> \</span><br><span class="line">    -Des.path.home=<span class="string">"<span class="variable">$ES_HOME</span>"</span> \</span><br><span class="line">    -Des.path.conf=<span class="string">"<span class="variable">$ES_PATH_CONF</span>"</span> \</span><br><span class="line">    -cp <span class="string">"<span class="variable">$ES_CLASSPATH</span>"</span> \</span><br><span class="line">    org.elasticsearch.bootstrap.Elasticsearch \</span><br><span class="line">    <span class="string">"<span class="variable">$@</span>"</span> \</span><br><span class="line">    &lt;&amp;- &amp;</span><br><span class="line">  retval=$?</span><br><span class="line">  pid=$!</span><br><span class="line">  [ <span class="variable">$retval</span> -eq 0 ] || <span class="built_in">exit</span> <span class="variable">$retval</span></span><br><span class="line">  <span class="keyword">if</span> [ ! -z <span class="string">"<span class="variable">$ES_STARTUP_SLEEP_TIME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    sleep <span class="variable">$ES_STARTUP_SLEEP_TIME</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> ! ps -p <span class="variable">$pid</span> &gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> $?</span><br></pre></td></tr></table></figure><h3 id="经常来看看才能记住😭"><a href="#经常来看看才能记住😭" class="headerlink" title="经常来看看才能记住😭"></a>经常来看看才能记住😭</h3>]]></content>
    
    <summary type="html">
    
      Shell脚本命令
    
    </summary>
    
    
    
      <category term="Shell" scheme="penghui.club/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="penghui.club/2020/07/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>penghui.club/2020/07/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-13T12:06:19.000Z</published>
    <updated>2020-07-13T13:33:14.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我想开一家酒馆 名字就叫陈年旧事吧 这家店只深夜开门半夜打烊 这家店没有激情的音乐 这家店会有你喜欢的装修 这家店不摇头不蹦迪 这家店长会跟每一个顾客分享故事 这家店会有一个唯一的免费会员 这家店是年少时我们一起的玩笑话 这家店我想开在郑州 今年我二十岁 我想在二十五岁开。</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这次的排序没有逼格！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (le &gt;= ri) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(a, le, ri);</span><br><span class="line">    quickSort(a, le, j - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, j + <span class="number">1</span>, ri);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = a[le];</span><br><span class="line">    <span class="keyword">int</span> i = le, j = ri + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], base)) <span class="keyword">if</span> (i == ri) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(base, a[--j])) <span class="keyword">if</span> (j == le) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, le, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i]; a[i] = a[j]; a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于以上标准快排的优化："><a href="#关于以上标准快排的优化：" class="headerlink" title="关于以上标准快排的优化："></a>关于以上标准快排的优化：</h3><p>以下使用三向切分的思路进行优化，他从左到右遍历数组一次，维护一个指针<code>lt</code>使得<code>a[lo..lt-1]</code>中的元素都小于<code>v</code>，一个指针<code>gt</code>使得<code>a[gt+1..hi]</code>中的元素都大于<code>v</code>，一个指针<code>i</code>使得<code>a[lt..i-1]</code>中的元素都等于<code>v</code>，<code>a[i..gt]</code>中的元素都还未确定。分以下三种情况：</p><ul><li><code>a[i]</code> &lt; <code>v</code>，将<code>a[lt]</code>和<code>a[i]</code>交换，将<code>lt</code>和<code>i</code>加一。</li><li><code>a[i]</code> &gt; <code>v</code>，将<code>a[gt]</code>和<code>a[i]</code>交换，将<code>gt</code>减一。</li><li><code>a[i]</code> == v，将<code>i</code>加一。</li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (le &gt;= ri) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = le, i = le + <span class="number">1</span>, gt = ri;</span><br><span class="line">    <span class="keyword">int</span> v = a[le];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = less(a[i], v);</span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) exch(a, lt ++, i ++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) exch(a, i, gt --);</span><br><span class="line">        <span class="keyword">else</span>              i ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort(a, le, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, gt + <span class="number">1</span>, ri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>      (x &lt; y) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i]; a[i] = a[j]; a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我想开一家酒馆 名字就叫陈年旧事吧 这家店只深夜开门半夜打烊 这家店没有激情的音乐 这家店会有你喜欢的装修 这家店不摇头不蹦迪 这家店长会跟每一个顾客分享故事 这家店会有一个唯一的免费会员 这家店是年少时我们一起的玩笑话 这家店我想开在郑州 今年我二十岁 我想在二十五岁开。&lt;/p&gt;
&lt;p&gt;​                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="penghui.club/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯方块的Shell脚本</title>
    <link href="penghui.club/2020/07/13/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E7%9A%84Shell%E8%84%9A%E6%9C%AC/"/>
    <id>penghui.club/2020/07/13/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E7%9A%84Shell%E8%84%9A%E6%9C%AC/</id>
    <published>2020-07-13T03:06:29.000Z</published>
    <updated>2020-07-13T12:36:33.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>人生一世 草木一秋 即是事过三而虑 醒来时抬头 着觉时回首 醉酒时忘忧</p><p>   ​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="俄罗斯方块"><a href="#俄罗斯方块" class="headerlink" title="俄罗斯方块"></a>俄罗斯方块</h2><p>此篇纯粹为了好玩！</p><h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>首先创建一个shell脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Tetris.sh</span><br></pre></td></tr></table></figure><h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>复制以下内容，粘贴到脚本中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tetris Game</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.21.2003 xhchen&lt;[email]xhchen@winbond.com.tw[/email]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">APP declaration</span></span><br><span class="line">APP_NAME="$&#123;0##*[\\/]&#125;"</span><br><span class="line">APP_VERSION="1.0"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">颜色定义</span></span><br><span class="line">cRed=1</span><br><span class="line">cGreen=2</span><br><span class="line">cYellow=3</span><br><span class="line">cBlue=4</span><br><span class="line">cFuchsia=5</span><br><span class="line">cCyan=6</span><br><span class="line">cWhite=7</span><br><span class="line">colorTable=($cRed $cGreen $cYellow $cBlue $cFuchsia $cCyan $cWhite)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">位置和大小</span></span><br><span class="line">iLeft=3</span><br><span class="line">iTop=2</span><br><span class="line">((iTrayLeft = iLeft + 2))</span><br><span class="line">((iTrayTop = iTop + 1))</span><br><span class="line">((iTrayWidth = 10))</span><br><span class="line">((iTrayHeight = 15))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">颜色设置</span></span><br><span class="line">cBorder=$cGreen</span><br><span class="line">cScore=$cFuchsia</span><br><span class="line">cScoreValue=$cCyan</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">控制信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">改游戏使用两个进程，一个用于接收输入，一个用于游戏流程和显示界面;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当前者接收到上下左右等按键时，通过向后者发送signal的方式通知后者。</span></span><br><span class="line">sigRotate=25</span><br><span class="line">sigLeft=26</span><br><span class="line">sigRight=27</span><br><span class="line">sigDown=28</span><br><span class="line">sigAllDown=29</span><br><span class="line">sigExit=30</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">七中不同的方块的定义</span></span><br><span class="line"><span class="meta">#</span><span class="bash">通过旋转，每种方块的显示的样式可能有几种</span></span><br><span class="line">box0=(0 0 0 1 1 0 1 1)</span><br><span class="line">box1=(0 2 1 2 2 2 3 2 1 0 1 1 1 2 1 3)</span><br><span class="line">box2=(0 0 0 1 1 1 1 2 0 1 1 0 1 1 2 0)</span><br><span class="line">box3=(0 1 0 2 1 0 1 1 0 0 1 0 1 1 2 1)</span><br><span class="line">box4=(0 1 0 2 1 1 2 1 1 0 1 1 1 2 2 2 0 1 1 1 2 0 2 1 0 0 1 0 1 1 1 2)</span><br><span class="line">box5=(0 1 1 1 2 1 2 2 1 0 1 1 1 2 2 0 0 0 0 1 1 1 2 1 0 2 1 0 1 1 1 2)</span><br><span class="line">box6=(0 1 1 1 1 2 2 1 1 0 1 1 1 2 2 1 0 1 1 0 1 1 2 1 0 1 1 0 1 1 1 2)</span><br><span class="line"><span class="meta">#</span><span class="bash">所有其中方块的定义都放到box变量中</span></span><br><span class="line">box=($&#123;box0[@]&#125; $&#123;box1[@]&#125; $&#123;box2[@]&#125; $&#123;box3[@]&#125; $&#123;box4[@]&#125; $&#123;box5[@]&#125; $&#123;box6[@]&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash">各种方块旋转后可能的样式数目</span></span><br><span class="line">countBox=(1 2 2 2 4 4 4)</span><br><span class="line"><span class="meta">#</span><span class="bash">各种方块再box数组中的偏移</span></span><br><span class="line">offsetBox=(0 1 3 5 7 11 15)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">每提高一个速度级需要积累的分数</span></span><br><span class="line">iScoreEachLevel=50        #be greater than 7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行时数据</span></span><br><span class="line">sig=0                #接收到的signal</span><br><span class="line">iScore=0        #总分</span><br><span class="line">iLevel=0        #速度级</span><br><span class="line">boxNew=()        #新下落的方块的位置定义</span><br><span class="line">cBoxNew=0        #新下落的方块的颜色</span><br><span class="line">iBoxNewType=0        #新下落的方块的种类</span><br><span class="line">iBoxNewRotate=0        #新下落的方块的旋转角度</span><br><span class="line">boxCur=()        #当前方块的位置定义</span><br><span class="line">cBoxCur=0        #当前方块的颜色</span><br><span class="line">iBoxCurType=0        #当前方块的种类</span><br><span class="line">iBoxCurRotate=0        #当前方块的旋转角度</span><br><span class="line">boxCurX=-1        #当前方块的x坐标位置</span><br><span class="line">boxCurY=-1        #当前方块的y坐标位置</span><br><span class="line">iMap=()                #背景方块图表</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">初始化所有背景方块为-1, 表示没有方块</span></span><br><span class="line">for ((i = 0; i &lt; iTrayHeight * iTrayWidth; i++)); do iMap[$i]=-1; done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">接收输入的进程的主函数</span></span><br><span class="line">function RunAsKeyReceiver()</span><br><span class="line">&#123;</span><br><span class="line">        local pidDisplayer key aKey sig cESC sTTY</span><br><span class="line"></span><br><span class="line">        pidDisplayer=$1</span><br><span class="line">        aKey=(0 0 0)</span><br><span class="line"></span><br><span class="line">        cESC=`echo -ne "\033"`</span><br><span class="line">        cSpace=`echo -ne "\040"`</span><br><span class="line"></span><br><span class="line">        #保存终端属性。在read -s读取终端键时，终端的属性会被暂时改变。</span><br><span class="line">        #如果在read -s时程序被不幸杀掉，可能会导致终端混乱，</span><br><span class="line">        #需要在程序退出时恢复终端属性。</span><br><span class="line">        sTTY=`stty -g`</span><br><span class="line"></span><br><span class="line">        #捕捉退出信号</span><br><span class="line">        trap "MyExit;" INT TERM</span><br><span class="line">        trap "MyExitNoSub;" $sigExit</span><br><span class="line"></span><br><span class="line">        #隐藏光标</span><br><span class="line">        echo -ne "\033[?25l"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #读取输入。注-s不回显，-n读到一个字符立即返回</span><br><span class="line">                read -s -n 1 key</span><br><span class="line"></span><br><span class="line">                aKey[0]=$&#123;aKey[1]&#125;</span><br><span class="line">                aKey[1]=$&#123;aKey[2]&#125;</span><br><span class="line">                aKey[2]=$key</span><br><span class="line">                sig=0</span><br><span class="line"></span><br><span class="line">                #判断输入了何种键</span><br><span class="line">                if [[ $key == $cESC &amp;&amp; $&#123;aKey[1]&#125; == $cESC ]]</span><br><span class="line">                then</span><br><span class="line">                        #ESC键</span><br><span class="line">                        MyExit</span><br><span class="line">                elif [[ $&#123;aKey[0]&#125; == $cESC &amp;&amp; $&#123;aKey[1]&#125; == "[" ]]</span><br><span class="line">                then</span><br><span class="line">                        if [[ $key == "A" ]]; then sig=$sigRotate        #&lt;向上键&gt;</span><br><span class="line">                        elif [[ $key == "B" ]]; then sig=$sigDown        #&lt;向下键&gt;</span><br><span class="line">                        elif [[ $key == "D" ]]; then sig=$sigLeft        #&lt;向左键&gt;</span><br><span class="line">                        elif [[ $key == "C" ]]; then sig=$sigRight        #&lt;向右键&gt;</span><br><span class="line">                        fi</span><br><span class="line">                elif [[ $key == "W" || $key == "w" ]]; then sig=$sigRotate        #W, w</span><br><span class="line">                elif [[ $key == "S" || $key == "s" ]]; then sig=$sigDown        #S, s</span><br><span class="line">                elif [[ $key == "A" || $key == "a" ]]; then sig=$sigLeft        #A, a</span><br><span class="line">                elif [[ $key == "D" || $key == "d" ]]; then sig=$sigRight        #D, d</span><br><span class="line">                elif [[ "[$key]" == "[]" ]]; then sig=$sigAllDown        #空格键</span><br><span class="line">                elif [[ $key == "Q" || $key == "q" ]]                        #Q, q</span><br><span class="line">                then</span><br><span class="line">                        MyExit</span><br><span class="line">                fi</span><br><span class="line"></span><br><span class="line">                if [[ $sig != 0 ]]</span><br><span class="line">                then</span><br><span class="line">                        #向另一进程发送消息</span><br><span class="line">                        kill -$sig $pidDisplayer</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出前的恢复</span></span><br><span class="line">function MyExitNoSub()</span><br><span class="line">&#123;</span><br><span class="line">        local y</span><br><span class="line"></span><br><span class="line">        #恢复终端属性</span><br><span class="line">        stty $sTTY</span><br><span class="line">        ((y = iTop + iTrayHeight + 4))</span><br><span class="line"></span><br><span class="line">        #显示光标</span><br><span class="line">        echo -e "\033[?25h\033[$&#123;y&#125;;0H"</span><br><span class="line">        exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function MyExit()</span><br><span class="line">&#123;</span><br><span class="line">        #通知显示进程需要退出</span><br><span class="line">        kill -$sigExit $pidDisplayer</span><br><span class="line"></span><br><span class="line">        MyExitNoSub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">处理显示和游戏流程的主函数</span></span><br><span class="line">function RunAsDisplayer()</span><br><span class="line">&#123;</span><br><span class="line">        local sigThis</span><br><span class="line">        InitDraw</span><br><span class="line"></span><br><span class="line">        #挂载各种信号的处理函数</span><br><span class="line">        trap "sig=$sigRotate;" $sigRotate</span><br><span class="line">        trap "sig=$sigLeft;" $sigLeft</span><br><span class="line">        trap "sig=$sigRight;" $sigRight</span><br><span class="line">        trap "sig=$sigDown;" $sigDown</span><br><span class="line">        trap "sig=$sigAllDown;" $sigAllDown</span><br><span class="line">        trap "ShowExit;" $sigExit</span><br><span class="line"></span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #根据当前的速度级iLevel不同，设定相应的循环的次数</span><br><span class="line">                for ((i = 0; i &lt; 21 - iLevel; i++))</span><br><span class="line">                do</span><br><span class="line">                        sleep 0.02</span><br><span class="line">                        sigThis=$sig</span><br><span class="line">                        sig=0</span><br><span class="line"></span><br><span class="line">                        #根据sig变量判断是否接受到相应的信号</span><br><span class="line">                        if ((sigThis == sigRotate)); then BoxRotate;        #旋转</span><br><span class="line">                        elif ((sigThis == sigLeft)); then BoxLeft;        #左移一列</span><br><span class="line">                        elif ((sigThis == sigRight)); then BoxRight;        #右移一列</span><br><span class="line">                        elif ((sigThis == sigDown)); then BoxDown;        #下落一行</span><br><span class="line">                        elif ((sigThis == sigAllDown)); then BoxAllDown;        #下落到底</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">                #kill -$sigDown $$</span><br><span class="line">                BoxDown        #下落一行</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">BoxMove(y, x), 测试是否可以把移动中的方块移到(x, y)的位置, 返回0则可以, 1不可以</span></span><br><span class="line">function BoxMove()</span><br><span class="line">&#123;</span><br><span class="line">        local j i x y xTest yTest</span><br><span class="line">        yTest=$1</span><br><span class="line">        xTest=$2</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + yTest))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + xTest))</span><br><span class="line">                if (( y &lt; 0 || y &gt;= iTrayHeight || x &lt; 0 || x &gt;= iTrayWidth))</span><br><span class="line">                then</span><br><span class="line">                        #撞到墙壁了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">                if (($&#123;iMap[y * iTrayWidth + x]&#125; != -1 ))</span><br><span class="line">                then</span><br><span class="line">                        #撞到其他已经存在的方块了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将当前移动中的方块放到背景方块中去,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">并计算新的分数和速度级。(即一次方块落到底部)</span></span><br><span class="line">function Box2Map()</span><br><span class="line">&#123;</span><br><span class="line">        local j i x y xp yp line</span><br><span class="line"></span><br><span class="line">        #将当前移动中的方块放到背景方块中去</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + boxCurY))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + boxCurX))</span><br><span class="line">                ((i = y * iTrayWidth + x))</span><br><span class="line">                iMap[$i]=$cBoxCur</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        #消去可被消去的行</span><br><span class="line">        line=0</span><br><span class="line">        for ((j = 0; j &lt; iTrayWidth * iTrayHeight; j += iTrayWidth))</span><br><span class="line">        do</span><br><span class="line">                for ((i = j + iTrayWidth - 1; i &gt;= j; i--))</span><br><span class="line">                do</span><br><span class="line">                        if (($&#123;iMap[$i]&#125; == -1)); then break; fi</span><br><span class="line">                done</span><br><span class="line">                if ((i &gt;= j)); then continue; fi</span><br><span class="line"></span><br><span class="line">                ((line++))</span><br><span class="line">                for ((i = j - 1; i &gt;= 0; i--))</span><br><span class="line">                do</span><br><span class="line">                        ((x = i + iTrayWidth))</span><br><span class="line">                        iMap[$x]=$&#123;iMap[$i]&#125;</span><br><span class="line">                done</span><br><span class="line">                for ((i = 0; i &lt; iTrayWidth; i++))</span><br><span class="line">                do</span><br><span class="line">                        iMap[$i]=-1</span><br><span class="line">                done</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        if ((line == 0)); then return; fi</span><br><span class="line"></span><br><span class="line">        #根据消去的行数line计算分数和速度级</span><br><span class="line">        ((x = iLeft + iTrayWidth * 2 + 7))</span><br><span class="line">        ((y = iTop + 11))</span><br><span class="line">        ((iScore += line * 2 - 1))</span><br><span class="line">        #显示新的分数</span><br><span class="line">        echo -ne "\033[1m\033[3$&#123;cScoreValue&#125;m\033[$&#123;y&#125;;$&#123;x&#125;H$&#123;iScore&#125;         "</span><br><span class="line">        if ((iScore % iScoreEachLevel &lt; line * 2 - 1))</span><br><span class="line">        then</span><br><span class="line">                if ((iLevel &lt; 20))</span><br><span class="line">                then</span><br><span class="line">                        ((iLevel++))</span><br><span class="line">                        ((y = iTop + 14))</span><br><span class="line">                        #显示新的速度级</span><br><span class="line">                        echo -ne "\033[3$&#123;cScoreValue&#125;m\033[$&#123;y&#125;;$&#123;x&#125;H$&#123;iLevel&#125;        "</span><br><span class="line">                fi</span><br><span class="line">        fi</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #重新显示背景方块</span><br><span class="line">        for ((y = 0; y &lt; iTrayHeight; y++))</span><br><span class="line">        do</span><br><span class="line">                ((yp = y + iTrayTop + 1))</span><br><span class="line">                ((xp = iTrayLeft + 1))</span><br><span class="line">                ((i = y * iTrayWidth))</span><br><span class="line">                echo -ne "\033[$&#123;yp&#125;;$&#123;xp&#125;H"</span><br><span class="line">                for ((x = 0; x &lt; iTrayWidth; x++))</span><br><span class="line">                do</span><br><span class="line">                        ((j = i + x))</span><br><span class="line">                        if (($&#123;iMap[$j]&#125; == -1))</span><br><span class="line">                        then</span><br><span class="line">                                echo -ne "  "</span><br><span class="line">                        else</span><br><span class="line">                                echo -ne "\033[1m\033[7m\033[3$&#123;iMap[$j]&#125;m\033[4$&#123;iMap[$j]&#125;m[]\033[0m"</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下落一行</span></span><br><span class="line">function BoxDown()</span><br><span class="line">&#123;</span><br><span class="line">        local y s</span><br><span class="line">        ((y = boxCurY + 1))        #新的y坐标</span><br><span class="line">        if BoxMove $y $boxCurX        #测试是否可以下落一行</span><br><span class="line">        then</span><br><span class="line">                s="`DrawCurBox 0`"        #将旧的方块抹去</span><br><span class="line">                ((boxCurY = y))</span><br><span class="line">                s="$s`DrawCurBox 1`"        #显示新的下落后方块</span><br><span class="line">                echo -ne $s</span><br><span class="line">        else</span><br><span class="line">                #走到这儿, 如果不能下落了</span><br><span class="line">                Box2Map                #将当前移动中的方块贴到背景方块中</span><br><span class="line">                RandomBox        #产生新的方块</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">左移一列</span></span><br><span class="line">function BoxLeft()</span><br><span class="line">&#123;</span><br><span class="line">        local x s</span><br><span class="line">        ((x = boxCurX - 1))</span><br><span class="line">        if BoxMove $boxCurY $x</span><br><span class="line">        then</span><br><span class="line">                s=`DrawCurBox 0`</span><br><span class="line">                ((boxCurX = x))</span><br><span class="line">                s=$s`DrawCurBox 1`</span><br><span class="line">                echo -ne $s</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">右移一列</span></span><br><span class="line">function BoxRight()</span><br><span class="line">&#123;</span><br><span class="line">        local x s</span><br><span class="line">        ((x = boxCurX + 1))</span><br><span class="line">        if BoxMove $boxCurY $x</span><br><span class="line">        then</span><br><span class="line">                s=`DrawCurBox 0`</span><br><span class="line">                ((boxCurX = x))</span><br><span class="line">                s=$s`DrawCurBox 1`</span><br><span class="line">                echo -ne $s</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下落到底</span></span><br><span class="line">function BoxAllDown()</span><br><span class="line">&#123;</span><br><span class="line">        local k j i x y iDown s</span><br><span class="line">        iDown=$iTrayHeight</span><br><span class="line"></span><br><span class="line">        #计算一共需要下落多少行</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + boxCurY))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + boxCurX))</span><br><span class="line">                for ((k = y + 1; k &lt; iTrayHeight; k++))</span><br><span class="line">                do</span><br><span class="line">                        ((i = k * iTrayWidth + x))</span><br><span class="line">                        if (( $&#123;iMap[$i]&#125; != -1)); then break; fi</span><br><span class="line">                done</span><br><span class="line">                ((k -= y + 1))</span><br><span class="line">                if (( $iDown &gt; $k )); then iDown=$k; fi</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        s=`DrawCurBox 0`        #将旧的方块抹去</span><br><span class="line">        ((boxCurY += iDown))</span><br><span class="line">        s=$s`DrawCurBox 1`        #显示新的下落后的方块</span><br><span class="line">        echo -ne $s</span><br><span class="line">        Box2Map                #将当前移动中的方块贴到背景方块中</span><br><span class="line">        RandomBox        #产生新的方块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">旋转方块</span></span><br><span class="line">function BoxRotate()</span><br><span class="line">&#123;</span><br><span class="line">        local iCount iTestRotate boxTest j i s</span><br><span class="line">        iCount=$&#123;countBox[$iBoxCurType]&#125;        #当前的方块经旋转可以产生的样式的数目</span><br><span class="line"></span><br><span class="line">        #计算旋转后的新的样式</span><br><span class="line">        ((iTestRotate = iBoxCurRotate + 1))</span><br><span class="line">        if ((iTestRotate &gt;= iCount))</span><br><span class="line">        then</span><br><span class="line">                ((iTestRotate = 0))</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        #更新到新的样式, 保存老的样式(但不显示)</span><br><span class="line">        for ((j = 0, i = ($&#123;offsetBox[$iBoxCurType]&#125; + $iTestRotate) * 8; j &lt; 8; j++, i++))</span><br><span class="line">        do</span><br><span class="line">                boxTest[$j]=$&#123;boxCur[$j]&#125;</span><br><span class="line">                boxCur[$j]=$&#123;box[$i]&#125;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        if BoxMove $boxCurY $boxCurX        #测试旋转后是否有空间放的下</span><br><span class="line">        then</span><br><span class="line">                #抹去旧的方块</span><br><span class="line">                for ((j = 0; j &lt; 8; j++))</span><br><span class="line">                do</span><br><span class="line">                        boxCur[$j]=$&#123;boxTest[$j]&#125;</span><br><span class="line">                done</span><br><span class="line">                s=`DrawCurBox 0`</span><br><span class="line"></span><br><span class="line">                #画上新的方块</span><br><span class="line">                for ((j = 0, i = ($&#123;offsetBox[$iBoxCurType]&#125; + $iTestRotate) * 8; j &lt; 8; j++, i++))</span><br><span class="line">                do</span><br><span class="line">                        boxCur[$j]=$&#123;box[$i]&#125;</span><br><span class="line">                done</span><br><span class="line">                s=$s`DrawCurBox 1`</span><br><span class="line">                echo -ne $s</span><br><span class="line">                iBoxCurRotate=$iTestRotate</span><br><span class="line">        else</span><br><span class="line">                #不能旋转，还是继续使用老的样式</span><br><span class="line">                for ((j = 0; j &lt; 8; j++))</span><br><span class="line">                do</span><br><span class="line">                        boxCur[$j]=$&#123;boxTest[$j]&#125;</span><br><span class="line">                done</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">DrawCurBox(bDraw), 绘制当前移动中的方块, bDraw为1, 画上, bDraw为0, 抹去方块。</span></span><br><span class="line">function DrawCurBox()</span><br><span class="line">&#123;</span><br><span class="line">        local i j t bDraw sBox s</span><br><span class="line">        bDraw=$1</span><br><span class="line"></span><br><span class="line">        s=""</span><br><span class="line">        if (( bDraw == 0 ))</span><br><span class="line">        then</span><br><span class="line">                sBox="\040\040"</span><br><span class="line">        else</span><br><span class="line">                sBox="[]"</span><br><span class="line">                s=$s"\033[1m\033[7m\033[3$&#123;cBoxCur&#125;m\033[4$&#123;cBoxCur&#125;m"</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = iTrayTop + 1 + $&#123;boxCur[$j]&#125; + boxCurY))</span><br><span class="line">                ((t = iTrayLeft + 1 + 2 * (boxCurX + $&#123;boxCur[$j + 1]&#125;)))</span><br><span class="line">                #\033[y;xH, 光标到(x, y)处</span><br><span class="line">                s=$s"\033[$&#123;i&#125;;$&#123;t&#125;H$&#123;sBox&#125;"</span><br><span class="line">        done</span><br><span class="line">        s=$s"\033[0m"</span><br><span class="line">        echo -n $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">更新新的方块</span></span><br><span class="line">function RandomBox()</span><br><span class="line">&#123;</span><br><span class="line">        local i j t</span><br><span class="line"></span><br><span class="line">        #更新当前移动的方块</span><br><span class="line">        iBoxCurType=$&#123;iBoxNewType&#125;</span><br><span class="line">        iBoxCurRotate=$&#123;iBoxNewRotate&#125;</span><br><span class="line">        cBoxCur=$&#123;cBoxNew&#125;</span><br><span class="line">        for ((j = 0; j &lt; $&#123;#boxNew[@]&#125;; j++))</span><br><span class="line">        do</span><br><span class="line">                boxCur[$j]=$&#123;boxNew[$j]&#125;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #显示当前移动的方块</span><br><span class="line">        if (( $&#123;#boxCur[@]&#125; == 8 ))</span><br><span class="line">        then</span><br><span class="line">                #计算当前方块该从顶端哪一行"冒"出来</span><br><span class="line">                for ((j = 0, t = 4; j &lt; 8; j += 2))</span><br><span class="line">                do</span><br><span class="line">                        if (($&#123;boxCur[$j]&#125; &lt; t)); then t=$&#123;boxCur[$j]&#125;; fi</span><br><span class="line">                done</span><br><span class="line">                ((boxCurY = -t))</span><br><span class="line">                for ((j = 1, i = -4, t = 20; j &lt; 8; j += 2))</span><br><span class="line">                do</span><br><span class="line">                        if (($&#123;boxCur[$j]&#125; &gt; i)); then i=$&#123;boxCur[$j]&#125;; fi</span><br><span class="line">                        if (($&#123;boxCur[$j]&#125; &lt; t)); then t=$&#123;boxCur[$j]&#125;; fi</span><br><span class="line">                done</span><br><span class="line">                ((boxCurX = (iTrayWidth - 1 - i - t) / 2))</span><br><span class="line"></span><br><span class="line">                #显示当前移动的方块</span><br><span class="line">                echo -ne `DrawCurBox 1`</span><br><span class="line"></span><br><span class="line">                #如果方块一出来就没处放，Game over!</span><br><span class="line">                if ! BoxMove $boxCurY $boxCurX</span><br><span class="line">                then</span><br><span class="line">                        kill -$sigExit $&#123;PPID&#125;</span><br><span class="line">                        ShowExit</span><br><span class="line">                fi</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #清除右边预显示的方块</span><br><span class="line">        for ((j = 0; j &lt; 4; j++))</span><br><span class="line">        do</span><br><span class="line">                ((i = iTop + 1 + j))</span><br><span class="line">                ((t = iLeft + 2 * iTrayWidth + 7))</span><br><span class="line">                echo -ne "\033[$&#123;i&#125;;$&#123;t&#125;H        "</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        #随机产生新的方块</span><br><span class="line">        ((iBoxNewType = RANDOM % $&#123;#offsetBox[@]&#125;))</span><br><span class="line">        ((iBoxNewRotate = RANDOM % $&#123;countBox[$iBoxNewType]&#125;))</span><br><span class="line">        for ((j = 0, i = ($&#123;offsetBox[$iBoxNewType]&#125; + $iBoxNewRotate) * 8; j &lt; 8; j++, i++))</span><br><span class="line">        do</span><br><span class="line">                boxNew[$j]=$&#123;box[$i]&#125;;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        ((cBoxNew = $&#123;colorTable[RANDOM % $&#123;#colorTable[@]&#125;]&#125;))</span><br><span class="line"></span><br><span class="line">        #显示右边预显示的方块</span><br><span class="line">        echo -ne "\033[1m\033[7m\033[3$&#123;cBoxNew&#125;m\033[4$&#123;cBoxNew&#125;m"</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = iTop + 1 + $&#123;boxNew[$j]&#125;))</span><br><span class="line">                ((t = iLeft + 2 * iTrayWidth + 7 + 2 * $&#123;boxNew[$j + 1]&#125;))</span><br><span class="line">                echo -ne "\033[$&#123;i&#125;;$&#123;t&#125;H[]"</span><br><span class="line">        done</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">初始绘制</span></span><br><span class="line">function InitDraw()</span><br><span class="line">&#123;</span><br><span class="line">        clear</span><br><span class="line">        RandomBox        #随机产生方块，这时右边预显示窗口中有方快了</span><br><span class="line">        RandomBox        #再随机产生方块，右边预显示窗口中的方块被更新，原先的方块将开始下落</span><br><span class="line">        local i t1 t2 t3</span><br><span class="line"></span><br><span class="line">        #显示边框</span><br><span class="line">        echo -ne "\033[1m"</span><br><span class="line">        echo -ne "\033[3$&#123;cBorder&#125;m\033[4$&#123;cBorder&#125;m"</span><br><span class="line"></span><br><span class="line">        ((t2 = iLeft + 1))</span><br><span class="line">        ((t3 = iLeft + iTrayWidth * 2 + 3))</span><br><span class="line">        for ((i = 0; i &lt; iTrayHeight; i++))</span><br><span class="line">        do</span><br><span class="line">                ((t1 = i + iTop + 2))</span><br><span class="line">                echo -ne "\033[$&#123;t1&#125;;$&#123;t2&#125;H||"</span><br><span class="line">                echo -ne "\033[$&#123;t1&#125;;$&#123;t3&#125;H||"</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        ((t2 = iTop + iTrayHeight + 2))</span><br><span class="line">        for ((i = 0; i &lt; iTrayWidth + 2; i++))</span><br><span class="line">        do</span><br><span class="line">                ((t1 = i * 2 + iLeft + 1))</span><br><span class="line">                echo -ne "\033[$&#123;iTrayTop&#125;;$&#123;t1&#125;H=="</span><br><span class="line">                echo -ne "\033[$&#123;t2&#125;;$&#123;t1&#125;H=="</span><br><span class="line">        done</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #显示"Score"和"Level"字样</span><br><span class="line">        echo -ne "\033[1m"</span><br><span class="line">        ((t1 = iLeft + iTrayWidth * 2 + 7))</span><br><span class="line">        ((t2 = iTop + 10))</span><br><span class="line">        echo -ne "\033[3$&#123;cScore&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;HScore"</span><br><span class="line">        ((t2 = iTop + 11))</span><br><span class="line">        echo -ne "\033[3$&#123;cScoreValue&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;H$&#123;iScore&#125;"</span><br><span class="line">        ((t2 = iTop + 13))</span><br><span class="line">        echo -ne "\033[3$&#123;cScore&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;HLevel"</span><br><span class="line">        ((t2 = iTop + 14))</span><br><span class="line">        echo -ne "\033[3$&#123;cScoreValue&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;H$&#123;iLevel&#125;"</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出时显示GameOVer!</span></span><br><span class="line">function ShowExit()</span><br><span class="line">&#123;</span><br><span class="line">        local y</span><br><span class="line">        ((y = iTrayHeight + iTrayTop + 3))</span><br><span class="line">        echo -e "\033[$&#123;y&#125;;0HGameOver!\033[0m"</span><br><span class="line">        exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示用法.</span></span><br><span class="line">function Usage</span><br><span class="line">&#123;</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">Usage: $APP_NAME</span><br><span class="line">Start tetris game.</span><br><span class="line"></span><br><span class="line">  -h, --help              display this help and exit</span><br><span class="line">      --version           output version information and exit</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">游戏主程序在这儿开始.</span></span><br><span class="line">if [[ "$1" == "-h" || "$1" == "--help" ]]; then</span><br><span class="line">        Usage</span><br><span class="line">elif [[ "$1" == "--version" ]]; then</span><br><span class="line">        echo "$APP_NAME $APP_VERSION"</span><br><span class="line">elif [[ "$1" == "--show" ]]; then</span><br><span class="line">        #当发现具有参数--show时，运行显示函数</span><br><span class="line">        RunAsDisplayer</span><br><span class="line">else</span><br><span class="line">        bash $0 --show&amp;        #以参数--show将本程序再运行一遍</span><br><span class="line">        RunAsKeyReceiver $!        #以上一行产生的进程的进程号作为参数</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p>给当前用户执行此文件的权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 ./Tetris.sh</span><br></pre></td></tr></table></figure><h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><p>有了执行此文件的权限之后，开始执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Tetris.sh</span><br></pre></td></tr></table></figure><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594896756.jpg" alt="1594896756"></p>]]></content>
    
    <summary type="html">
    
      俄罗斯方块的Shell脚本
    
    </summary>
    
    
    
      <category term="Shell" scheme="penghui.club/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>有逼格的希尔排序</title>
    <link href="penghui.club/2020/07/13/%E6%9C%89%E9%80%BC%E6%A0%BC%E7%9A%84%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>penghui.club/2020/07/13/%E6%9C%89%E9%80%BC%E6%A0%BC%E7%9A%84%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-12T23:42:30.000Z</published>
    <updated>2020-07-13T00:21:47.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>鲸落“当鲸鱼在海洋中死去，它的尸体会最终沉入海底。生物学家赋予这个过程一个名字——鲸落（Whale Fall）。一座鲸鱼的尸体可以供养整套生命系统长达百年，这是它留给大海最后的温柔。” </p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="有逼格的希尔排序"><a href="#有逼格的希尔排序" class="headerlink" title="有逼格的希尔排序"></a>有逼格的希尔排序</h2><p>希尔排序是一种基于插入排序的快速的排序算法。希尔排序为了加快速度简单的改进了插入排序，<span style="background-color: yellow; color: red;">交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</span></p><p>希尔排序的思想是使数组中任意<code>间隔为 h</code> 的元素都是有序的。这样的数组成为 <code>h</code> 有序数组。可以这么理解：一个<code>h</code> 有序数组就是<code>h</code> 个互相独立的有序数组编织在一起组成的一个数组。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/xier.jpg" alt="xier"></p><p>实现希尔排序的一种方法是对每一个<code>h</code>，用插入排序将<code>h</code>个子数组独立的排序。但因为子数组是相互独立的，一个更简单的方法是在<code>h-</code>子数组中将每一个元素交换到比它大的元素之前。只需要在插入排序的代码中将移动元素的距离由<code>1</code>改为<code>h</code>即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> ind1, <span class="keyword">int</span> ind2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[ind1]; a[ind1] = a[ind2]; a[ind2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;鲸落“当鲸鱼在海洋中死去，它的尸体会最终沉入海底。生物学家赋予这个过程一个名字——鲸落（Whale Fall）。一座鲸鱼的尸体可以供养整套生命系统长达百年，这是它留给大海最后的温柔。” &lt;/p&gt;
&lt;p&gt;​                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="penghui.club/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>地下城游戏</title>
    <link href="penghui.club/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"/>
    <id>penghui.club/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</id>
    <published>2020-07-11T23:30:47.000Z</published>
    <updated>2020-07-12T00:04:03.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我尚未遇见更好的，只好愿我惦念之人岁岁平安</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a></h2><p>又是 7 月的每日一题，一看题目就是典型的<code>dp</code>。一般<code>难度</code>吧<del>~</del>(让我装个逼d=====(￣▽￣*)b)。</p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只<strong>向右</strong>或<strong>向下</strong>移动一步。</p><p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><table><thead><tr><th>-2 (K)</th><th>-3</th><th>3</th></tr></thead><tbody><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5 (P)</td></tr></tbody></table><p>说明:</p><ul><li><p>骑士的健康点数没有上限。</p></li><li><p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p></li></ul><p>接下来我们就讲讲如何<span style="color: red;background-color: yellow;">英雄救美:</span></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先我们可以看出这是道动态规划问题，在我认为：动态规划就是在<strong>穷举</strong>了所有情况的时候加了个<strong>备忘录</strong>，即有状态的记录每一步的结果，当一步的值取决于我们已求出的结果。</p><h5 id="定义dp："><a href="#定义dp：" class="headerlink" title="定义dp："></a>定义dp：</h5><p>我们定义一个二维数组 <code>dp[m + 1][n + 1]</code>; 则<code>dp[j][j]</code>就表示我们移动到坐标<code>[i][j]</code>的位置时，需要的最少血量。</p><p>题目上说了，骑士每次只<strong>向右</strong>或<strong>向下</strong>移动一步。那么当前状态就和<code>右边的状态</code>和<code>下面的状态</code>有关。所以我们应逆向来搜索（即从<strong>公主的位置—&gt;&gt;骑士的位置</strong>），这不变成了<span style="color: red;background-color: yellow;">美救英雄</span>了吗？</p><p>那么状态转移方式怎么得出？接下来就分情况而定：</p><p>题目给出的坐标数组是：<code>int[][] dungeon</code>;</p><p>当<code>dungeon[i][j] &gt;= dp[i + 1][j] || dungeon[i][j] &gt;= dp[i][j + 1]</code>的时候，我们只需要将<code>dp[i][j] = 1</code>即可，为什么呢？因为我们不论是要走到右边还是下边，当前的血量已经充足够用了，只需要 <code>1</code>点血量走到<code>dungeon[i][j]</code>位置即可。并且无需做其他判断，因为 <code>1</code>是最低血量了。</p><p>其它情况：当前<code>dp[i + 1][j]</code>就和右边状态、下边状态有关了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j] - dungeon[i][j], dp[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br></pre></td></tr></table></figure><h4 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">    <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i --) dp[i][n] = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j --) dp[m][j] = <span class="number">1000000</span>;</span><br><span class="line">    dp[m - <span class="number">1</span>][n] = <span class="number">1</span>; dp[m][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dungeon[i][j] &gt;= dp[i + <span class="number">1</span>][j] || dungeon[i][j] &gt;= dp[i][j + <span class="number">1</span>]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j] - dungeon[i][j], dp[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      地下城游戏
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="penghui.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>spring相关知识点</title>
    <link href="penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-07-06T10:22:17.000Z</published>
    <updated>2020-07-08T07:06:35.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。</p><p>​                                                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h3 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h3><h4 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h4><ul><li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li><li>它是轻量级、松散耦合的。</li><li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li><li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li></ul><h4 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h4><ul><li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li><li>OC - 控制反转</li><li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h4 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h4><p>​        Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。</p><h3 id="依赖注入（IOC）"><a href="#依赖注入（IOC）" class="headerlink" title="依赖注入（IOC）"></a>依赖注入（IOC）</h3><h4 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h4><p>​        Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p><h4 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h4><p>​        在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p><h4 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h4><p>通常，依赖注入可以通过三种方式完成，即：</p><ul><li>构造函数注入</li><li>setter 注入</li><li>接口注入</li></ul><h4 id="区分构造函数注入和-setter-注入。"><a href="#区分构造函数注入和-setter-注入。" class="headerlink" title="区分构造函数注入和 setter 注入。"></a>区分构造函数注入和 setter 注入。</h4><table><thead><tr><th align="left">构造函数注入</th><th align="left">setter 注入</th></tr></thead><tbody><tr><td align="left">任意修改都会创建一个新实例</td><td align="left">任意修改不会创建一个新实例</td></tr><tr><td align="left">适用于设置很多属性</td><td align="left">适用于设置少量属性</td></tr></tbody></table><h4 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h4><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h4 id="区分-BeanFactory-和-ApplicationContext。"><a href="#区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="区分 BeanFactory 和 ApplicationContext。"></a>区分 BeanFactory 和 ApplicationContext。</h4><table><thead><tr><th>BeanFactory</th><th>ApplicationContext</th></tr></thead><tbody><tr><td>它使用懒加载</td><td>它使用即时加载</td></tr><tr><td>它使用语法显式提供资源对象</td><td>它自己创建和管理资源对象</td></tr><tr><td>不支持国际化</td><td>支持国际化</td></tr><tr><td>不支持基于依赖的注解</td><td>支持基于依赖的注解</td></tr></tbody></table><h4 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h4><p>​        Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射机制</strong>。</p><h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h3><h4 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h4><h5 id="1、基于-xml-配置"><a href="#1、基于-xml-配置" class="headerlink" title="1、基于 xml 配置"></a>1、基于 xml 配置</h5><p>​        bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentbean"</span> <span class="attr">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Edureka"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、基于注解配置"><a href="#2、基于注解配置" class="headerlink" title="2、基于注解配置"></a>2、基于注解配置</h5><p>​        您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、基于-Java-API-配置"><a href="#3、基于-Java-API-配置" class="headerlink" title="3、基于 Java API 配置"></a>3、基于 Java API 配置</h5><p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p><ol><li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h4><p> Spring bean 支持 5 种 scope： </p><ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。</li></ul><p>常用的有<code>Singleton</code>、<code>Prototype</code>。 仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。 </p><h4 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h4><p>spring bean 容器的生命周期流程如下：</p><ol><li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 <code>BeanNameAware</code> 接口，则工厂通过传递 bean 的 ID 来调用 <code>setBeanName()</code>。</li><li>如果 bean 实现 <code>BeanFactoryAware</code> 接口，工厂通过传递自身的实例来调用 <code>setBeanFactory()</code>。</li><li>如果为 bean 指定了 <code>init</code> 方法（<bean> 的 <code>init-method</code> 属性），那么将调用它。</li><li>如果存在与 bean 关联的任何 <code>BeanPostProcessors</code>，则调用 <code>postProcessBeforeInitialization()</code> 方法。</li><li>如果存在与 bean 关联的任何 <code>BeanPostProcessors</code>，则将调用 <code>postProcessAfterInitialization()</code> 方法。</li><li>如果 bean 实现 <code>DisposableBean</code> 接口，当 spring 容器关闭时，会调用 <code>destory()</code>。</li><li>如果为 bean 指定了 <code>destroy</code> 方法（<bean> 的 <code>destroy-method</code> 属性），spring 容器关闭时，那么将调用它。</li></ol><h4 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h4><p>​        当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p><h4 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h4><p>​        Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p><p>自动装配的不同模式：</p><ol><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ol><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h4><p>​        不使用 XML 来描述 bean 装配，开发人员通过在相关的类，<strong>方法或字段</strong>声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p><p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p><ul><li><code>@Bean</code> 注解扮演与 元素相同的角色。</li><li><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul><p><em>可以这么来说，当一个类使用 <code>@Configuration</code> 注解标注时，那么该类相当于一个 spring的 xml 配置文件</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h4><p>​        默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p><h4 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h4><ul><li><strong>@Component</strong>：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li><strong>@Controller</strong>：这将一个类标记为 <code>Spring Web MVC</code> 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li><strong>@Service</strong>：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 <code>@Service</code> 而不是 <code>@Component</code>，因为它以更好的方式指定了意图。</li><li><strong>@Repository</strong>：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h4 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h4><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是<span style="background-color: yellow;color: red;">类型驱动</span>的注入。</p><h4 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h4><p><code>@RequestMapping</code> 注解用于将特定 HTTP 请求方法映射到将处理相应请求的<strong>控制器</strong>中的<strong>特定类/方法</strong>。此注释可应用于两个级别：</p><ul><li>类级别（注解标注在类上）：映射请求的 URL</li><li>方法级别（注解标注在方法上）：映射 URL 以及 HTTP 请求方法</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是-AOP？"><a href="#什么是-AOP？" class="headerlink" title="什么是 AOP？"></a>什么是 AOP？</h4><p> AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong> </p><h4 id="什么是-Aspect？"><a href="#什么是-Aspect？" class="headerlink" title="什么是 Aspect？"></a>什么是 Aspect？</h4><p>​        <code>aspect</code> 由 <code>Pointcut</code> 和 <code>Advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</p><p> <strong>可以简单地认为, 使用 @Aspect 注解的类就是一个切面.</strong> </p><h4 id="什么是切点（JoinPoint）"><a href="#什么是切点（JoinPoint）" class="headerlink" title="什么是切点（JoinPoint）"></a>什么是切点（JoinPoint）</h4><p>​        程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理，在 Spring AOP 中, <code>join point</code> 就是方法的执行点。</p><h4 id="什么是通知（Advice）？"><a href="#什么是通知（Advice）？" class="headerlink" title="什么是通知（Advice）？"></a>什么是通知（Advice）？</h4><p>​        特定 <code>JoinPoint</code> 处的 <code>Aspect</code> 所采取的动作称为 <code>Advice</code>。Spring AOP 使用一个 <code>Advice</code> 作为拦截器，在 <code>JoinPoint</code> “周围”维护一系列的拦截器。</p><h4 id="有哪些类型的通知（Advice）？"><a href="#有哪些类型的通知（Advice）？" class="headerlink" title="有哪些类型的通知（Advice）？"></a>有哪些类型的通知（Advice）？</h4><ul><li><strong>Before</strong> - 这些类型的 <code>Advice</code> 在 <code>joinpoint</code> 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li><li><strong>After Returning</strong> - 这些类型的 <code>Advice</code> 在连接点方法正常执行后执行，并使用<code>@AfterReturning</code> 注解标记进行配置。</li><li><strong>After Throwing</strong> - 这些类型的 <code>Advice</code> 仅在 <code>joinpoint</code> 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li><li><strong>After (finally)</strong> - 这些类型的 <code>Advice</code> 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li><li><strong>Around</strong> - 这些类型的 <code>Advice</code> 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li></ul><h4 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h4><p>实现 AOP 的技术，主要分为两大类：</p><ul><li><strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为<strong>编译时增强</strong>；<ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li><strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为<strong>运行时增强</strong>。<ul><li>JDK 动态代理</li><li>CGLIB</li></ul></li></ul><h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h4><p>​        Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p><h4 id="Spring-MVC-工作流程"><a href="#Spring-MVC-工作流程" class="headerlink" title="Spring MVC 工作流程"></a>Spring MVC 工作流程</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1159443997.jpg" alt="1159443997"></p><p>1、用户发送请求至前端控制器<code>DispatcherServlet</code>。</p><p>2、<code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code><strong>处理器映射器。</strong></p><p>3、<strong>处理器映射器</strong>找到具体的处理器(可以根据<strong>xml</strong>配置或者<strong>注解</strong>进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<code>DispatcherServlet</code>。</p><p>4、 <code>DispatcherServlet</code>调用<code>HandlerAdapter</code><strong>处理器适配器。</strong></p><p>5、<code>HandlerAdapter</code>经过适配调用具体的处理器(<code>Controller</code>，也叫<strong>后端控制器</strong>)。</p><p>6、<code>Controller</code>执行完成返回<code>ModelAndView</code>。</p><p>7、<code>HandlerAdapter</code>将<code>controller</code>执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code>。</p><p>8、<code>DispatcherServlet</code>将<code>ModelAndView</code>传给<code>ViewReslover</code><strong>视图解析器</strong>。</p><p>9、<code>ViewReslove</code>r解析后返回具体<strong>View</strong>。</p><p>10、<code>DispatcherServlet</code>根据<strong>View</strong>进行渲染视图（即将模型数据填充至视图中）。 </p><p>11、<code>DispatcherServlet</code>响应用户。</p><h4 id="描述一下-DispatcherServlet-的工作流程"><a href="#描述一下-DispatcherServlet-的工作流程" class="headerlink" title="描述一下 DispatcherServlet 的工作流程"></a>描述一下 DispatcherServlet 的工作流程</h4><ol><li>向服务器发送 HTTP 请求，请求被前端控制器 <code>DispatcherServlet</code> 捕获。</li><li><code>DispatcherServlet</code> 根据 <code>servlet.xml</code> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以<code>HandlerExecutionChain</code> 对象的形式返回。</li><li><code>DispatcherServlet</code> 根据获得的<code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。（附注：如果成功获得<code>HandlerAdapter</code>后，此时将开始执行拦截器的 <code>preHandler(...)</code>方法）。</li><li>提取<code>Request</code>中的模型数据，填充<code>Handler</code>入参，开始执行<code>Handler（Controller)</code>。 在填充<code>Handler</code>的入参过程中，根据你的配置，<code>Spring</code> 将帮你做一些额外的工作：<ol><li><code>HttpMessageConveter</code>： 将请求消息（如 <code>Json、xml</code> 等数据）转换成一个对象，将对象转换为指定的响应信息。</li><li>数据转换：对请求消息进行数据转换。如<code>String</code>转换成<code>Integer、Double</code>等。</li><li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</li></ol></li><li><code>Handler(Controller)</code>执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code> 对象；</li><li>根据返回的<code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>（必须是已经注册到 Spring 容器中的<code>ViewResolver</code>)返回给<code>DispatcherServlet</code>。</li><li><code>ViewResolver</code> 结合<code>Model</code>和<code>View</code>，来渲染视图。</li><li>视图负责将渲染结果返回给客户端。</li></ol><p>原文链接：<a href="https://blog.csdn.net/qq_41701956/article/details/81389067" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81389067</a></p><p>部分内容原文链接：<a href="https://blog.csdn.net/floating_dreaming/article/details/89089214" target="_blank" rel="noopener">https://blog.csdn.net/floating_dreaming/article/details/89089214</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。&lt;/p&gt;
&lt;p&gt;​                                                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="spring" scheme="penghui.club/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>NIO之缓冲区的使用</title>
    <link href="penghui.club/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>penghui.club/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-06T08:17:56.000Z</published>
    <updated>2020-07-07T10:48:21.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>女人错过了她最想嫁的那个男人，就会变得挑剔；男人错过了那个他最想娶的女人，就会变得随意 那时候陪伴我的那个，这里的故事你是否还记得 </p><p>​                                                                                                       —– 网易云热评</p></blockquote><h2 id="NIO之缓冲区的使用"><a href="#NIO之缓冲区的使用" class="headerlink" title="NIO之缓冲区的使用"></a>NIO之缓冲区的使用</h2><p>今年寒假前，在学校图书馆里借了一本关于NIO的书，花了几天时间看完了，但是由于之前没有创建个人博客，所以今天重温一下做个笔记😁。</p><hr><h3 id="首先了解什么是NIO？"><a href="#首先了解什么是NIO？" class="headerlink" title="首先了解什么是NIO？"></a>首先了解什么是NIO？</h3><p>​        常规的 I/O （如InputStream 和 OutputStream）存在很大缺点，就是它们是阻塞的，而<code>NIO</code>解决的就是常规 I/O执行效率低的问题。即采用非阻塞高性能运行的方式来避免出现以前 “笨拙” 的同步 I/O带来的低效率问题。 <code>NIO</code>对常规的 I/O 使用的 byte[] 或 char[] 进行封装，采用 ByteBuffer 类来操作数据，再结合针对 File 或 Socket 技术的 Channel ，采用同步非阻塞技术实现高性能处理。</p><p>​        Buffer 类的信息如下：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594024381559.png" alt="1594024381559"></p><p>​        可以发现 Buffer 是个抽象类，那么它必定有子类，分别是：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594024436930.png" alt="1594024436930"></p><p>​        NIO 中Buffer是一个用于存储基本数据类型值的容器，它以类似于数组有序的方式来存储和组织数据。每个基本数据类型（除去 boolean）都有一个子类与之对应。</p><h3 id="Buffer-类的使用"><a href="#Buffer-类的使用" class="headerlink" title="Buffer 类的使用"></a>Buffer 类的使用</h3><p>​        观察上图，我们可以发现，Buffer 是个抽象类，并不能直接实例化，但是我们会发现，即使它的子类也都是抽象类，同样不可以直接实例化。那么我们该如何创建这些类的对象呢？使用方式是将上面 7 种数据类型的数组包装（wrap）进缓冲区，此时需要借助静态方法 <code>wrap()</code>进行实现。<code>wrap()</code>方法的作用是将数组放入缓冲区，来构建存储不同的数据类型缓冲区。以下以 CharBuffer 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CharBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">char</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>缓冲区为非线程安全的。</em></p><p>​        那么这个缓冲区的实例到底是由哪个类实现的呢？我们点进<code>wrap</code>方法进去看个究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CharBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapCharBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 具体的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapCharBuffer</span> <span class="keyword">extends</span> <span class="title">CharBuffer</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">HeapCharBuffer(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123; <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        hb = buf;</span></span><br><span class="line"><span class="comment">        offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super(-1, off, off + len, buf.length, buf, 0); </span></span><br><span class="line">CharBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// package-private</span></span><br><span class="line">                            <span class="keyword">char</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <strong>原来，<code>CharBuffer</code>是由 <code>HeapCharBuffer</code> 来具体实现的。</strong></p><h3 id="NIO技术的缓冲区的相关方法"><a href="#NIO技术的缓冲区的相关方法" class="headerlink" title="NIO技术的缓冲区的相关方法"></a>NIO技术的缓冲区的相关方法</h3><h4 id="包装数据与获得容量"><a href="#包装数据与获得容量" class="headerlink" title="包装数据与获得容量"></a>包装数据与获得容量</h4><h5 id="capacity（容量）"><a href="#capacity（容量）" class="headerlink" title="capacity（容量）"></a>capacity（容量）</h5><p>​        它代表包含元素的数量。不可是负值，不可被修改。</p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"><span class="keyword">int</span> cap = charbuffer.capacity();</span><br><span class="line">System.out.println(cap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： 3</span></span><br></pre></td></tr></table></figure><h4 id="限制获取与设置"><a href="#限制获取与设置" class="headerlink" title="限制获取与设置"></a>限制获取与设置</h4><h5 id="limit（限制）"><a href="#limit（限制）" class="headerlink" title="limit（限制）"></a>limit（限制）</h5><p>​        返回此缓冲区的限制。什么是缓冲区的限制呢？它代表第一个不应该读取或写入元素的 index（索引）。不可以是负值，并且其值不能大于<code>capacity</code>。如果<code>position</code> 大于新的 <code>limit</code>，则奖<code>position</code>设置为新的<code>limit</code>。如果<code>mark</code>已定义且大于新的<code>limit</code>，则丢弃该<code>mark</code>。<code>limit</code>的应用示例如图所示：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594026005008.jpg" alt="1594026005008"></p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"><span class="keyword">int</span> limit = charbuffer.limit();</span><br><span class="line">System.out.println(<span class="string">"修改前"</span> + limit);</span><br><span class="line"></span><br><span class="line">charbuffer.limit(<span class="number">3</span>);</span><br><span class="line">limit = charbuffer.limit();</span><br><span class="line">System.out.println(<span class="string">"修改后"</span> + limit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// put(索引，数据)</span></span><br><span class="line">charbuffer.put(<span class="number">3</span>, <span class="string">'q'</span>);<span class="comment">// 此位置是第一个不可读不可写的索引,会抛出IndexOutOfBoundException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： </span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IndexOutOfBoundException</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="位置获取与设置"><a href="#位置获取与设置" class="headerlink" title="位置获取与设置"></a>位置获取与设置</h4><h5 id="position（位置）"><a href="#position（位置）" class="headerlink" title="position（位置）"></a>position（位置）</h5><p>​        代表 “下一个” 要读取或写入元素的索引，<code>position</code>不能为负值，并且<code>position</code>不能大于其<code>limit</code>。如果<code>mark</code>已定义且大于新的<code>position</code>，则丢弃该<code>mark</code>。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594026689661.jpg" alt="1594026689661"></p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">// position 默认刚开始为 0</span></span><br><span class="line"><span class="keyword">int</span> position = charbuffer.position();</span><br><span class="line">System.out.println(<span class="string">"修改前: "</span> + position);</span><br><span class="line"></span><br><span class="line">charbuffer.position(<span class="number">3</span>);</span><br><span class="line">position = charbuffer.position();</span><br><span class="line">System.out.println(<span class="string">"修改后: "</span> + position);</span><br><span class="line"></span><br><span class="line">charbuffer.put(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i ++) </span><br><span class="line">    System.out.print(chars[i] + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： </span></span><br><span class="line">修改前: <span class="number">0</span></span><br><span class="line">修改后: <span class="number">3</span></span><br><span class="line">a b c q e</span><br></pre></td></tr></table></figure><h4 id="剩余空间大小获取"><a href="#剩余空间大小获取" class="headerlink" title="剩余空间大小获取"></a>剩余空间大小获取</h4><h5 id="remaining（剩余空间）"><a href="#remaining（剩余空间）" class="headerlink" title="remaining（剩余空间）"></a>remaining（剩余空间）</h5><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    return limit - position</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594027234062.jpg" alt="1594027234062"></p><p>上图：limit - position 会返回 2。</p><h4 id="设置标记："><a href="#设置标记：" class="headerlink" title="设置标记："></a><strong>设置标记：</strong></h4><h5 id="mark（标记）"><a href="#mark（标记）" class="headerlink" title="mark（标记）"></a>mark（标记）</h5><p>​        在此缓冲区的位置设置标记。</p><p>​        标记是一个索引，当我们调用<code>reset()</code>方法时，会将缓冲区的<code>position</code>位置重置为该索引。标记并不是必须的，同样不能是负数，并且不能让它大于<code>position</code>。如果定义<code>mark</code>，则再将<code>position</code>或<code>limit</code>调整为小于该<code>mark</code>的值时，该<code>mark</code>被丢弃，丢弃后其值为 -1。如果未定义<code>mark</code>，那么调用<code>reset()</code>方法将导致抛出<code>InvalidMarkException</code>异常。</p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="还原缓冲区的状态："><a href="#还原缓冲区的状态：" class="headerlink" title="还原缓冲区的状态："></a>还原缓冲区的状态：</h4><h5 id="clear（清除）"><a href="#clear（清除）" class="headerlink" title="clear（清除）"></a>clear（清除）</h5><p>​        还原缓冲区到初始的状态，包含将位置设置为 0 ，将限制（limit）设置为容量（capacity），并丢弃标记（mark），即 “一切为默认”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主要应用场景："><a href="#主要应用场景：" class="headerlink" title="主要应用场景："></a>主要应用场景：</h5><p><strong>对缓冲区存储数据之前调用此方法。</strong></p><h4 id="对缓冲区进行反转："><a href="#对缓冲区进行反转：" class="headerlink" title="对缓冲区进行反转："></a>对缓冲区进行反转：</h4><h5 id="flip（反转）"><a href="#flip（反转）" class="headerlink" title="flip（反转）"></a>flip（反转）</h5><p>​        反转此缓冲区。首先将限制设置为当前位置，然后将位置设置为 0 。丢弃标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意此方法会修改 limit 为 当前 position的值。</em></p><h5 id="主要应用场景：-1"><a href="#主要应用场景：-1" class="headerlink" title="主要应用场景："></a>主要应用场景：</h5><p><strong>当向缓冲区中存储数据，然后再从缓冲区中读取这些数据时，就是使用 flip() 方法的最佳时机。</strong></p><h4 id="重绕缓冲区"><a href="#重绕缓冲区" class="headerlink" title="重绕缓冲区"></a>重绕缓冲区</h4><h5 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h5><p>​        重绕此缓冲区，将位置设置为 0 并丢弃标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主要应用场景：-2"><a href="#主要应用场景：-2" class="headerlink" title="主要应用场景："></a>主要应用场景：</h5><p><strong>“重新写入或获取” 的操作之前调用此方法（假定已经设当设置了限制）。常在重新读取缓冲区中数据时使用。</strong></p><h3 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h3><ol><li>缓冲区的<code>capacity</code>、<code>limit</code>、<code>position</code>都不能是负数。</li><li><code>position</code>不能大于<code>limit</code>。</li><li><code>limit</code>不能大于capacity。</li><li>如果定义<code>mark</code>，在将<code>position</code>或<code>limit</code>调整为小于该<code>mark</code>的值时，该<code>mark</code>被丢弃。</li><li>未定义<code>mark</code>，调用<code>reset()</code>方法将导致抛出<code>InvalidMarkException</code>异常。</li><li>当<code>limit</code>和<code>position</code>值一样时，在指定的<code>position</code>位置写入数据会出现异常。</li></ol><p>喜欢本文的话，<strong>在评论区留个言吧😘</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="NIO" scheme="penghui.club/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>通配符匹配</title>
    <link href="penghui.club/2020/07/05/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    <id>penghui.club/2020/07/05/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</id>
    <published>2020-07-05T06:15:53.000Z</published>
    <updated>2020-07-05T08:29:13.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>到了二十多岁的年纪，我终于承认我真的很平庸，我会更加努力！加油！！！</p><p>​                                                                                                                               —– Halo</p></blockquote><a id="more"></a><h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></h2><p>今天是2020年7月5日，我仍在努力…</p><p>这道题是leetcode每日一题，典型的动态规划问题。虽说难度为<span style="color: red;">困难</span>，但是并不是很难。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;?&#39; 可以匹配任何单个字符。</span><br><span class="line">&#39;*&#39; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a><strong>说明:</strong></h3><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#39;*&#39; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</span><br></pre></td></tr></table></figure><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a><strong>示例 4:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a><strong>示例 5:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h3><p>这道题我本来想着先用递归来解，通过双指针法，不断递归，可惜超时。。。思路如下：</p><p>当 <code>s[i] == p[j]  || p[j] == &#39;?&#39;</code>，进行<code>helper(s, i + 1, p, j + 1);</code> </p><p>当 <code>p[j] == &#39;*&#39;</code>, 进行 <code>helper(s, i + 1, p, j) || helper(s, i + 1, p, j + 1) || helper(s, i, p, j + 1)</code>;</p><p>至于为什么这样做，接下来动态规划的思路会讲解。这里只提供大概得思路，时间复杂度是很高的，不建议使用此方法。</p><h4 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h4><ul><li>首先定义<strong>dp</strong>数组的含义：<code>dp[i][j]</code> 表示字符串 <strong>s</strong> 的前 i 个字符和字符串 <strong>p</strong> 的前 j 个字符是否匹配</li><li>接下来就按照情况划分：<ul><li>1、p[j] 和s[i] 相等；</li><li>2、p[j] = ‘?’；</li><li>3、p[j] = ‘*’；</li></ul></li><li><strong>1和2</strong>：可合为一种 <ul><li>只要<code>dp[i - 1][j - 1]</code>匹配，那么我们可以得出只要<code>p[j]</code> 和<code>s[i]</code> 相等或者<code>[j] = &#39;?&#39;</code>；那么 我们就能 <code>dp[i][j] = dp[i - 1][j - 1]</code>; </li></ul></li><li><strong>3</strong>：当p[j] = ‘*’，分为三种情况，只要这三种情况任意一个为true，那么<code>dp[i][j]</code>就为true：<ul><li>表示一个字符：<code>dp[i][j] = dp[i - 1][j - 1]</code>;</li><li>表示空：<code>dp[i][j] = dp[i][j - 1]</code>;</li><li>表示多个字符：<code>dp[i][j] = dp[i - 1][j]</code>;</li></ul></li></ul><p>这里我们可以使用一个小技巧，在<strong>s 和 p</strong>最前面拼接一个“ ”字符串，既可以防止为空，也可以为接下来的代码做准备：</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    s = <span class="string">" "</span> + s;</span><br><span class="line">    p = <span class="string">" "</span> + p;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> sLen = s.length(), pLen = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen + <span class="number">1</span>][pLen + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sLen; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再看看递归的做法，是不是恍然大悟了呢？😱</strong></p>]]></content>
    
    <summary type="html">
    
      通配符匹配
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="penghui.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Object解读</title>
    <link href="penghui.club/2020/07/03/Object%E8%A7%A3%E8%AF%BB/"/>
    <id>penghui.club/2020/07/03/Object%E8%A7%A3%E8%AF%BB/</id>
    <published>2020-07-03T09:48:04.000Z</published>
    <updated>2020-07-10T12:22:14.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>加油吧！</p><p>​                                                                                                                                                   —– me   </p></blockquote><a id="more"></a><h2 id="Object概述"><a href="#Object概述" class="headerlink" title="Object概述"></a>Object概述</h2><p>Object类位于java.lang包， Java中的每个类都是由这个类扩展而来，所有类都<strong>直接</strong>或者<strong>间接</strong>的<strong>继承</strong>自Object。 所以，所有类都继承了Object中的方法。首先来看看Object中都有那些方法吧！</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593774455032.jpg" alt="1593774455032.jpg"></p><p>随便挑选一个类，就会发现他也有这些个方法：</p><p>这是自己写的类</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593770525068.jpg" alt="1593770525068"></p><p>以下是它的方法：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593770564796.jpg" alt="1593770564796"></p><h3 id="Object中的构造方法"><a href="#Object中的构造方法" class="headerlink" title="Object中的构造方法"></a>Object中的构造方法</h3><p>​        有过java基础的同学都知道，java中如果没有有参的构造方法，那么该类会默认有一个无参的构造方法。</p><p> 所以Object类中具有默认的无参构造<code>Object()</code> 。 </p><h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a><strong>源码：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>方法描述第一行：<strong>返回这个对象的hashcode， 支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。</strong> </p><p>我们来运行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：21685669</span></span><br></pre></td></tr></table></figure><p>该方法把对象的地址值换算成一个整数值，当两个对象不是同一对象，其地址值不同，哈希码值也不一样。 </p><p><em>注意：不同对象的hashcode有可能相同！同一个对象的hashcode一定相同！</em></p><p>当然你可以重写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无论如何打印类对象的hashcode，都是1</span></span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>同一个对象(如果该对象没有被修改)：那么重复调用<code>hashCode()</code>那么返回的int是相同的！ </li><li><code>hashCode()</code>方法默认是由对象的地址转换而来的 </li></ul><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates whether some other object is "equal to" this one.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>返回某个对象是否与此对象“相等”。也就是比较两个对象的地址值是否相等，是否为同一对象。如果相等则返回true，不相等则返回false。 </p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        ObjectTest obj2 = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        <span class="keyword">int</span> hashCode2 = obj2.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">        System.out.println(hashCode2);</span><br><span class="line">        System.out.println(<span class="string">"obj: "</span> + obj);</span><br><span class="line">        System.out.println(<span class="string">"obj2: "</span> + obj2);</span><br><span class="line">        System.out.println(obj.equals(obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line">hashcode:  <span class="number">21685669</span></span><br><span class="line">hashcode2: <span class="number">19997786</span></span><br><span class="line">obj:  niuke.offer.ObjectTest@<span class="number">14</span>ae5a5</span><br><span class="line">obj2: niuke.offer.ObjectTest@<span class="number">131245</span>a</span><br><span class="line">对象是否相等：<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul><li>只有两个对象的地址相同，那么这两个对象才相等。当我们需要重写<code>equals()</code>方法时，<strong>必须重写hashCode()</strong>方法。</li><li><code>equals()</code>方法默认是比较对象的地址，使用的是<code>==</code>等值运算符 </li><li><code>equals()</code>方法还有5个默认的原则：<ul><li>自反性：调用<code>equals()</code>返回的是true，无论这两个对象谁调用<code>equals()</code>都好，返回的都是true 。</li><li>一致性：只要对象没有被修改，那么多次调用还是返回对应的结果！ </li><li>传递性：<code>x.equals(y)</code>和<code>y.equals(z)</code>都返回true，那么可以得出：<code>x.equals(z)</code>返回true 。</li><li>对称性：<code>x.equals(y)</code>和<code>y.equals(x)</code>结果应该是相等的。 </li><li>传入的参数为null，返回的是false </li></ul></li></ul><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><p>我们常用的String已经实现了<code>equals</code>和<code>hashCode</code>方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 地址相等那么两者对象肯定相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断两者长度，相等的话继续判断它们的值</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 发现两字符串值不相等</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 继续判断</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两者值相同返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a string representation of the object. </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p> 返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串表达式。 </p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">System.out.println(obj.toString());</span><br><span class="line"><span class="comment">// 输出：niuke.offer.ObjectTest@14ae5a5</span></span><br><span class="line"><span class="comment">// 类名@对象哈希码的无符号十六进制</span></span><br></pre></td></tr></table></figure><p>通常我们并不会需要用着这种字符串的情况，一般需要重写该方法打印该对象的一些具体信息。</p><h3 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h3><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 拷贝的对象和原对象的引用一般不相同</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 拷贝对象和原对象调用equals一般相等</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 因此往往其成员变量（如果是可变的引用）都需要拷贝一份出去（实现完全独立）</span></span><br><span class="line"><span class="comment"> * Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * 该对象没有实现Cloneable接口会抛出CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. </span></span><br><span class="line"><span class="comment"> * 字段本身不克隆称为`浅克隆`</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a "shallow copy" of this object, not a "deep copy" operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 由于Object没有实现Cloneable接口，如果在Object上调用clone方法一样会抛出异常</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><ul><li>clone方法用于对象的克隆，一般想要克隆出的对象是<strong>独立</strong>的(与原有的对象是分开的) </li><li>深拷贝指的是该对象的成员变量(如果是可变引用)都应该克隆一份，浅拷贝指的是成员变量没有被克隆一份 </li></ul><h3 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h3><h4 id="源码：-4"><a href="#源码：-4" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用wait方法会让线程处于等待状态。直到调用唤醒方法notify或者指定的时间已过</span></span><br><span class="line"><span class="comment"> * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment"> * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The current thread must own this object's monitor.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to</span></span><br><span class="line"><span class="comment"> * 处于等待状态，锁会被释放</span></span><br><span class="line"><span class="comment"> * place itself in the wait set for this object and then to relinquish</span></span><br><span class="line"><span class="comment"> * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt;</span></span><br><span class="line"><span class="comment"> * becomes disabled for thread scheduling purposes and lies dormant</span></span><br><span class="line"><span class="comment"> * until one of four things happens:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 当线程等待时间结束，会回到就绪状态。再次抢到cpu资源时，同步状态与之前调用wait方法</span></span><br><span class="line"><span class="comment"> * 时是一致的！</span></span><br><span class="line"><span class="comment"> * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this</span></span><br><span class="line"><span class="comment"> * object and re-enabled for thread scheduling. It then competes in the</span></span><br><span class="line"><span class="comment"> * usual manner with other threads for the right to synchronize on the</span></span><br><span class="line"><span class="comment"> * object; once it has gained control of the object, all its</span></span><br><span class="line"><span class="comment"> * synchronization claims on the object are restored to the status quo</span></span><br><span class="line"><span class="comment"> * ante - that is, to the situation as of the time that the &#123;<span class="doctag">@code</span> wait&#125;</span></span><br><span class="line"><span class="comment"> * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the</span></span><br><span class="line"><span class="comment"> * invocation of the &#123;<span class="doctag">@code</span> wait&#125; method. Thus, on return from the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; method, the synchronization state of the object and of</span></span><br><span class="line"><span class="comment"> * thread &#123;<span class="doctag">@code</span> T&#125; is exactly as it was when the &#123;<span class="doctag">@code</span> wait&#125; method</span></span><br><span class="line"><span class="comment"> * was invoked.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 调用wait的线程，如果线程中断会抛出InterruptedException（结束等待状态）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment"> * interrupted&#125; by any thread before or while it is waiting, then an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> InterruptedException&#125; is thrown.  This exception is not</span></span><br><span class="line"><span class="comment"> * thrown until the lock status of this object has been restored as</span></span><br><span class="line"><span class="comment"> * described above.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 只会解锁当前调用wait的对象，而该线程的其他对象是不会解锁的</span></span><br><span class="line"><span class="comment"> * Note that the &#123;<span class="doctag">@code</span> wait&#125; method, as it places the current thread</span></span><br><span class="line"><span class="comment"> * into the wait set for this object, unlocks only this object; any</span></span><br><span class="line"><span class="comment"> * other objects on which the current thread may be synchronized remain</span></span><br><span class="line"><span class="comment"> * locked while the thread waits.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><p>导致<code>wait()</code>的线程被唤醒的有4种情况：</p><ul><li>该线程发生中断</li><li>wait 时间已到</li><li>被notify 唤醒（下面会介绍）</li><li>被notifyAll 唤醒</li></ul><p>调用<code>wait()</code>的线程会释放掉锁！</p><h3 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify()方法"></a>notify()方法</h3><h4 id="源码：-5"><a href="#源码：-5" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `随机`唤醒正在等待的对象（可能不止一个等待对象）</span></span><br><span class="line"><span class="comment"> * Wakes up a single thread that is waiting on this object's</span></span><br><span class="line"><span class="comment"> * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment"> * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment"> * the discretion of the implementation. A thread waits on an object's</span></span><br><span class="line"><span class="comment"> * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 3种方式来成为监听器对象的所有者</span></span><br><span class="line"><span class="comment"> * a. 调用该实例的同步方法</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing a synchronized instance method of that object.</span></span><br><span class="line"><span class="comment"> * b. 执行该对象的同步代码块</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing the body of a &#123;<span class="doctag">@code</span> synchronized&#125; statement</span></span><br><span class="line"><span class="comment"> *     that synchronizes on the object.</span></span><br><span class="line"><span class="comment"> * c. 执行对应的静态代码块</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;For objects of type &#123;<span class="doctag">@code</span> Class,&#125; by executing a</span></span><br><span class="line"><span class="comment"> *     synchronized static method of that class.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Only one thread at a time can own an object's monitor.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒所有正在等待队列的线程</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object's monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object's monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h5 id="1、为什么wait和notify在Object方法上？"><a href="#1、为什么wait和notify在Object方法上？" class="headerlink" title="1、为什么wait和notify在Object方法上？"></a>1、为什么wait和notify在Object方法上？</h5><p> 因为我们的<strong>锁是对象锁</strong>， 每个对象都可以成为锁。<strong>让当前线程等待某个对象的锁，当然应该通过这个对象来操作了</strong>。  锁对象是<strong>任意</strong>的，所以这些方法必须定义在Object类中 。</p><h5 id="2、sleep和wait有什么区别？"><a href="#2、sleep和wait有什么区别？" class="headerlink" title="2、sleep和wait有什么区别？"></a>2、sleep和wait有什么区别？</h5><p> <code>Thread.sleep()</code>与<code>Object.wait()</code>二者都可以暂停当前线程，释放CPU控制权。 主要的区别在于<code>Object.wait()</code>在释放CPU同时，<strong>释放了对象锁的控制</strong>。  而<code>Thread.sleep()</code>没有对锁释放 。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;加油吧！&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                   —– me   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="penghui.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP的四次挥手</title>
    <link href="penghui.club/2020/07/01/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>penghui.club/2020/07/01/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2020-07-01T08:34:02.000Z</published>
    <updated>2020-07-01T08:44:39.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第二高峰是乔戈里峰，第三是干城章嘉峰，第四是洛子峰，第五是马卡鲁峰，，，，其实只要尽自己的能力，无论做到第几，都会有人记住的。</p><p>​                                                                                                                                                             —– 网易云热评   </p></blockquote><a id="more"></a><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a><strong>TCP四次挥手</strong></h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/v2-c8b61ed2a249700583b11bc5d16c5711_hd.jpg" alt="v2-c8b61ed2a249700583b11bc5d16c5711_hd"></p><h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a><strong>第一次挥手</strong></h3><p>若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：<br>FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。</p><ul><li>PS1：FIN=1表示该报文段是一个连接释放请求。</li><li>PS2：seq=u，u-1是A向B发送的最后一个字节的序号。</li></ul><h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a><strong>第二次挥手</strong></h3><p>B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：<br>ACK=1，seq=v，ack=u+1。</p><ul><li>PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。</li><li>PS2：seq=v，v-1是B向A发送的最后一个字节的序号。</li><li>PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。</li></ul><p>A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。</p><p>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p><h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a><strong>第三次挥手</strong></h3><p>当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</p><h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a><strong>第四次挥手</strong></h3><p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p><h3 id="为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"><a href="#为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？" class="headerlink" title="为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"></a><strong>为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？</strong></h3><p>为了保证B能收到A的确认应答。<br>若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭</p><p>转载： <a href="https://www.zhihu.com/question/24853633/answer/254224088" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633/answer/254224088</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;第二高峰是乔戈里峰，第三是干城章嘉峰，第四是洛子峰，第五是马卡鲁峰，，，，其实只要尽自己的能力，无论做到第几，都会有人记住的。&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                             —– 网易云热评   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="penghui.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP为什么要三次握手</title>
    <link href="penghui.club/2020/07/01/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>penghui.club/2020/07/01/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2020-07-01T08:10:45.000Z</published>
    <updated>2020-07-01T08:44:05.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>世界上最孤独的鲸鱼 发出的频率是52赫兹 而正常鲸鱼是15至25赫兹 世上没任何鲸鱼能听懂它 它没有鱼群 没有同类 但它没放弃大海 从千里外的太平洋游到大西洋 纵然呐喊二十五年没人应答 但大海有多浩瀚它比别的鲸鱼都清楚。</p><p>​                                                                                                                                                             —– 网易云热评   </p></blockquote><a id="more"></a><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/jisuanjiwangluo.jpg" alt="jisuanjiwangluo"></p><p>起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。<br>服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a><strong>第一次握手</strong></h3><p>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。</p><ul><li>PS1：SYN=1，ACK=0表示该报文段为连接请求报文。</li><li>PS2：x为本次TCP通信的字节流的初始序号。<br>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。</li></ul><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a><strong>第二次握手</strong></h3><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。<br>该应答发送完成后便进入SYN-RCVD状态。</p><ul><li>PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。</li><li>PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。</li><li>PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。</li></ul><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a><strong>第三次握手</strong></h3><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。<br>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。<br>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p><h3 id="为什么连接建立需要三次握手，而不是两次握手？"><a href="#为什么连接建立需要三次握手，而不是两次握手？" class="headerlink" title="为什么连接建立需要三次握手，而不是两次握手？"></a><strong>为什么连接建立需要三次握手，而不是两次握手？</strong></h3><p>防止失效的连接请求报文段被服务端接收，从而产生错误。</p><p>PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</p><p><span style="background-color: yellow; color:red;">若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</span></p><p>转载：<a href="https://www.zhihu.com/question/24853633/answer/254224088" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633/answer/254224088</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世界上最孤独的鲸鱼 发出的频率是52赫兹 而正常鲸鱼是15至25赫兹 世上没任何鲸鱼能听懂它 它没有鱼群 没有同类 但它没放弃大海 从千里外的太平洋游到大西洋 纵然呐喊二十五年没人应答 但大海有多浩瀚它比别的鲸鱼都清楚。&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                             —– 网易云热评   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="penghui.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务概念理解</title>
    <link href="penghui.club/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>penghui.club/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</id>
    <published>2020-06-25T11:26:44.000Z</published>
    <updated>2020-06-25T12:53:21.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><pre><code>有的人只要跋山涉水就可以见面。 只有少数人，需要时光机才能见面。 我在等一场意外的死亡 然后笑着去见孟婆                                                                        ----- 网易云热评</code></pre><a id="more"></a><h2 id="1、事务简介"><a href="#1、事务简介" class="headerlink" title="1、事务简介"></a>1、事务简介</h2><p><strong style="background-color: yellow; color: red;">事务，简短的说就是一组操作要么全部完成，要么全部不做，绝不允许只做其中的一部分操作。</strong ><br>比如银行转账，A账号转给B账号1000元，其中包括两个操作A-1000、B+1000，要么这两个操作全部完成，要么全部不做，决不允许只执行其中一个操作（你可以想想想如果A-1000，但是B没有+1000会有什么后果？/斜眼笑/斜眼笑）。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚:"></a><strong>事务回滚</strong>:</h3><p>当一个事务执行过程中发生了异常、错误，则重新回到最先未开始执行的过程。比如上面那个银行转账过程，假设A-1000操作已经完成，但是在执行B+1000操作时，系统发生位置错误，这时需要回到未执行该转账操作之前的状态，即A、B原来多少钱还是多少钱，一分不能少。</p><h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交:"></a>事务提交:</h3><p>当一个事务执行过程没有发生任何异常、错误，这时我们要保存这个事务的修改。比如上面的银行转账过程，假设A-1000、B+1000操作全部完成，没有出现任何异常、错误，这时需要保存事务执行状态修改（A减少了1000元，B增加了1000元），即事务提交。</p><h2 id="2、事务的特性-ACID"><a href="#2、事务的特性-ACID" class="headerlink" title="2、事务的特性(ACID)"></a>2、事务的特性(ACID)</h2><p>事务具有<strong>四大特性</strong>，如下：</p><p><strong>①、原子性(Atomicity)</strong>：整体 【原子性是指事务包含的所有操作要么全部成功，要么全部失败】<br><strong>②、一致性(Consistency)</strong>：数据 【事务提交后的状态合集称为一致，也就是数据库只包含事务提交的状态】<br><strong>③、隔离性(Isolation)</strong>：并发 【对于任意两个并发的事务A和B，在事务A看来，B要么在A开始之前就已经结束，要么在A结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。】<br><strong>④、持久性(Durability)</strong>：结果 【持久性是指一个事务一旦提交了，就保存到硬盘上，对数据库中的数据的改变就是永久性的】</p><h2 id="3、事务隔离问题"><a href="#3、事务隔离问题" class="headerlink" title="3、事务隔离问题"></a>3、事务隔离问题</h2><p>由于事务可包含多个操作，在多个客户端并发访问过程，可能会发生一个事务只做了一部分操作，此时另外一个事务也开始执行，那么前一个事务的只执行部分操作的中间状态会给第二个事务造成影响。</p><p>再举个转账的例子，比如第一个事务包含A-100000，B+100000两个操作，当它把两个操作执行完后，正准备提交，恰在此时另外一个客户端B开启了第二个事务检查它的余额，此时已经到账了100000元。但是第一个事务对应的哪个顾客发现转错人了，所以执行了事务回滚，那么A、B原来多少钱还是多少钱，此时B客户的事务再查它的余额发现之前的100000元又不见了！</p><h3 id="①、读未提交读-Read-Uncommitted-，也称脏读"><a href="#①、读未提交读-Read-Uncommitted-，也称脏读" class="headerlink" title="①、读未提交读(Read Uncommitted)，也称脏读:"></a><strong>①、读未提交读(Read Uncommitted)，也称脏读</strong>:</h3><p>一个事务读到另一个事务未提交的内容事务B读看到事务A没有提交的内容，比如对A、B账户的修改。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204113244757.jpg" alt="20191204113244757"></p><h3 id="②、不可重复读-Read-Committed"><a href="#②、不可重复读-Read-Committed" class="headerlink" title="②、不可重复读(Read Committed):"></a><strong>②、不可重复读(Read Committed)</strong>:</h3><p>一个事务读到另一个事务已提交的内容（主要是数据更新）此级别解决了读未提交读的问题，即其它事务没有提交的内容对本事务不可见。<br>但是事务B能读到事务A提交的数据更新内容。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204113555818.jpg" alt="20191204113555818"></p><h3 id="③、可重复读-Repeatable-Read-，虚读（幻读）："><a href="#③、可重复读-Repeatable-Read-，虚读（幻读）：" class="headerlink" title="③、可重复读(Repeatable Read)，虚读（幻读）："></a><strong>③、可重复读(Repeatable Read)，虚读（幻读）</strong>：</h3><p>一个事务读到另一个事务已提交的内容（主要是数据插入）此级别解决了读未提交读、不可重复读的问题，事务B能读到事务A提交的数据插入内容。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204114519339.jpg" alt="20191204114519339"></p><h3 id="④、可串行化-Serializable-："><a href="#④、可串行化-Serializable-：" class="headerlink" title="④、可串行化(Serializable)："></a><strong>④、可串行化(Serializable)</strong>：</h3><p>最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204120121806.jpg" alt="20191204120121806"></p><h2 id="4、事务锁"><a href="#4、事务锁" class="headerlink" title="4、事务锁"></a>4、事务锁</h2><p>为了解决事务隔离性问题，引入锁的概念，只有拿到锁的事务才可对数据库进行读写操作\color{red}只有拿到锁的事务才可对数据库进行读写操作只有拿到锁的事务才可对数据库进行读写操作。事务有两种锁，并且有相应的权限。</p><h3 id="①、读锁，也称为共享锁。"><a href="#①、读锁，也称为共享锁。" class="headerlink" title="①、读锁，也称为共享锁。"></a>①、读锁，也称为共享锁。</h3><p>某个事务A拿到该锁时，事务A只能进行读操作，此时其他事务也可以拿到这把锁（共享）。</p><h3 id="②、写锁，也称为排它锁。"><a href="#②、写锁，也称为排它锁。" class="headerlink" title="②、写锁，也称为排它锁。"></a>②、写锁，也称为排它锁。</h3><p>某个事务A拿到该锁时，事务A能进行读、写操作，此时其他事务不能拿到这把锁（排它）。<br>如果某个事务A拿到了读锁，其它事务可以拿到读锁（共享），但是无法获取写锁。<br>如果某个事务A拿到了写锁，其他事务既不能拿到写锁，也拿不到读锁！</p><h3 id="③、锁的粒度"><a href="#③、锁的粒度" class="headerlink" title="③、锁的粒度"></a>③、锁的粒度</h3><p>所谓锁的粒度，就是锁的范围，比如如果锁的范围是一张表，则事务A获取写锁后，只能事务A进行读、写，其他事务全部要靠边站。<br>如果锁的粒度是事务A需要操作的某几行记录，其它记录如果其他事务拿到锁仍然可以读、写。</p><p><strong>一般情况下，锁的粒度越小（锁的范围小），则并发问题解决越好（事务都是并发执行），但是效率越低，因为需要大量的资源来确保各个事务的锁的粒度没有交集、冲突。</strong></p><p><strong>锁的粒度越大（锁的范围大），则并发问题解决越差（其他事务都在等待），但是效率较高，因为不要资源来控制各个事务的锁粒度交集问题。</strong></p><h2 id="5、运用锁解决隔离性问题"><a href="#5、运用锁解决隔离性问题" class="headerlink" title="5、运用锁解决隔离性问题"></a>5、运用锁解决隔离性问题</h2><p>这里演示一下使用写锁解决读未提交读的问题，其它并发问题都可以通过类似的方法解决。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204124729517.jpg" alt="20191204124729517"></p><p>原文链接：<a href="https://blog.csdn.net/qq_41855420/article/details/103382189" target="_blank" rel="noopener">https://blog.csdn.net/qq_41855420/article/details/103382189</a></p>]]></content>
    
    <summary type="html">
    
      数据库事务概念
    
    </summary>
    
    
    
      <category term="数据库" scheme="penghui.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉搜索树详解(附C++代码实现查找、插入、删除操作)</title>
    <link href="penghui.club/2020/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%AF%A6%E8%A7%A3-%E9%99%84C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <id>penghui.club/2020/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%AF%A6%E8%A7%A3-%E9%99%84C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-24T09:43:19.000Z</published>
    <updated>2020-06-25T12:53:39.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多年以后的某个深夜。你会不会突然想起我 然后泪如泉涌 。才发现你曾亏欠我太多。你陪我一程。可我会惦记你一生。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二叉搜索树详解"><a href="#二叉搜索树详解" class="headerlink" title="二叉搜索树详解"></a>二叉搜索树详解</h2><h3 id="一、二叉搜索树简述"><a href="#一、二叉搜索树简述" class="headerlink" title="一、二叉搜索树简述"></a>一、<code>二叉搜索树</code>简述</h3><p>  二叉搜索树大致定义为二叉树的左子树任意节点的值小于根节点的值，右子树任意节点的值大于根节点的值，并且左子树、右子树同样也符合二叉搜索树的定义（递归定义）。中序遍历顺序为左根右，所以二叉搜索树的典型特征是中序遍历序列有序。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041722005953.jpg" alt="2020041722005953"></p><h3 id="二、二叉搜索树相关操作"><a href="#二、二叉搜索树相关操作" class="headerlink" title="二、二叉搜索树相关操作"></a>二、二叉搜索树相关操作</h3><p>  为了能让大家更好的理解二叉搜索树，将提供C++的编码实现。下面是TreeNode结构体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里额外添加了parent指针，主要是为了访问父节点方便</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 三个指针分别指向父节点、左子树根节点、右子树根节点</span></span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value) : value(value), parent(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value, TreeNode *parent, TreeNode *left, TreeNode *right) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right =right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color: red;">温馨提示：</span>查找、插入、删除节点三个操作的复杂度依次增加，如果觉得有点压力，请按照顺序依次阅读，稳扎稳打。</p><h4 id="1、二叉搜索树中节点的查找"><a href="#1、二叉搜索树中节点的查找" class="headerlink" title="1、二叉搜索树中节点的查找"></a>1、二叉搜索树中节点的查找</h4><p>  二叉搜索树设计成左 &lt; 根 &lt; 右（中序遍历有序），一个很重要的动机就是快速查找。有过一点算法基础的应该能想到有一种搜索策略非常相似，没错就是二分搜索，每次将target与搜索区间（递增有序）的中间值mid比较，如果target &lt; mid则缩小搜索区间为[left, mid - 1],如果target &gt; mid则缩小搜索区间为[mid + 1, right],否则target == mid。辣么再来看看二叉搜索树中查找的伪代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root 指向二叉搜索树的根，target为需要搜索的值</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> root-&gt;value == target</span><br><span class="line">        成功搜索到了 <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> root-&gt;value &gt; target</span><br><span class="line">        <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">        <span class="comment">// 既然root-&gt;value &gt; target，那么只可能出现在左子树，转移root到左子树</span></span><br><span class="line">        root = root-&gt;left</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则root-&gt;value &lt; target</span></span><br><span class="line">        <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">        <span class="comment">// 既然root-&gt;value &lt; target，那么只可能出现在右子树，转移root到右子树</span></span><br><span class="line">        root = root-&gt;right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// root == NULL，二叉搜索树中没有target</span></span><br></pre></td></tr></table></figure><h5 id="C-代码实现："><a href="#C-代码实现：" class="headerlink" title="C++代码实现："></a>C++代码实现：</h5><p>// 在二叉搜索树中查找target，存在返回对应的指针，否则返NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">searchNode</span><span class="params">(TreeNode *root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;value == target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;value &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然root-&gt;value &gt; target，那么只可能出现在左子树，转移root到左子树</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则root-&gt;value &lt; target</span></span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然root-&gt;value &lt; target，那么只可能出现在右子树，转移root到右子树</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、二叉搜索树中节点的插入"><a href="#2、二叉搜索树中节点的插入" class="headerlink" title="2、二叉搜索树中节点的插入"></a>2、二叉搜索树中节点的插入</h4><p>  二叉搜索树中查找充分利用左 &lt; 根 &lt; 右特性，辣么插入也能用上这个特性么？答案是显然的。<br>  首先思考一下，我们插入节点后是不是还需要维持二叉树仍然满足二叉搜索树特性，这是必须的，要不能你的二叉搜索树就变成一次性的了。辣么我们就先要找到它真实应该插入的位置，保证中序遍历为递增有序。下面是删除的伪代码.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root 指向二叉搜索树的根，value为需要插入的值</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">// 二叉搜索树为空，插入的节点即是根节点</span></span><br><span class="line">    root = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 我们需要找到插入的位置</span></span><br><span class="line">    TreeNode *ptr = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ptr-&gt;value == value</span><br><span class="line">            <span class="comment">// 树中已经存在这个value，不进行插入（这里简化逻辑）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ptr-&gt;value &gt; value</span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然ptr-&gt;value &gt; value，value只能插入ptr左子树</span></span><br><span class="line">            <span class="keyword">if</span> ptr-&gt;left == <span class="literal">NULL</span></span><br><span class="line">                <span class="comment">// 如果ptr左子树为空，则插入的节点正好做左子树的根</span></span><br><span class="line">                ptr-&gt;left = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则转移到左子树，继续查找</span></span><br><span class="line">                ptr = ptr-&gt;left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然ptr-&gt;value &lt; value，value只能插入ptr右子树</span></span><br><span class="line">            <span class="keyword">if</span> ptr-&gt;right == <span class="literal">NULL</span></span><br><span class="line">                <span class="comment">// 如果ptr右子树为空，则插入的节点正好做右子树的根</span></span><br><span class="line">                ptr-&gt;right = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则转移到右子树，继续查找</span></span><br><span class="line">                ptr = ptr-&gt;right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>C++代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中插入value，如果二叉树中已经存在则不进行插入（简化处理逻辑）</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">searchNode</span><span class="params">(TreeNode *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 二叉搜索树为空，插入的节点即是根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 我们需要找到插入的位置</span></span><br><span class="line">        TreeNode *ptr = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;value == value) &#123;</span><br><span class="line">                <span class="comment">// 树中已经存在这个value，不进行插入（这里简化逻辑）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;value &gt; value) &#123;</span><br><span class="line">                <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">                <span class="comment">// 既然ptr-&gt;value &gt; value，value只能插入ptr左子树</span></span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果ptr左子树为空，则插入的节点正好做左子树的根</span></span><br><span class="line">                    ptr-&gt;left = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则转移到左子树，继续查找</span></span><br><span class="line">                    ptr = ptr-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">                <span class="comment">// 既然ptr-&gt;value &lt; value，value只能插入ptr右子树</span></span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果ptr右子树为空，则插入的节点正好做右子树的根</span></span><br><span class="line">                    ptr-&gt;right = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则转移到右子树，继续查找</span></span><br><span class="line">                    ptr = ptr-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、二叉搜索树中节点的删除"><a href="#3、二叉搜索树中节点的删除" class="headerlink" title="3、二叉搜索树中节点的删除"></a>3、二叉搜索树中节点的删除</h4><p>  在二叉搜索树删除节点，首先我们应该在树中查找到这个节点的位置吧，然后将其移除，并且移除后我们需要进行调整，使其任然满足二叉搜索树。这个删除操作可以分成好几种情况，需要分别讨论。</p><h5 id="①、删除叶节点"><a href="#①、删除叶节点" class="headerlink" title="①、删除叶节点"></a>①、删除叶节点</h5><p>  删除叶节点，只要将其移除即可，不需要进行任何调整操作。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041808272493.jpg" alt="2020041808272493"></p><h5 id="②、删除非叶节点"><a href="#②、删除非叶节点" class="headerlink" title="②、删除非叶节点"></a>②、删除非叶节点</h5><p>  删除非叶节点可以细分为两种，第一种是删除有右子树的节点，删除节点后需要将右子树中序遍历第一个节点填充到删除节点A位置（为什么选右子树中序遍历第一个节点？因为整棵树的中序遍历序列中，节点A的下一个节点就是其右子树中序遍历的第一个节点）。<br>  右子树中序遍历第一个节点为某个节点的左子节点，直接将最左的左子节点填补到已删除节点的位置。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041808351744.jpg" alt="2020041808351744"></p><h5 id="a、删除节点有右子树"><a href="#a、删除节点有右子树" class="headerlink" title="a、删除节点有右子树"></a>a、删除节点有右子树</h5><p>  右子树中序遍历序列中的第一个节点为某个没有左子节点的节点B。将节点B填入已删除节点的位置，并且将节点B的右子树置于节点B的位置。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418084409899.jpg" alt="20200418084409899"></p><h5 id="b、删除节点没有右子树"><a href="#b、删除节点没有右子树" class="headerlink" title="b、删除节点没有右子树"></a>b、删除节点没有右子树</h5><p>  第二种是删除没有右子树的节点A，此时寻找整颗二叉树中序遍历中节点A的下一个节点，稍微复杂一点，需要利用parent指针。找到远祖父节点B，并且使得节点A在远祖父节点B的左子树中！远祖父节点B.value替换到节点A.value后，它自己也需要它的下一个节点来填充。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418090738723.jpg" alt="20200418090738723"><br>  <span style="color: red">备注：</span>其实根本不需要进行删除操作，只要寻找到这个节点中序遍历序列的下一个节点，然后直接替换即可。<br>C++代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中插入value，如果二叉树中已经存在则不进行插入（简化处理逻辑）</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">deleteNode</span><span class="params">(TreeNode *root, TreeNode *targetPtr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetPtr == <span class="literal">NULL</span> || root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == targetPtr &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 一、删除的是根节点，并且根节点没有右子树</span></span><br><span class="line">        <span class="comment">// 处理：切断targetPtr与左子树的关联，返回左子树，释放targetPtr</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetPtr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> targetPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (targetPtr-&gt;left == targetPtr-&gt;right) &#123;</span><br><span class="line">        <span class="comment">// 二、删除的叶节点</span></span><br><span class="line">        <span class="comment">// targetPtr-&gt;left == targetPtr-&gt;right,只能是同时为NULL</span></span><br><span class="line">        <span class="comment">// 操作：切断parent与targetPtr的关联，返回root，释放targetPtr</span></span><br><span class="line">        <span class="keyword">if</span> (targetPtr-&gt;parent-&gt;left == targetPtr) &#123;</span><br><span class="line">            targetPtr-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetPtr-&gt;parent-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切断targetPtr 与targetPtr-&gt;parent的关联</span></span><br><span class="line">        targetPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> targetPtr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetPtr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 三、删除节点右子树为空      需要找到远祖父节点</span></span><br><span class="line">        TreeNode *pParent = targetPtr;</span><br><span class="line">        <span class="comment">// 祖父节点B，并且使得节点targetPtr在远祖父节点B的左子树</span></span><br><span class="line">        <span class="keyword">while</span> (pParent-&gt;parent != <span class="literal">NULL</span> &amp;&amp; pParent-&gt;parent-&gt;right == pParent) &#123;</span><br><span class="line">            pParent = pParent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pParent-&gt;parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果targetPtr不存在一个远祖父节点B，使得leftPtr在远祖父B的左子树</span></span><br><span class="line">            <span class="comment">// 操作：只能删除这个节点，并且把左子树放到当前节点的位置</span></span><br><span class="line">            targetPtr-&gt;parent-&gt;right = targetPtr-&gt;left;</span><br><span class="line">            targetPtr-&gt;left-&gt;parent = targetPtr-&gt;parent;</span><br><span class="line">            <span class="comment">// 切断targetPtr与parent、left的关系</span></span><br><span class="line">            targetPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">            targetPtr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> targetPtr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则pParent-&gt;parent-&gt;value替换targetPtr-&gt;value，再删除pParent-&gt;parent（递归）</span></span><br><span class="line">            targetPtr-&gt;value = pParent-&gt;parent-&gt;value;</span><br><span class="line">            root = deleteNode(root, pParent-&gt;parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 四、删除节点存在右子树，直接在右子树寻找中序遍历的第一个节点</span></span><br><span class="line">        TreeNode * leftPtr = targetPtr-&gt;right;</span><br><span class="line">        <span class="comment">// 一直往left寻找</span></span><br><span class="line">        <span class="keyword">while</span> (leftPtr-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            leftPtr = leftPtr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将leftPtr-&gt;value替换到targetPtr-&gt;value</span></span><br><span class="line">        targetPtr-&gt;value = leftPtr-&gt;value;</span><br><span class="line">        <span class="comment">// targetPtr-&gt;right就是leftPtr</span></span><br><span class="line">        <span class="keyword">if</span> (targetPtr-&gt;right == leftPtr) &#123;</span><br><span class="line">            <span class="comment">// 将targetPtr-&gt;right指向leftPtr右子树</span></span><br><span class="line">            targetPtr-&gt;right = leftPtr-&gt;right;</span><br><span class="line">            <span class="comment">// 如果targetPtr-&gt;right ！= NULL，还需要设置parent</span></span><br><span class="line">            <span class="keyword">if</span> (leftPtr-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                leftPtr-&gt;right-&gt;parent = targetPtr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则leftPtr-&gt;parent与leftPtr切断关系</span></span><br><span class="line">            leftPtr-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将leftPtr于其parent切断关系并释放</span></span><br><span class="line">        leftPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> leftPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">deleteNodeByValue</span><span class="params">(TreeNode *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先查找value所在的位置</span></span><br><span class="line">    TreeNode *targetPtr = searchNode(root, value);</span><br><span class="line">    <span class="keyword">if</span> (targetPtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// value都没找到还删除啥...</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deleteNode(root, targetPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、思考与总结"><a href="#三、思考与总结" class="headerlink" title="三、思考与总结"></a>三、思考与总结</h3><p>  可以看出二叉搜索树的查找、插入还是比较简单的，删除稍微复杂一点。不过二叉搜索树可能存在退化成链表的缺陷，比如给你一个本来递增有序的序列让你插入到一颗空二叉搜索树中，这时就退化成链表了。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418111144946.jpg" alt="20200418111144946"><br>  因此我们需要将二叉搜索树增加平衡的特性，即AVL树或红黑树。<br>原文链接：<a href="https://hestyle.blog.csdn.net/article/details/105595528" target="_blank" rel="noopener">https://hestyle.blog.csdn.net/article/details/105595528</a></p>]]></content>
    
    <summary type="html">
    
      数据结构之二叉搜索树
    
    </summary>
    
    
    
      <category term="数据结构" scheme="penghui.club/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="penghui.club/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉树、AVL树、红黑树、Trie树、B树、B+树、B*树浅析</title>
    <link href="penghui.club/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81Trie%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E6%B5%85%E6%9E%90/"/>
    <id>penghui.club/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81Trie%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E6%B5%85%E6%9E%90/</id>
    <published>2020-06-23T10:31:53.000Z</published>
    <updated>2020-06-24T06:24:27.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">夏天迟暮的霞光，正如皆是笑意的你。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数据结构之二叉树、AVL树、红黑树、Trie树、B树、B-树、B-树浅析"><a href="#数据结构之二叉树、AVL树、红黑树、Trie树、B树、B-树、B-树浅析" class="headerlink" title="数据结构之二叉树、AVL树、红黑树、Trie树、B树、B+树、B*树浅析"></a>数据结构之二叉树、AVL树、红黑树、Trie树、B树、B+树、B*树浅析</h2><p>树，作为五大经典数据结构之一，有许多运用场景，比如MySQL数据库的B+树（数据结构的重要性不用强调了吧）。下面将对二叉树、红黑树、B树、B+树等树结构进行一些概念区分与总结，此篇博客适合新手、有一定数据结构基础的小伙伴。</p><h3 id="一、树的划分"><a href="#一、树的划分" class="headerlink" title="一、树的划分"></a>一、树的划分</h3><p>  根据子节点的个数可以划分成N叉树（一般N ≥ 2），N叉树拥有的特征是每个节点至多有N个子节点。</p><p>比如，N = 2时，称为二叉树，每个节点至多只有2个节点。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407082832601.jpg" alt="20200407082832601"><br>比如，N = 3时，称为三叉树，每个节点至多只有3个节点。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407083131618.jpg" alt="20200407083131618"><br><span style="color: red;">注意：</span>特别的当N = 1时，此时是”一叉树”（一般没有这个概念，这只是我个人这么叫），其实”一叉树”就是链表。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407083801385.jpg" alt="20200407083801385"><br>还有一点，树的定义并不是很严谨，因为它强调的是每个节点至多有N个子节点，那么，如果某N叉树的每个节点都至多只有N - 1个节点，那么它也可以称为N - 1叉树，反过来，它也可以称为K叉树（K ≥ N）。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407084732264.jpg" alt="20200407084732264"></p><h3 id="二、二叉树（重点）"><a href="#二、二叉树（重点）" class="headerlink" title="二、二叉树（重点）"></a>二、二叉树（重点）</h3><p>  由上面的概念可知，当N = 2时，称为二叉树。在二叉树还有左子树、右子树、左孩子、右孩子的概念。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407085832323.jpg" alt="20200407085832323"></p><h4 id="1、二叉树的遍历方式"><a href="#1、二叉树的遍历方式" class="headerlink" title="1、二叉树的遍历方式"></a>1、二叉树的遍历方式</h4><p>  由二叉树的结构可知，每个节点都是由左子节点、右子节点、父节点构成（有些节点的左或右子节点为空，但不能说它没有左或右子节点）。根据节点的访问顺序可排列出 左父右、左右父、父左右、右父左、右左父、父右左6种情况，但是一般要求左子节点比右子节点先访问，因此剩下 左父右、左右父、父左右三种情况。</p><h5 id="①、中序遍历（左父右）"><a href="#①、中序遍历（左父右）" class="headerlink" title="①、中序遍历（左父右）"></a>①、中序遍历（左父右）</h5><p>  对于每个节点，先访问它的左子树，再访问本节点，最后访问它的右子树，对于左子树、右子树也符合这个规定（递归定义）。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407091405102.jpg" alt="20200407091405102"></p><h5 id="②、后序遍历（左右父）"><a href="#②、后序遍历（左右父）" class="headerlink" title="②、后序遍历（左右父）"></a>②、后序遍历（左右父）</h5><p>  对于每个节点，先访问它的左子树，再访问它的右子树，最后访问本节点，对于左子树、右子树也符合这个规定（递归定义）。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407093217486.jpg" alt="20200407093217486"></p><h5 id="③、前序遍历（父左右）"><a href="#③、前序遍历（父左右）" class="headerlink" title="③、前序遍历（父左右）"></a>③、前序遍历（父左右）</h5><p>  对于每个节点，先访问本节点，再访问它的左子树，最后访问它的右子树，对于左子树、右子树也符合这个规定（递归定义）。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020040709330051.jpg" alt="2020040709330051"><br><span style="color: red;">注：</span>其实还有一种遍历方式，层次遍历，即按层访问二叉树。</p><h4 id="2、二叉树的特例"><a href="#2、二叉树的特例" class="headerlink" title="2、二叉树的特例"></a>2、二叉树的特例</h4><h5 id="①、二叉搜索树"><a href="#①、二叉搜索树" class="headerlink" title="①、二叉搜索树"></a>①、二叉搜索树</h5><p>  二叉搜索树的定义是对于某二叉树的每个节点b，它的左子树A的所有节点的值都小于节点b的值，它的右子树B的所有节点的值都大于节点b的值，并且左子树A、右子树B同样符合这个定义（递归定义）。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407152634442.jpg" alt="20200407152634442"></p><p>对于值为10的节点，左子树的所有节点的值 &lt; 10，右子树的所有节点的值 &gt; 10，并且左子树、右子树中的所有节点同样 左 &lt; 父 &lt; 右 的定义。</p><p><span style="color: red;">表现特征：</span>二叉搜索树的定义简化一下就是左 &lt; 父 &lt; 右规则，还记先前介绍的中序遍历么，是不是发现了什么，中序遍历顺序不也是如此么。其实二叉搜索树的变现特征就是中序遍历得到的序列递增。（可能会有小伙伴问，为什么要引入这个特性呢？答案是查找方便。如果我们需要你在二叉树中查target = 7这个值是否存在，从根节点入手，如果target = root，查找成功，停止查找；若target &lt; root，转到左子树，否则target &gt; root，转到右子树。）</p><h5 id="②、平衡二叉树"><a href="#②、平衡二叉树" class="headerlink" title="②、平衡二叉树"></a>②、平衡二叉树</h5><p>  平衡二叉树定义是某二叉树的左、右两个子树的 高度差的绝对值不超过1，并且左、右两个子树也都是一棵平衡二叉树（递归定义）。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020040715495833.jpg" alt="2020040715495833"></p><p>那么问题来了，为啥又要引入平衡这个概念呢？<br>可以看出平衡主要是限制树的整体高度，将左、右子树的高度差缩减到1之内。</p><h5 id="③、平衡二叉搜索树-AVL树、红黑树"><a href="#③、平衡二叉搜索树-AVL树、红黑树" class="headerlink" title="③、平衡二叉搜索树(AVL树、红黑树)"></a>③、平衡二叉搜索树(AVL树、红黑树)</h5><p>  平衡二叉搜索树，顾名思义，是二叉树同时满足平衡二叉树以及二叉搜索树的定义，即二叉树不但中序遍历为递增序列，并且树还平衡。</p><p>问题又来了，引入平衡二叉搜索树又是为啥目的捏？看完下图你就明白了。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407191645970.jpg" alt="20200407191645970"></p><p>上图左边的树是平衡二叉搜索树，右边是一颗非平衡的二叉搜索树。如果给你这两颗树，让你搜索target = 15，你会选择那一颗？你肯定会选择左边的吧，因为它看起来更矮一些，根据上面介绍的二叉搜索树的查找规则，我们每次都大概能排除掉剩余节点中的一半（最优的情况下，搜索复杂度为log2n）。</p><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，其实它就是上面介绍的平衡二叉搜索树。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>由于平衡二叉搜索树的定义比较苛刻，实际过程中生成并维持一颗平衡二叉搜索树是比较复杂的，而红黑树放宽了平衡条件的限制，引入弱平衡的概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">红黑树的定义：</span><br><span class="line">1.节点是红色或黑色。</span><br><span class="line">2.根是黑色。</span><br><span class="line">3.所有叶子都是黑色（叶子是NIL节点）。</span><br><span class="line">4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</span><br><span class="line">5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200425164845697.jpg" alt="20200425164845697"></p><h3 id="三、多叉树"><a href="#三、多叉树" class="headerlink" title="三、多叉树"></a>三、多叉树</h3><p>  根据先前树的划分，对于多叉树也有父节点、子节点、兄弟节点的概念。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407164449689.jpg" alt="20200407164449689"></p><h4 id="1、Trie树（前缀树）"><a href="#1、Trie树（前缀树）" class="headerlink" title="1、Trie树（前缀树）"></a>1、Trie树（前缀树）</h4><p>  Trie树其实就是前缀树，运用于大量字符串的存放。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407165308310.jpg" alt="20200407165308310"></p><p>其实Trie树的关键就是把每个字符串的前缀进行合并，也称前缀树。</p><p><span style="color: red;">注意：</span>在Trie树中，每个节点的子节点可能有26个，因为对于每个字符串的下一个字符可能是a ~ z中的任意字母。并且26个子节点需要保持有序。</p><h4 id="2、B树"><a href="#2、B树" class="headerlink" title="2、B树"></a>2、B树</h4><p>  B树是多路搜索树，对于树中的非叶子节点，如果放了m个关键字，就同时需要放m+1个指向子节点的指针，根节点的子节点数为[2, N]，其他节点的子节点数为[N/2,N]。并且所有关键字在整颗树中只出现一次，非叶子结点可以命中所有叶子结点位于同一层。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407170643924.jpg" alt="20200407170643924"></p><h4 id="3、B-树"><a href="#3、B-树" class="headerlink" title="3、B+树"></a>3、B+树</h4><p>  B+树是在B树上进行改造升级，把叶子节点层串成一个链表，并且父节点修改为每个子节点关键字序列的最大值。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407191943282.jpg" alt="20200407191943282"></p><p>MySQL数据库的表结构底层数据存储用的就是B+树。</p><h4 id="4、B-树"><a href="#4、B-树" class="headerlink" title="4、B*树"></a>4、B*树</h4><p>  B*树是在B+树的基础上再次进行升级，把非叶子节点层也用串成链表。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407192112176.jpg" alt="20200407192112176"></p><p>个人总结：AVL树、红黑树都是二叉树，并且是平衡二叉搜索树，Trie树、B树、B+树、B*树都是多叉树，并且是多叉搜索树。一般编程算法题中，二叉树使用的较多。对于多叉树，除非是专业的数据结构设计人员，用的是比较少的，但是这并不说明多叉树没有用武之地，文章中多次提及MySQL数据库中的表中的数据就是用B+树存储。（本博客多叉树用的篇幅很少，但是B树、B+树等多叉树的插入、删除节点是比较复杂的，可能会涉及到节点的拆分、合并，但是博主能力有限啊）</p><p>以上就是数据结构之二叉树、红黑树、B树、B+树、Trie树浅析的主要内容。</p>]]></content>
    
    <summary type="html">
    
      数据结构之树
    
    </summary>
    
    
    
      <category term="数据结构" scheme="penghui.club/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="penghui.club/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>基本计算器</title>
    <link href="penghui.club/2020/06/21/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>penghui.club/2020/06/21/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2020-06-21T12:34:22.000Z</published>
    <updated>2020-06-22T00:00:20.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我真的接受不了有很多男闺蜜的女孩子。</span><br><span class="line"></span><br><span class="line">                                                                    ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器</h2><p>本文要使用栈结构来实现一个可以 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>以及包含<code>()</code>的运算。所给的表达式都是有效的（本文代码并未实现验证表达式是否合法），表达式中的数都是<strong>非负数</strong>，可包含<strong>空格</strong>。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: "1 + 1"</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: " 2-1 + 2 "</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: "(3+2)*2"</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h3 id="以下代码可解决LeetCode题目："><a href="#以下代码可解决LeetCode题目：" class="headerlink" title="以下代码可解决LeetCode题目："></a>以下代码可解决LeetCode题目：</h3><ul><li><p><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></p></li><li><p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></p></li></ul><h3 id="整体代码思路："><a href="#整体代码思路：" class="headerlink" title="整体代码思路："></a>整体代码思路：</h3><p>以：<code>2 * (10 - 3) / 5</code>为例: </p><p>1、先给第一个数字加一个默认符号<code>+</code>，变成<code>+ 2 * (10 - 3) / 5</code>。 </p><p>2、把一个运算符和数字组合成一对儿，也就是三对儿<code>+2</code>，<code>(10 - 3)</code>, <code>5</code>，把它们转化成数字，然后放到一个栈中。 </p><p>3、当遇到<code>*</code>, <code>/</code>符号时, 取出栈中的数字和当前的数字，计算结果再存入栈中。</p><p>4、当遇到<code>(</code>，将<code>(</code>后面的部分运用递归调用本函数，遇到<code>)</code>就跳出循环，并将<code>(...)</code>中的结果存入栈中，计算结果返回。</p><p>5、 将栈中所有的数字求和，就是原算式的结果。 </p><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; length ) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            num = calculate(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!Character.isDigit(ch) &amp;&amp; ch != <span class="string">' '</span>) || i == length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre;</span><br><span class="line">            <span class="keyword">switch</span> (sign) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    stack.add(num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    stack.add(-num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 只要拿出前一个数字做对应运算即可</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    pre = stack.pop();</span><br><span class="line">                    stack.add(pre * num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    pre = stack.pop();</span><br><span class="line">                    stack.add(pre / num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sign = ch;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">')'</span>) <span class="keyword">break</span>;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: stack) &#123;</span><br><span class="line">        res += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加油！！！🧐"><a href="#加油！！！🧐" class="headerlink" title="加油！！！🧐"></a>加油！！！🧐</h3>]]></content>
    
    <summary type="html">
    
      使用Java语言设计一个计算器算法
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="penghui.club/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>倒数第N个字符串</title>
    <link href="penghui.club/2020/06/21/hello-world/"/>
    <id>penghui.club/2020/06/21/hello-world/</id>
    <published>2020-06-21T03:34:10.000Z</published>
    <updated>2020-06-21T04:32:48.364Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"姑娘有心事？"书生抿嘴品茶问到。 </span><br><span class="line">少女："公子与王公子可是熟识？" </span><br><span class="line">书生："世交。" </span><br><span class="line">少女："那下次你与他一起来吧。" </span><br><span class="line">书生："他不喜品茶。" </span><br><span class="line">少女："没关系，那他喜欢什么，我可以慢慢学。" </span><br><span class="line">书生："他喜欢我。"</span><br><span class="line"></span><br><span class="line">                                                                    ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="倒数第N个字符串"><a href="#倒数第N个字符串" class="headerlink" title="倒数第N个字符串"></a>倒数第N个字符串</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为 { aaa, aab, aac, …, aaz, aba, abb, …, abz, …, zzz }。这个序列的倒数第27个字符串就是 zyz。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出两个正整数 L（2 ≤ L ≤ 6）和 N（≤105）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7417</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pat</span><br></pre></td></tr></table></figure><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;L, &amp;N);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">26</span>, L) - N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num[L];</span><br><span class="line">    <span class="keyword">int</span> ind = L;</span><br><span class="line">    <span class="keyword">while</span> (L -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num[L] = n % <span class="number">26</span>;</span><br><span class="line">        n = n / <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ind; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, num[i] + <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继续加油吧🤪"><a href="#继续加油吧🤪" class="headerlink" title="继续加油吧🤪"></a>继续加油吧🤪</h3>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&quot;姑娘有心事？&quot;书生抿嘴品茶问到。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;少女：&quot;公子与王公子可是熟识？&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;书生：&quot;世交。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;少女：&quot;那下次你与他一起来吧。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;书生：&quot;他不喜品茶。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;少女：&quot;没关系，那他喜欢什么，我可以慢慢学。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;书生：&quot;他喜欢我。&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                    ----- 网易云热评&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>倒数第N个字符串</title>
    <link href="penghui.club/2020/06/21/%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>penghui.club/2020/06/21/%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-06-21T03:34:10.000Z</published>
    <updated>2020-06-22T00:02:19.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"姑娘有心事？"书生抿嘴品茶问到。 </span><br><span class="line">少女："公子与王公子可是熟识？" </span><br><span class="line">书生："世交。" </span><br><span class="line">少女："那下次你与他一起来吧。" </span><br><span class="line">书生："他不喜品茶。" </span><br><span class="line">少女："没关系，那他喜欢什么，我可以慢慢学。" </span><br><span class="line">书生："他喜欢我。"</span><br><span class="line"></span><br><span class="line">                                                                    ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="倒数第N个字符串"><a href="#倒数第N个字符串" class="headerlink" title="倒数第N个字符串"></a>倒数第N个字符串</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为 { aaa, aab, aac, …, aaz, aba, abb, …, abz, …, zzz }。这个序列的倒数第27个字符串就是 zyz。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出两个正整数 L（2 ≤ L ≤ 6）和 N（≤105）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7417</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pat</span><br></pre></td></tr></table></figure><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;L, &amp;N);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">26</span>, L) - N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num[L];</span><br><span class="line">    <span class="keyword">int</span> ind = L;</span><br><span class="line">    <span class="keyword">while</span> (L -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num[L] = n % <span class="number">26</span>;</span><br><span class="line">        n = n / <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ind; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, num[i] + <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继续加油吧🤪"><a href="#继续加油吧🤪" class="headerlink" title="继续加油吧🤪"></a>继续加油吧🤪</h3>]]></content>
    
    <summary type="html">
    
      倒数第N个字符串
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>天梯赛座位分配</title>
    <link href="penghui.club/2020/06/20/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/"/>
    <id>penghui.club/2020/06/20/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/</id>
    <published>2020-06-20T09:22:38.000Z</published>
    <updated>2020-06-22T00:02:49.273Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">倒啤酒时上面总有一层泡沫，看似庞大但抿一口全是空气。感情亦是如此。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>天梯赛每年有大量参赛队员，要保证同一所学校的所有队员都不能相邻，分配座位就成为一件比较麻烦的事情。为此我们制定如下策略：假设某赛场有 N 所学校参赛，第 i 所学校有 M[i] 支队伍，每队 10 位参赛选手。令每校选手排成一列纵队，第 i+1 队的选手排在第 i 队选手之后。从第 1 所学校开始，各校的第 1 位队员顺次入座，然后是各校的第 2 位队员…… 以此类推。如果最后只剩下 1 所学校的队伍还没有分配座位，则需要安排他们的队员隔位就坐。本题就要求你编写程序，自动为各校生成队员的座位号，从 1 开始编号。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出参赛的高校数 N （不超过100的正整数）；第二行给出 N 个不超过10的正整数，其中第 i 个数对应第 i 所高校的参赛队伍数，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>从第 1 所高校的第 1 支队伍开始，顺次输出队员的座位号。每队占一行，座位号间以 1 个空格分隔，行首尾不得有多余空格。另外，每所高校的第一行按“#X”输出该校的编号X，从 1 开始。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">1 4 7 10 13 16 19 22 25 28</span><br><span class="line">31 34 37 40 43 46 49 52 55 58</span><br><span class="line">61 63 65 67 69 71 73 75 77 79</span><br><span class="line">#2</span><br><span class="line">2 5 8 11 14 17 20 23 26 29</span><br><span class="line">32 35 38 41 44 47 50 53 56 59</span><br><span class="line">62 64 66 68 70 72 74 76 78 80</span><br><span class="line">82 84 86 88 90 92 94 96 98 100</span><br><span class="line">#3</span><br><span class="line">3 6 9 12 15 18 21 24 27 30</span><br><span class="line">33 36 39 42 45 48 51 54 57 60</span><br></pre></td></tr></table></figure><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> M[n];</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxM = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M[i]);</span><br><span class="line">        <span class="keyword">if</span> (M[i] &gt; maxM) maxM = M[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>, preM = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> * maxM; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; M[j] * <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preM == j) </span><br><span class="line">                    num ++;</span><br><span class="line">                A[j][i] = num ++;</span><br><span class="line">                preM = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#%d\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span> * M[i]; j ++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i][j], (j + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="今天额外的累😭"><a href="#今天额外的累😭" class="headerlink" title="今天额外的累😭"></a>今天额外的累😭</h3>]]></content>
    
    <summary type="html">
    
      天梯赛座位分配
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整除光棍</title>
    <link href="penghui.club/2020/06/20/%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/"/>
    <id>penghui.club/2020/06/20/%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/</id>
    <published>2020-06-20T05:16:57.000Z</published>
    <updated>2020-06-22T00:03:10.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">屏幕前的女孩 我不认识你 但我祝你坚强 祝你可爱 祝你善良 一生向前永不回头 加油哟！</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数<code>x</code>，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字<code>s</code>，表示<code>x</code>乘以<code>s</code>是一个光棍，第二个数字<code>n</code>是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p><p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除<code>x</code>为止。但难点在于，<code>s</code>可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p> 输入在一行中给出一个不以5结尾的正奇数<code>x</code>（&lt;1000）。 </p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p> 在一行中输出相应的最小的<code>s</code>和<code>n</code>，其间以1个空格分隔。 </p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3584229390681</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="程序代码："><a href="#程序代码：" class="headerlink" title="程序代码："></a>程序代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, s = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">5</span> == <span class="number">0</span> || x % <span class="number">2</span> == <span class="number">0</span> || x &gt;= <span class="number">1000</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x &gt; s) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, s / x);</span><br><span class="line">        s %= x;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        s = s * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="收藏一下本站吧！😁"><a href="#收藏一下本站吧！😁" class="headerlink" title="收藏一下本站吧！😁"></a>收藏一下本站吧！😁</h3>]]></content>
    
    <summary type="html">
    
      整除光棍
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="penghui.club/2020/06/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>penghui.club/2020/06/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-17T14:04:16.000Z</published>
    <updated>2020-06-17T15:08:49.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">太过热情总是不被珍惜。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><hr><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="“对象性能”模式"><a href="#“对象性能”模式" class="headerlink" title="“对象性能”模式"></a>“对象性能”模式</h3><ul><li>面向对象很好解决了 “抽象” 的问题，但是必不可免地要付出一定的代价。对于同常来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</li><li>典型模式<ul><li>Singleton</li><li>Flyweight</li></ul></li></ul><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>在软件系统中,经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率。</li><li>如何绕过常规的构造器,提供种机制来保证一个类只有一个实例？</li><li>这应该是类设计者的责任,而不是使用者的责任。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实现一个只能创建一个对象的类。</p><p><strong>懒汉模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instace=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，安全但是锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.store(tmp, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Java中可以实现单例模式的方法有：饿汉、懒汉、静态内部类等</em></p><hr><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类仅有一个实例 ,并提供一个该实例的全局访问点。</p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要支持拷贝构造函数和Clone接口 ，因为这有可能导致多个对象实例,与Singleton模式的初衷违背。</li><li>如何实现多线程环境下安全的Singleton ?注意对双检查锁的正确实现。.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="penghui.club/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
