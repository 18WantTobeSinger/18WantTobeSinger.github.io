<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fluoxetine</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="penghui.club/"/>
  <updated>2020-07-22T01:59:01.623Z</updated>
  <id>penghui.club/</id>
  
  <author>
    <name>Fluoxetine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis事务</title>
    <link href="penghui.club/2020/07/22/redis-shi-wu/"/>
    <id>penghui.club/2020/07/22/redis-shi-wu/</id>
    <published>2020-07-22T01:30:32.000Z</published>
    <updated>2020-07-22T01:59:01.623Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我离星星只有一步之遥 我踮起脚伸手去够它 脚下的梯子倒了 我掉了下来 从此我连看星星的勇气都没有了 希望你不懂</p><p>​                                                                        —– 《  陈先生  》</p></blockquote><a id="more"></a><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务本质：一组命令的集合！一个事务中所有的命令都会被序列化，在事务执行过程中，会按照顺序执行！</p><p><strong>一次性、顺序性、排它性！</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">----- 队列 set set set 执行 -----</span><br></pre></td></tr></table></figure><p><span style="color:red;">Redis单条命令保证原子性，但是事务不保证原子性，Redis事务没有隔离级别的概念</span></p><h3 id="Redis事务执行流程"><a href="#Redis事务执行流程" class="headerlink" title="Redis事务执行流程"></a>Redis事务执行流程</h3><ul><li><p>开启事务（multi）</p></li><li><p>命令入队（……）</p></li><li><p>执行事务（exec）</p></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">"k1"</span></span><br><span class="line">5) <span class="string">"k2"</span></span><br><span class="line">6) <span class="string">"k3"</span></span><br></pre></td></tr></table></figure><p><em>事务在执行<code>exec</code>之后就消失了</em></p><h3 id="取消事务"><a href="#取消事务" class="headerlink" title="取消事务"></a>取消事务</h3><p>在向事务队列中放入要执行的命令时，可以使用<code>DISCARD</code>来取消事务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="编译型异常"><a href="#编译型异常" class="headerlink" title="编译型异常"></a>编译型异常</h3><blockquote><p>在输入命令的过程中，所写的命令有错，则在exec之后，会抛异常，事务中所有的命令都不会执行！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k1 k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3 k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k4</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'getset'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><blockquote><p>如果事务队列存在语法性错误，那么在执行的过程中，其他命令可以正常执行，错误命令会抛出错误（事务是不保证原子性的）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">"a"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incrby k1 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">"k3"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我离星星只有一步之遥 我踮起脚伸手去够它 脚下的梯子倒了 我掉了下来 从此我连看星星的勇气都没有了 希望你不懂&lt;/p&gt;
&lt;p&gt;​                                                                        —– 《  陈先生  》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="penghui.club/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Redis计算两地距离</title>
    <link href="penghui.club/2020/07/22/yong-redis-zhao-ju-li/"/>
    <id>penghui.club/2020/07/22/yong-redis-zhao-ju-li/</id>
    <published>2020-07-22T00:41:56.000Z</published>
    <updated>2020-07-22T01:11:32.549Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p> 让你嘴角上扬的那个人姓什么 ?</p><p>​                                                                        —– 《 我准备好，放弃你了 》</p></blockquote><a id="more"></a><h2 id="使用Redis计算两地距离"><a href="#使用Redis计算两地距离" class="headerlink" title="使用Redis计算两地距离"></a>使用Redis计算两地距离</h2><blockquote><p> <strong>时间复杂度：</strong>每一个元素添加是O(log(N)) ，N是sorted set的元素数量。 </p></blockquote><p> 将指定的地理空间位置（纬度、经度、名称）添加到指定的<code>key</code>中。这些数据将会存储到<code>sorted set</code> 这样的目的是为了方便使用<a href="http://redis.cn/commands/georadius.html" target="_blank" rel="noopener">GEORADIUS</a>或者<a href="http://redis.cn/commands/georadiusbymember.html" target="_blank" rel="noopener">GEORADIUSBYMEMBER</a>命令对数据进行半径查询等操作。</p><p>该命令以采用标准格式的参数<code>x,y</code>,所以<strong>经度必须在纬度之前</strong>。这些坐标的限制是可以被编入索引的，区域面积可以很接近极点但是不能索引。具体的限制，由EPSG:900913 / EPSG:3785 / OSGEO:41001 规定如下：</p><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul><blockquote><p> 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</p></blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><h5 id="添加地理位置元素"><a href="#添加地理位置元素" class="headerlink" title="添加地理位置元素"></a>添加地理位置元素</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key 经度 纬度 城市名称</span><br><span class="line"></span><br><span class="line">GEOADD citys 13.361389 38.115556 <span class="string">"PCity"</span></span><br><span class="line">GEOADD citys 15.087269 37.502669 <span class="string">"CCity"</span></span><br></pre></td></tr></table></figure><h5 id="查询key中经度、纬度"><a href="#查询key中经度、纬度" class="headerlink" title="查询key中经度、纬度"></a>查询key中经度、纬度</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopos key city ...[city]</span><br></pre></td></tr></table></figure><h5 id="查找两地距离"><a href="#查找两地距离" class="headerlink" title="查找两地距离"></a>查找两地距离</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEODIST key city1 city2 距离单位</span><br><span class="line"></span><br><span class="line">GEODIST citys PCity CCity [m | km | mi(英里) | ft(英尺)]</span><br></pre></td></tr></table></figure><h5 id="以经、纬度查找附近的人"><a href="#以经、纬度查找附近的人" class="headerlink" title="以经、纬度查找附近的人"></a>以经、纬度查找附近的人</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOREDIUS key 经度 纬度 距离 距离单位 [withdist(输出结果的距离)] [withcoord(输出结果经、纬度)] [count(数量)]</span><br></pre></td></tr></table></figure><h5 id="以具体城市查找附近"><a href="#以具体城市查找附近" class="headerlink" title="以具体城市查找附近"></a>以具体城市查找附近</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUSBYMEMBER key city radius [m | km | mi(英里) | ft(英尺)]</span><br></pre></td></tr></table></figure><h5 id="返回一个或多个位置元素的-Geohash-表示-一般用不到"><a href="#返回一个或多个位置元素的-Geohash-表示-一般用不到" class="headerlink" title="返回一个或多个位置元素的 Geohash 表示(一般用不到)"></a>返回一个或多个位置元素的 Geohash 表示(一般用不到)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOHASH key city ...[city]</span><br></pre></td></tr></table></figure><h5 id="查看所有城市"><a href="#查看所有城市" class="headerlink" title="查看所有城市"></a>查看所有城市</h5><p>由于<code>GEO</code>底层使用<code>Zset</code>存储，所以可以用<code>Zset</code>相关的命令查看所有元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start end</span><br></pre></td></tr></table></figure><h5 id="移除城市"><a href="#移除城市" class="headerlink" title="移除城市"></a>移除城市</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem key val</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 让你嘴角上扬的那个人姓什么 ?&lt;/p&gt;
&lt;p&gt;​                                                                        —– 《 我准备好，放弃你了 》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="penghui.club/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>2、3、4的幂</title>
    <link href="penghui.club/2020/07/21/er-san-si-de-mi/"/>
    <id>penghui.club/2020/07/21/er-san-si-de-mi/</id>
    <published>2020-07-21T15:05:15.000Z</published>
    <updated>2020-07-21T15:22:44.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我经常在想，我到底放不下的是你这个人，还是你给过我的感受，又或者是你出现在我最爱的时光里</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="2、3、4的幂"><a href="#2、3、4的幂" class="headerlink" title="2、3、4的幂"></a>2、3、4的幂</h2><h4 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目:"></a><code>LeetCode</code>题目:</h4><h3 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂</a></h3><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 2^0 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br><span class="line">解释: 2^4 &#x3D; 16</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p> 2的幂次方在二进制下，只有1位是1，其余全是0 ，我们只需要获取给的数最右边<code>1</code>的位置后面的部分，判断他是否与原数相等即可。</p><p>例如：</p><p>6： 二进制下为：110，最右边<code>1</code>的位置后面的部分为 10，10和110不相等，所以是<code>false</code>。</p><p>8：二进制下为：1000，最右边<code>1</code>的位置后面的部分为 1000，两者相等，所以为<code>true</code>。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; -n) == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3的幂"><a href="#3的幂" class="headerlink" title="3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">3的幂</a></h3><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>3的幂次的质因子只有3，而所给出的n如果也是3的幂次，故而题目中所给整数范围内最大的3的幂次的因子只能是3的幂次，1162261467是3的19次幂，是整数范围内最大的3的幂次 。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4的幂"><a href="#4的幂" class="headerlink" title="4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">4的幂</a></h3><p>给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>理论上数字4幂的二进制类似于100，10000，1000000，…形式。可以有如下结论：</p><ul><li>4的幂一定是2的。</li><li>4的幂和2的幂一样，只会出现一位1。但是，4的1总是出现在<span style="color:red;">奇数位</span>。</li><li><code>0x5 = 0101b</code>可以用来校验奇数位上的1。</li></ul><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span> || (num &amp; (-num)) != num) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">0x55555555</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      2、3、4的幂
    
    </summary>
    
    
    
      <category term="位运算" scheme="penghui.club/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis基本命令</title>
    <link href="penghui.club/2020/07/21/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>penghui.club/2020/07/21/Redis%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2020-07-21T09:35:34.000Z</published>
    <updated>2020-07-22T00:43:48.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p> 如果你出事了，我的命能救你，我会豪不犹豫，但是如果你好好的，我不愿在看你一眼 </p></blockquote><a id="more"></a><h2 id="Redis基本命令"><a href="#Redis基本命令" class="headerlink" title="Redis基本命令"></a>Redis基本命令</h2><p>Redis 是一个开源（BSD许可）的，==内存==中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a href="http://redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="noopener">字符串（strings）</a>， <a href="http://redis.cn/topics/data-types-intro.html#hashes" target="_blank" rel="noopener">散列（hashes）</a>， <a href="http://redis.cn/topics/data-types-intro.html#lists" target="_blank" rel="noopener">列表（lists）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sets" target="_blank" rel="noopener">集合（sets）</a>， <a href="http://redis.cn/topics/data-types-intro.html#sorted-sets" target="_blank" rel="noopener">有序集合（sorted sets）</a> 与范围查询， <a href="http://redis.cn/topics/data-types-intro.html#bitmaps" target="_blank" rel="noopener">bitmaps</a>， <a href="http://redis.cn/topics/data-types-intro.html#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> 和 <a href="http://redis.cn/commands/geoadd.html" target="_blank" rel="noopener">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a href="http://redis.cn/topics/replication.html" target="_blank" rel="noopener">复制（replication）</a>，<a href="http://redis.cn/commands/eval.html" target="_blank" rel="noopener">LUA脚本（Lua scripting）</a>， <a href="http://redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">LRU驱动事件（LRU eviction）</a>，<a href="http://redis.cn/topics/transactions.html" target="_blank" rel="noopener">事务（transactions）</a> 和不同级别的 <a href="http://redis.cn/topics/persistence.html" target="_blank" rel="noopener">磁盘持久化（persistence）</a>， 并通过 <a href="http://redis.cn/topics/sentinel.html" target="_blank" rel="noopener">Redis哨兵（Sentinel）</a>和自动 <a href="http://redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">分区（Cluster）</a>提供高可用性（high availability）。 </p><h3 id="热身运动"><a href="#热身运动" class="headerlink" title="热身运动"></a>热身运动</h3><h4 id="验证密码"><a href="#验证密码" class="headerlink" title="验证密码"></a>验证密码</h4><p>当我们启动redis时，如果我们设置了登陆密码，我们可以使用<code>auth</code>命令来验证登陆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth password</span><br></pre></td></tr></table></figure><h4 id="判断是否存在key"><a href="#判断是否存在key" class="headerlink" title="判断是否存在key:"></a>判断是否存在<code>key</code>:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><p>redis默认有16个数据库，可使用<code>select</code>命令选择数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1&#x2F;2&#x2F;3...</span><br></pre></td></tr></table></figure><h4 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure><h4 id="获取所有key："><a href="#获取所有key：" class="headerlink" title="获取所有key："></a>获取所有<code>key</code>：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure><h4 id="获取key对应的存储类型"><a href="#获取key对应的存储类型" class="headerlink" title="获取key对应的存储类型"></a>获取key对应的存储类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><h4 id="设置键值超时时间"><a href="#设置键值超时时间" class="headerlink" title="设置键值超时时间"></a>设置键值超时时间</h4><p>可以多次调用这个命令改变超时时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key time</span><br></pre></td></tr></table></figure><h4 id="获取key剩余存活时间"><a href="#获取key剩余存活时间" class="headerlink" title="获取key剩余存活时间"></a>获取key剩余存活时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown --&gt; exit</span><br></pre></td></tr></table></figure><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><h4 id="设置一个键值对儿"><a href="#设置一个键值对儿" class="headerlink" title="设置一个键值对儿"></a>设置一个键值对儿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br></pre></td></tr></table></figure><h4 id="获取键的值"><a href="#获取键的值" class="headerlink" title="获取键的值"></a>获取键的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><h4 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key1 key2 key3</span><br></pre></td></tr></table></figure><h4 id="对字符串截取"><a href="#对字符串截取" class="headerlink" title="对字符串截取"></a>对字符串截取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getrange key start end</span><br><span class="line">getrange key 0 -1</span><br></pre></td></tr></table></figure><h4 id="对数字字符串递增、递减"><a href="#对数字字符串递增、递减" class="headerlink" title="对数字字符串递增、递减"></a>对数字字符串递增、递减</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set cnt 100</span><br><span class="line">incr cnt    # cnt + 1</span><br><span class="line">decr cnt    # cnt - 1</span><br></pre></td></tr></table></figure><h4 id="设置递增的步长"><a href="#设置递增的步长" class="headerlink" title="设置递增的步长"></a>设置递增的步长</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrby cnt 3    # cnt + 3</span><br><span class="line">decrby cnt 4    # cnt - 4</span><br></pre></td></tr></table></figure><h4 id="存储多个键值"><a href="#存储多个键值" class="headerlink" title="存储多个键值"></a>存储多个键值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset k1 v1 k2 v2 k3 v3</span><br></pre></td></tr></table></figure><h4 id="获取多个键值"><a href="#获取多个键值" class="headerlink" title="获取多个键值"></a>获取多个键值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget k1 k2 k3</span><br></pre></td></tr></table></figure><h4 id="向尾部追加值"><a href="#向尾部追加值" class="headerlink" title="向尾部追加值"></a>向尾部追加值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># key &#x3D; he</span><br><span class="line">append key llo</span><br><span class="line"># key &#x3D; hello</span><br></pre></td></tr></table></figure><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen key</span><br></pre></td></tr></table></figure><h3 id="Lists（列表）"><a href="#Lists（列表）" class="headerlink" title="Lists（列表）"></a>Lists（列表）</h3><h4 id="向list添加新元素"><a href="#向list添加新元素" class="headerlink" title="向list添加新元素"></a>向list添加新元素</h4><h5 id="向list头部添加新元素"><a href="#向list头部添加新元素" class="headerlink" title="向list头部添加新元素"></a><strong>向list头部添加新元素</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush list val1 val2 val3 ...</span><br></pre></td></tr></table></figure><h5 id="向list尾部添加新元素"><a href="#向list尾部添加新元素" class="headerlink" title="向list尾部添加新元素"></a><strong>向list尾部添加新元素</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush list val1 val2 val3 ...</span><br></pre></td></tr></table></figure><h5 id="更改已存在的list的下标值"><a href="#更改已存在的list的下标值" class="headerlink" title="更改已存在的list的下标值"></a>更改已存在的list的下标值</h5><p>list必须存在，以及该下标必须已经赋过值，否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lset list index val</span><br><span class="line"></span><br><span class="line">lpush list val1</span><br><span class="line">lset list 0 item1</span><br></pre></td></tr></table></figure><h5 id="在list中插入值"><a href="#在list中插入值" class="headerlink" title="在list中插入值"></a>在list中插入值</h5><p>在list中val1之前/之后插入val2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linsert list before|after val1 val2</span><br></pre></td></tr></table></figure><h4 id="获取list中的元素"><a href="#获取list中的元素" class="headerlink" title="获取list中的元素"></a>获取list中的元素</h4><h5 id="根据索引范围取值"><a href="#根据索引范围取值" class="headerlink" title="根据索引范围取值"></a>根据索引范围取值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrange list start end</span><br><span class="line">lrange list 0 -1</span><br></pre></td></tr></table></figure><h5 id="按照索引取值"><a href="#按照索引取值" class="headerlink" title="按照索引取值"></a>按照索引取值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex list index</span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p> 从list中删除元素并同时返回删除的值。可以在左边或右边操作。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpop list</span><br><span class="line">lpop list</span><br></pre></td></tr></table></figure><h4 id="把list从左边截断指定长度"><a href="#把list从左边截断指定长度" class="headerlink" title="把list从左边截断指定长度"></a>把list从左边截断指定长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; list: 1 2 3 4 5</span><br><span class="line">ltrim list 0 2</span><br><span class="line">&#x2F;&#x2F; list: 1 2 3</span><br></pre></td></tr></table></figure><h4 id="获取list长度"><a href="#获取list长度" class="headerlink" title="获取list长度"></a>获取list长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Llen list</span><br></pre></td></tr></table></figure><h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p><code>list</code>可以存在重复的值，所以我们可以指定删除值得数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrem list count val</span><br><span class="line"></span><br><span class="line">lrem list 2 &quot;abc&quot; # 会移除掉2个list中值为abc的值</span><br></pre></td></tr></table></figure><h4 id="移除添加"><a href="#移除添加" class="headerlink" title="移除添加"></a>移除添加</h4><p>从右侧移除一个元素并新增一个元素到一个新的list中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpoplpush source destination</span><br><span class="line"></span><br><span class="line"># list1: 1 2 3 4</span><br><span class="line"># list2: </span><br><span class="line">rpoplpush list1 list2</span><br><span class="line"># list1: 1 2 3</span><br><span class="line"># list2: 4</span><br></pre></td></tr></table></figure><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><p>set里面的值不可以重复</p><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd myset val1</span><br></pre></td></tr></table></figure><h4 id="获取set中所有元素"><a href="#获取set中所有元素" class="headerlink" title="获取set中所有元素"></a>获取set中所有元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers myset</span><br></pre></td></tr></table></figure><h4 id="判断指定元素是否存在"><a href="#判断指定元素是否存在" class="headerlink" title="判断指定元素是否存在"></a>判断指定元素是否存在</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember myset val</span><br></pre></td></tr></table></figure><h4 id="获取set元素个数"><a href="#获取set元素个数" class="headerlink" title="获取set元素个数"></a>获取set元素个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard myset</span><br></pre></td></tr></table></figure><h4 id="移除set中元素"><a href="#移除set中元素" class="headerlink" title="移除set中元素"></a>移除set中元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem myset val</span><br></pre></td></tr></table></figure><h4 id="随机获取set中元素"><a href="#随机获取set中元素" class="headerlink" title="随机获取set中元素"></a>随机获取set中元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember myset</span><br></pre></td></tr></table></figure><h4 id="随机弹出一个元素"><a href="#随机弹出一个元素" class="headerlink" title="随机弹出一个元素"></a>随机弹出一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop myset</span><br></pre></td></tr></table></figure><h4 id="将一个集合中指定的元素移动到另一个集合中"><a href="#将一个集合中指定的元素移动到另一个集合中" class="headerlink" title="将一个集合中指定的元素移动到另一个集合中"></a>将一个集合中指定的元素移动到另一个集合中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># myset1: h1 h2 he h3</span><br><span class="line"># myset2: hh</span><br><span class="line">smove myset1 myset2 he</span><br><span class="line"># myset1: h1 h2 h3</span><br><span class="line"># myset2: hh he</span><br></pre></td></tr></table></figure><h4 id="两集合差集操作"><a href="#两集合差集操作" class="headerlink" title="两集合差集操作"></a>两集合差集操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># set1: a b c</span><br><span class="line"># set2: c d e</span><br><span class="line">sdiff set1 set2</span><br><span class="line"># &quot;b&quot; &quot;a&quot;</span><br></pre></td></tr></table></figure><h4 id="两集合交集操作"><a href="#两集合交集操作" class="headerlink" title="两集合交集操作"></a>两集合交集操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># set1: a b c</span><br><span class="line"># set2: c d e</span><br><span class="line">sinter set1 set2</span><br><span class="line"># &quot;c&quot;</span><br></pre></td></tr></table></figure><h4 id="两集合并集操作"><a href="#两集合并集操作" class="headerlink" title="两集合并集操作"></a>两集合并集操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># set1: a b c</span><br><span class="line"># set2: c d e</span><br><span class="line">sunion set1 set2</span><br><span class="line"># &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;</span><br></pre></td></tr></table></figure><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>map集合，key-map！这个值是一个map集合。</p><h4 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmset myhash k1 v1 k2 v2</span><br><span class="line">hset myhash k3 v3</span><br></pre></td></tr></table></figure><h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hmget myhash k1 k2</span><br><span class="line">hget myhash k1</span><br><span class="line">hgetall myhash</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>对应的val也就消失了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel myhash k1</span><br></pre></td></tr></table></figure><h4 id="获取hash元素个数"><a href="#获取hash元素个数" class="headerlink" title="获取hash元素个数"></a>获取hash元素个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen myhash</span><br></pre></td></tr></table></figure><h4 id="判断hash是否存在某个key"><a href="#判断hash是否存在某个key" class="headerlink" title="判断hash是否存在某个key"></a>判断hash是否存在某个key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexists myhash key</span><br></pre></td></tr></table></figure><h4 id="获取所有的key"><a href="#获取所有的key" class="headerlink" title="获取所有的key"></a>获取所有的key</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys myhash</span><br></pre></td></tr></table></figure><h4 id="获取所有的val"><a href="#获取所有的val" class="headerlink" title="获取所有的val"></a>获取所有的val</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals myhash</span><br></pre></td></tr></table></figure><h4 id="对某个val自增"><a href="#对某个val自增" class="headerlink" title="对某个val自增"></a>对某个val自增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incr myhash key</span><br><span class="line">decr myhash key</span><br><span class="line">hincrby myhash key num</span><br><span class="line">hdecrby myhash key num</span><br><span class="line"># 对键为key的值自增2</span><br><span class="line">hincrby myhash key 2</span><br></pre></td></tr></table></figure><h4 id="设置键值时查看是否存在"><a href="#设置键值时查看是否存在" class="headerlink" title="设置键值时查看是否存在"></a>设置键值时查看是否存在</h4><p>如果不存在存入key-val，存在则返回0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsetnx myhash key val</span><br></pre></td></tr></table></figure><h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><p>在set集合上，增加了一个值，对比set和zset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set k1 v1</span><br><span class="line">zset k1 score v1</span><br></pre></td></tr></table></figure><h4 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zadd key [NX|XX] [CH] [INCR] score member [score member...]</span><br><span class="line"></span><br><span class="line">zadd myzset 1 one</span><br><span class="line">zadd myzset 2 two 3 three</span><br></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从小到大</span><br><span class="line">zrange myset 0 -1</span><br><span class="line"># 从大到小</span><br><span class="line">zrevrange myset 0 -1</span><br></pre></td></tr></table></figure><h4 id="排序如何实现？"><a href="#排序如何实现？" class="headerlink" title="排序如何实现？"></a>排序如何实现？</h4><h5 id="从小到大排序"><a href="#从小到大排序" class="headerlink" title="从小到大排序"></a>从小到大排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrangebyscore zset min max [withscores]</span><br></pre></td></tr></table></figure><h5 id="从大到小排序"><a href="#从大到小排序" class="headerlink" title="从大到小排序"></a>从大到小排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrevrangebyscore zset min max [withscores]</span><br></pre></td></tr></table></figure><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">zadd salarys 2500 xiaohong</span><br><span class="line">zadd salarys 2500 zhangsan</span><br><span class="line">zadd salarys 500 kuangshen</span><br><span class="line"></span><br><span class="line"># +inf和-inf分别表示正负无穷</span><br><span class="line">zrangebyscore salarys -inf +inf</span><br><span class="line"></span><br><span class="line"># 输出带上score值</span><br><span class="line">zrangebyscore salarys -inf +inf withscores</span><br><span class="line"># 输出score范围在[0, 2500]之间的值</span><br><span class="line">zrangebyscore salarys 0 2500 withscores</span><br></pre></td></tr></table></figure><h4 id="移除元素-1"><a href="#移除元素-1" class="headerlink" title="移除元素"></a>移除元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zrem zset val</span><br></pre></td></tr></table></figure><h4 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard zset</span><br></pre></td></tr></table></figure><h4 id="判断-min-max-区间score的数量"><a href="#判断-min-max-区间score的数量" class="headerlink" title="判断[min, max]区间score的数量"></a>判断[min, max]区间score的数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount myset min max</span><br></pre></td></tr></table></figure><h2 id="完结撒花😥"><a href="#完结撒花😥" class="headerlink" title="完结撒花😥"></a>完结撒花😥</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 如果你出事了，我的命能救你，我会豪不犹豫，但是如果你好好的，我不愿在看你一眼 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="penghui.club/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java的四种访问修饰符</title>
    <link href="penghui.club/2020/07/21/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>penghui.club/2020/07/21/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2020-07-20T23:24:39.000Z</published>
    <updated>2020-07-21T02:11:45.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>“今天有没有跟喜欢的人说话。”</p><p> “说了。” </p><p>“说了啥？” </p><p>“说了。你呢？”</p><p> “说了啥”</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="Java的四种访问修饰符"><a href="#Java的四种访问修饰符" class="headerlink" title="Java的四种访问修饰符"></a>Java的四种访问修饰符</h2><h3 id="访问控制存在的原因："><a href="#访问控制存在的原因：" class="headerlink" title="访问控制存在的原因："></a>访问控制存在的原因：</h3><ul><li><p>让客户端程序员无法触及他们不应该触及的部分 ； </p></li><li><p>允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员</p></li></ul><h3 id="java的四个关键字："><a href="#java的四个关键字：" class="headerlink" title="java的四个关键字："></a>java的四个关键字：</h3><p>​    <code>public、protected、default、private</code></p><p>适用范围&lt;访问权限范围越小，安全性越高&gt;</p><table><thead><tr><th>访问权限</th><th>类</th><th>包</th><th>子类</th><th>其他包</th><th>描述</th></tr></thead><tbody><tr><td>public</td><td>∨</td><td>∨</td><td>∨</td><td>∨</td><td>对任何人都是可用的</td></tr><tr><td>protect</td><td>∨</td><td>∨</td><td>∨</td><td>×</td><td>继承的类可以访问以及和private一样的权限</td></tr><tr><td>default</td><td>∨</td><td>∨</td><td>×</td><td>×</td><td>包访问权限，即在整个包内均可被访问</td></tr><tr><td>private</td><td>∨</td><td>×</td><td>×</td><td>×</td><td>除类型创建者和类型的内部方法之外的任何人都不能访问的元素</td></tr></tbody></table><h4 id="一、public"><a href="#一、public" class="headerlink" title="一、public"></a>一、public</h4><p><strong>（1）定义</strong>：<code>public</code>是公共的，被<code>public</code>所修饰的成员可以在任何类中都能被访问到。</p><p><strong>（2）修饰的成分</strong>：</p><p>​        <code>public</code>能用来修饰类，在一个<code>java</code>源文件中只能有一个类被声明为<code>public</code>，而且一旦有一个类为<code>public</code>，那这个java源文件的文件名就必须要和这个被<code>public</code>所修饰的类的类名相同，否则编译不能通过。说到这里，穿插多一点知识。一个类作为外部类的时候只能被<code>public</code>或者默认访问修饰符所修饰，但是一个类如果作为内部类的时候，则可以被四种访问修饰符所修饰，因为一个类作为内部类的时候，就作为外部类的一个成员属性了，因此可以有四种访问修饰符修饰，这是内部类和外部类的一个区别。</p><p>​        <code>public</code>用来修饰类中成员（变量和方法），被<code>public</code>所修饰的成员可以在任何类中都能被访问到。通过操作该类的对象能随意访问<code>public</code>成员。</p><p>​        <code>public</code>在类的继承上的体现，被<code>public</code>所修饰的成员能被所有的子类继承下来。</p><h4 id="二、protected"><a href="#二、protected" class="headerlink" title="二、protected"></a>二、protected</h4><p><strong>（1）定义</strong>：<code>protected</code>是受保护的，受到该类所在的包所保护。</p><p><strong>（2）作用域</strong>：被<code>protected</code>所修饰的成员会被位于同一<code>package</code>中的所有类访问到。同时，被<code>protected</code>所修饰的成员也能被该类的所有子类继承下来。（注意：这里是指同一个<code>package</code>或者不同的<code>package</code>中的子类都能访问）</p><h4 id="三、default（默认，缺省的）"><a href="#三、default（默认，缺省的）" class="headerlink" title="三、default（默认，缺省的）"></a>三、default（默认，缺省的）</h4><p><strong>（1）定义</strong>：<code>default</code>是友好的，即在成员的前面不写任何的访问修饰符的时候，默认就是友好的。所谓友好的，是对同一<code>package</code>的类友好。</p><p><strong>（2）作用域</strong>：同一<code>package</code>中的所有类都能访问。被<code>friendly</code>所修饰的成员只能被该类所在同一个<code>package</code>中的子类所继承下来。（也就是说只有在同一个<code>package</code>中的子类才能访问到父类中<code>default</code>修饰的成员）</p><h4 id="四、private"><a href="#四、private" class="headerlink" title="四、private"></a>四、private</h4><p><strong>（1）定义</strong>：<code>private</code>是私有的，即只能在当前类中被访问到，它的作用域最小。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;“今天有没有跟喜欢的人说话。”&lt;/p&gt;
&lt;p&gt; “说了。” &lt;/p&gt;
&lt;p&gt;“说了啥？” &lt;/p&gt;
&lt;p&gt;“说了。你呢？”&lt;/p&gt;
&lt;p&gt; “说了啥”&lt;/p&gt;
&lt;p&gt;​                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="penghui.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>判断二分图</title>
    <link href="penghui.club/2020/07/16/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>penghui.club/2020/07/16/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</id>
    <published>2020-07-16T11:54:32.000Z</published>
    <updated>2020-07-16T12:36:40.014Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我上大学没钱，平常不打牌的爸爸拿着家里仅剩的1000块钱去朋友家打了一晚上麻将。第二天他疲倦的把学费交到我手里，我一直不知道他一个不大会打牌的人为什么会赢这么多钱。直到我长大后他朋友儿子也到了读大学的年纪，爸爸拿出了家里用来翻修的钱又去打了一晚上的麻将，输光了。 </p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">785. 判断二分图</a></h2><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点<code>i</code>相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a><strong>注意:</strong></h3><ul><li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li><li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li><li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li><li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h4 id="1、并查集"><a href="#1、并查集" class="headerlink" title="1、并查集"></a>1、并查集</h4><p>如果是二分图的话，那么图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合。因此我们可以使用并查集来解决这个问题，我们遍历图中每个顶点，将当前顶点的所有邻接点进行合并，并判断这些邻接点中是否存在某一邻接点已经和当前顶点处于同一个集合中了，若是，则说明不是二分图。</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="keyword">int</span>[] size;</span><br><span class="line">        </span><br><span class="line">    UF(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size    = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">            size[i]    = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> pp, <span class="keyword">int</span> qp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pp == qp) <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (size[pp] &gt; size[qp]) &#123;</span><br><span class="line">            parents[qp] = pp;</span><br><span class="line">            size[pp]  += size[qp];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[pp] = qp;</span><br><span class="line">            size[qp]  += size[pp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[x] != x) &#123;</span><br><span class="line">            parents[x] = parents[parents[x]];</span><br><span class="line">            x = parents[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.length;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; graph[i].length; j ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ip = uf.getParent(i);</span><br><span class="line">            <span class="keyword">int</span> pp = uf.getParent(graph[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> qp = uf.getParent(graph[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (ip == qp || ip == pp) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            uf.union(pp, qp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、DFS-BFS"><a href="#2、DFS-BFS" class="headerlink" title="2、DFS / BFS"></a>2、DFS / BFS</h4><p>以下两种解法来自： <a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/</a> </p><p>我们使用图搜索算法从各个连通域的任一顶点开始遍历整个连通域，遍历的过程中用两种不同的颜色对顶点进行染色，相邻顶点染成相反的颜色。这个过程中倘若发现相邻的顶点被染成了相同的颜色，说明它不是二分图；反之，如果所有的连通域都染色成功，说明它是二分图。</p><h5 id="BFS代码："><a href="#BFS代码：" class="headerlink" title="BFS代码："></a>BFS代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 visited 数组，初始值为 0 表示未被访问，赋值为 1 或者 -1 表示两种不同的颜色。 </span></span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 因为图中可能含有多个连通域，所以我们需要判断是否存在顶点未被访问，若存在则从它开始再进行一轮 bfs 染色。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每出队一个顶点，将其所有邻接点染成相反的颜色并入队。</span></span><br><span class="line">        queue.offer(i);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w: graph[v]) &#123;</span><br><span class="line">                <span class="comment">// 如果当前顶点的某个邻接点已经被染过色了，且颜色和当前顶点相同，说明此无向图无法被正确染色，返回 false。</span></span><br><span class="line">                <span class="keyword">if</span> (visited[w] == visited[v]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (visited[w] == <span class="number">0</span>) &#123;</span><br><span class="line">                    visited[w] = -visited[v];</span><br><span class="line">                    queue.offer(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DFS代码："><a href="#DFS代码：" class="headerlink" title="DFS代码："></a>DFS代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 visited 数组，初始值为 0 表示未被访问，赋值为 1 或者 -1 表示两种不同的颜色。 </span></span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    <span class="comment">// 因为图中可能含有多个连通域，所以我们需要判断是否存在顶点未被访问，若存在则从它开始再进行一轮 dfs 染色。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; !dfs(graph, i, <span class="number">1</span>, visited)) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> v, <span class="keyword">int</span> color, <span class="keyword">int</span>[] visited)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果要对某顶点染色时，发现它已经被染色了，则判断它的颜色是否与本次要染的颜色相同，如果矛盾，说明此无向图无法被正确染色，返回 false。</span></span><br><span class="line">    <span class="keyword">if</span> (visited[v] != <span class="number">0</span>) <span class="keyword">return</span> visited[v] == color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对当前顶点进行染色，并将当前顶点的所有邻接点染成相反的颜色。</span></span><br><span class="line">    visited[v] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w: graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(graph, w, -color, visited)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      判断二分图
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="并查集" scheme="penghui.club/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="DFS" scheme="penghui.club/tags/DFS/"/>
    
      <category term="BFS" scheme="penghui.club/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="penghui.club/2020/07/15/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>penghui.club/2020/07/15/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-07-15T05:13:22.000Z</published>
    <updated>2020-07-15T05:19:32.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>刚刚偷偷在楼顶抽烟被我爸撞见了，觉得尴尬又有点慌 他很淡定的说一起坐坐吧，自己也点了烟 一直没说话，抽完烟他就说了一句话 没事，会好的。不是还有我和你妈还有弟弟在嘛。累了早点下楼休息”瞬间泪崩了 对太多人感到抱歉了。家人，朋友，前任。还有你 还是恢复原状最好，如果可以。希望活得饱满</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h2><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a><strong>示例:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><h4 id="思路解析："><a href="#思路解析：" class="headerlink" title="思路解析："></a>思路解析：</h4><ul><li><p>标签：动态规划</p></li><li><p>假设<code>n</code>个节点存在二叉排序树的个数是<code>G(n)</code>，令<code>f(i)</code>为以<code>i</code>为根的二叉搜索树的个数，则</p><p><code>G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)</code></p></li><li><p>当i为根节点时，其左子树节点个数为<code>i-1</code>个，右子树节点为<code>n-i</code>，则<br><code>f(i) = G(i-1)*G(n-i)f(i)=G(i−1)∗G(n−i)</code></p></li><li><p>综合两个公式可以得到 卡特兰数 公式<br><code>G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+...+G(n−1)∗G(0)</code></p></li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i + <span class="number">1</span>; j++) </span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>] * dp[i-j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees/solution/hua-jie-suan-fa-96-bu-tong-de-er-cha-sou-suo-shu-b/</a></p>]]></content>
    
    <summary type="html">
    
      不同的二叉搜索树
    
    </summary>
    
    
    
      <category term="动态规划" scheme="penghui.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="卡特兰数" scheme="penghui.club/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本命令</title>
    <link href="penghui.club/2020/07/14/Shell%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>penghui.club/2020/07/14/Shell%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2020-07-14T12:30:47.000Z</published>
    <updated>2020-07-14T14:08:56.413Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我们都太懦弱 民国时期不敢做军阀 战乱时期不敢去起义 太平盛世不敢说我爱你</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><p>原文链接：<a href="https://blog.csdn.net/CSDN___LYY/article/details/100584638" target="_blank" rel="noopener">https://blog.csdn.net/CSDN___LYY/article/details/100584638</a></p><h2 id="shell脚本？"><a href="#shell脚本？" class="headerlink" title="shell脚本？"></a>shell脚本？</h2><p><strong>在说什么是shell脚本之前，先说说什么是shell。</strong></p><p>shell是外壳的意思，就是操作系统的外壳。我们可以通过shell命令来操作和控制操作系统，比如Linux中的Shell命令就包括ls、cd、pwd等等。总结来说，Shell是一个命令解释器，它通过接受用户输入的Shell命令来启动、暂停、停止程序的运行或对计算机进行控制。</p><p>shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。</p><p>shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序。</p><p><strong>那么什么是shell脚本呢？</strong></p><p>shell脚本就是由Shell命令组成的执行文件，将一些命令整合到一个文件中，进行处理业务逻辑，脚本不用编译即可运行。它通过解释器解释运行，所以速度相对来说比较慢。</p><p>shell脚本中最重要的就是对shell命令的使用与组合，再使用shell脚本支持的一些语言特性，完成想要的功能。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>“# ”开头的就是注释，被编译器忽略</p><ul><li>单行注释： #</li><li>多行注释： :&lt;&lt;EOF … EOF 或者 :&lt;&lt;! … ! （:&lt;&lt; 标识多行注释开始，并指定一个标识符作为开始结束的标志）</li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>局部变量</strong>：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong>：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>shell变量</strong>：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h4 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h4><ul><li>创建普通变量： name=“test” （=两边不可有空格）</li><li>创建只可函数体中使用的局部变量： local name=“test” （使用local修饰的变量在函数体外无法访问，并且local只能在函数体内使用）</li><li>使用变量： echo $name 或者 echo ​${name} （推荐使用大括号版）</li><li>变量重新赋值： name=“new_test” （将原值覆盖）</li><li>只读变量： name=“only_read” -&gt; readonly name（使用readonly标识后的变量，不可被修改）</li><li>删除变量： <code>unset name</code>; （删除之后不可访问，删除不掉只读变量）</li></ul><h4 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h4><h5 id="1）单引号"><a href="#1）单引号" class="headerlink" title="1）单引号"></a>1）单引号</h5><ul><li>单引号变量<span>var=’test’ </span>，只能原样输出，变量无效</li><li>单引号中不能出现一个单独的单引号，转义也不可以</li></ul><h5 id="2）双引号"><a href="#2）双引号" class="headerlink" title="2）双引号"></a>2）双引号</h5><ul><li>双引号变量var=”my name is ${name}”，变量有效</li><li>可出现转义符</li></ul><h5 id="3）拼接字符串"><a href="#3）拼接字符串" class="headerlink" title="3）拼接字符串"></a>3）拼接字符串</h5><ul><li>中间无任何+，之类的字符</li><li>name=“this is”” my name”; name=“this is my name”; name=“this” is “my name” 等效</li><li>name=‘this is’’ my nam’; name=‘this is my name’; name=‘this’ is ‘my name’ 等效</li></ul><h5 id="4）获取字符串长度"><a href="#4）获取字符串长度" class="headerlink" title="4）获取字符串长度"></a>4）获取字符串长度</h5><ul><li><p>在${}中使用“#”获取长度</p></li><li><p>name=“test”;</p></li><li><p>echo ${#name}; # 输出为4</p></li></ul><h5 id="5）提取子字符串"><a href="#5）提取子字符串" class="headerlink" title="5）提取子字符串"></a>5）提取子字符串</h5><ul><li>1:4 从第2个开始 往后截取4个字符</li><li>::4 从第一个字符开始 往后截取4个字符</li><li>name=“this is my name”;</li><li>echo ${name:1:4} #输出 is i</li><li>echo ${name::4}   #输出 this</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>bash只支持一维数组，不支持多维数组</p><ul><li>定义数组：array_name=(li wang xiang zhang) （小括号做边界、使用空格分离）</li><li>单独定义数组的元素： array_para[0]=“w”; array_para[3]=“s” （定义时下标不连续也可以）</li><li>赋值数组元素：array_name[0]=“zhao”;</li><li>获取数组元素：<ul><li>array_name[0]=“li”</li><li>array_name[3]=“zhang”</li><li>echo ${array_name[0]} # 输出”li”</li><li>echo ${array_name[1]} # 输出” “</li><li>echo ${array_name[3]} # 输出”zhang”</li><li>echo ${array_name[@]} # 输出”li zhang” 输出数组所有元素，没有元素的下标省略</li></ul></li><li>取得元素个数：${#array_name[@]} 或者 ${#array_name[*]}</li><li>取得单个元素长度：${#array_name[1]}</li></ul><hr><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><ul><li><p>获取参数值：</p><ul><li>$0 ： 固定，代表执行的文件名 </li></ul></li><li><p>$1 ： 代表传入的第1个参数</p><ul><li>$n ： 代表传入的第n个参数</li><li>$#：参数个数</li></ul></li><li><p>$*： 以一个单字符串显示所有向脚本传递的参数。如”$*“用「”」括起来的情况、以”$1 $2 … ​$n”的形式输出所有参数</p></li><li><p>$@：与$*相同，但是使用时加引号，并在引号中返回每个参数。</p></li><li><p>$$：脚本运行的当前进程号</p></li><li><p>$！：后台运行的最后一个进程的ID</p></li><li><p>$?： 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</p></li><li><p>$* 与 $@ 区别<br><strong>相同点</strong>：都是引用所有参数。<br><strong>不同点</strong>：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</p></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h4><ul><li><code>+、-、*、\</code> ： 乘号前必须加\进行转义才可以进行乘法运算</li><li>加法运算</li><li>val=<code>expr 2 + 2</code> （使用<code>linux</code>命令<code>expr</code>进行辅助运算）</li><li>val=$[2+2] （4个空格不是必要的，不同于条件判断）</li><li>val=$((2+2))</li></ul><h4 id="数字关系运算符"><a href="#数字关系运算符" class="headerlink" title="数字关系运算符"></a>数字关系运算符</h4><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。<br>下面假定变量 a 为 10，变量 b 为 20</p><ul><li><code>-eq</code> ：检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。</li><li><code>-ne</code>： 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。</li><li><code>-gt</code>： 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。</li><li><code>-lt</code> ： 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。</li><li><code>-ge</code>： 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。</li><li><code>-le</code> ： 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。</li></ul><h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><ul><li><code>=</code> ：检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。</li><li><code>!=</code> ：检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。</li><li><code>-z</code> ：检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。</li><li><code>-n</code> ：检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。</li><li>$ ：检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。</li></ul><h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><ul><li><code>!</code> ：非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。</li><li><code>-o</code> ：或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。</li><li><code>-a</code> ：与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。</li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p><ul><li><code>&amp;&amp;</code> ：逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</li><li><code>||</code> ：逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true</li></ul><h4 id="文件运算符"><a href="#文件运算符" class="headerlink" title="文件运算符"></a>文件运算符</h4><ul><li><code>-b file</code> ：检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ]`返回 false。</li><li><code>-c file</code> ：检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。</li><li><code>-d file</code> ：检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。</li><li><code>-f file</code> ：检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ]返回 true。</li><li><code>-g file</code> ：检测文件是否设置了 SGID 位，如果是，则返回 true。[ -g $file ] 返回 false。</li><li><code>-k file</code> ：检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。</li><li><code>-p file</code> ：检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ]`返回 false。</li><li><code>-u file</code> ：检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ]返回 false。</li><li><code>-r file</code> ：检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。</li><li><code>-w file</code> ：检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。</li><li><code>-x file</code> ：检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。</li><li><code>-s file</code> ：检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。</li><li><code>-e file</code> ：检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。</li></ul><hr><h3 id="执行相关"><a href="#执行相关" class="headerlink" title="执行相关"></a>执行相关</h3><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>命令替换与变量替换差不多，都是用来重组命令行的，先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。<br>执行命令：</p><ol><li>ls /etc ： 反引号 （所有的unix系统都支持）</li><li>$(ls /etc) ： $+() （部分unix系统不支持）<br>多个嵌套使用时，从内向外执行</li></ol><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><ul><li><code>$[ ]</code> : 加减乘除,不必添加空格</li><li><code>$(( ))</code> ：加减乘除等,不必添加空格</li></ul><h4 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h4><ul><li><code>[]</code>： 中括号旁边和运算符两边必须添加空格 （可以使用，不推荐）</li><li><code>[[ ]]</code>：中括号旁边和运算符两边必须添加空格 （字符串验证时，推荐使用）</li><li><code>(())</code> ： 中括号旁边和运算符两边必须添加空格 （数字验证时，推荐使用）</li><li><code>[[]]</code>和 <code>(())</code> 分别是[ ]的针对数学比较表达式和字符串表达式的加强版。</li><li>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; ​$a != 2 ]], 如果不适用双括号, 则为if [ ​$a -ne 1] &amp;&amp; [ ​$a != 2 ]或者if [ ​$a -ne 1 -a $a != 2 ]。<br>[[ ]]中增加模式匹配特效；</li></ul><hr><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>仅用于字符串的输出，没有使用printf作为输出的移植性好，建议使用printf</p><h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><blockquote><p>printf 不会像 echo 自动添加换行符，我们可以手动添加 \n<br>无大括号，直接以空格分隔</p></blockquote><ul><li>格式：printf format-string [arguments…] 其中（format-string: 格式控制字符串、arguments: 参数列表）</li><li>案例：printf “%-10s %-8s %-4.2f\n” 郭靖 男 66.1234</li><li>%s %c %d %f 都是格式替代符<ul><li>d：Decimal 十进制整数 对应位置参数必须是十进制整数，否则报错!</li><li>s：String 字符串 对应位置参数必须是字符串或者字符型 否则报错</li><li>c：Char 字符 对应位置参数必须是字符串或者字符型 否则报错</li><li>f：Float 浮点 对应位置参数必须是数字型 否则报错</li></ul></li><li>%-10s ： 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</li><li>%-4.2f ：指格式化为小数，宽度为4个字符，其中.2指保留2位小数。</li><li>转义符：<ul><li>\a ：警告字符，通常为ASCII的BEL字符</li><li>\b ：后退</li><li>\c ：抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</li><li>\f ：换页（formfeed）<br>\n ：换行</li><li>\r ：回车（Carriage return）</li><li>\t ：水平制表符</li><li>\v ：垂直制表符</li><li>\ ：一个字面上的反斜杠字符</li><li>\ddd ：表示1到3位数八进制值的字符。仅在格式字符串中有效</li><li>\0ddd ：表示1到3位的八进制值字符</li></ul></li></ul><hr><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>和Java、PHP等语言不一样，sh的流程控制不可为空，即if或者else的大括号中无任何语句</p><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><ul><li>if</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>if else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>if else-if else</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line"><span class="keyword">elif</span> condition2 </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">    command2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li>for</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>while</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>while 无限循环</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li>until<br>until 循环执行一系列命令直至条件为 true 时停止。<br>until 循环与 while 循环在处理方式上刚好相反。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。<br>case需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break，其中“;;”不是跳出循环，是不在去匹配下面的模式<br>case语句格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> 值 <span class="keyword">in</span></span><br><span class="line">  模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">  模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h4 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h4><ul><li>break ：跳出总循环</li><li>continue：跳出当前循环，继续下一次循环</li></ul><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</p><ul><li>函数定义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname()</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数传递<ul><li>调用函数: <code>fun_name 2 3 4</code></li><li>函数中使用：和<code>shell</code>取用函数相同 <code>$n $# $* $?</code>或者加上<code>{}</code></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">funWithParam</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第一个参数为 1 !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第二个参数为 2 !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 10 !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十个参数为 &#123;10&#125; !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"第十一个参数为 &#123;11&#125; !"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"参数总数有 # 个!"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"作为一个字符串输出所有参数 * !"</span>&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line"><span class="built_in">echo</span> ?  <span class="comment"># 判断执行是否成功</span></span><br></pre></td></tr></table></figure><ul><li>函数返回值<ul><li>return字样可存在也可不存在</li><li>return 只能为 return [0-255]，此处的返回可作为函数执行的状态，通过<code>$?</code>获取的便是这个返回值</li><li>如果不加return ， 则默认最后一条语句的执行状态所为函数执行状态的返回值，如果最后一条语句执行成功，则<code>$?</code>为0，否则不为0</li></ul></li><li>使用函数返回值（<code>Janusgraph</code>图数据库官方启动服务脚本片段）<ul><li><code>return</code>返回的数字，只是作为函数执行状态的返回值，也就是接下来<code>$?</code>获取的值</li><li>对于类似于下面的<code>BIN=\abs_path</code>语句，获取的是函数体内所有的<code>echo、printf</code>输出组合成的一个字符串</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">abs_path</span></span>() &#123;</span><br><span class="line">    SOURCE=<span class="string">"&#123;BASH_SOURCE[0]&#125;"</span></span><br><span class="line">    <span class="keyword">while</span> [ -h <span class="string">"SOURCE"</span> ]; <span class="keyword">do</span></span><br><span class="line">        DIR=<span class="string">"( cd -P "</span>( dirname <span class="string">"SOURCE"</span> )<span class="string">" &amp;&amp; pwd )"</span></span><br><span class="line">        SOURCE=<span class="string">"(readlink "</span>SOURCE<span class="string">")"</span></span><br><span class="line">        [[ SOURCE != /* ]] &amp;&amp; SOURCE=<span class="string">"DIR/SOURCE"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"test"</span>  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"( cd -P "</span>( dirname <span class="string">"<span class="variable">$SOURCE</span>"</span> )<span class="string">" &amp;&amp; pwd )"</span>  </span><br><span class="line">    此函数的两个<span class="built_in">echo</span>输出会组合成一个字符串作为下述BIN的值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BIN=abs_path <span class="comment"># BIN赋值函数返回值，如果没有return，则函数中所有的echo、printf输出组合成一个字符串传入BIN</span></span><br><span class="line">path=<span class="variable">$&#123;BIN&#125;</span>/nodetool <span class="comment"># 可直接使用</span></span><br></pre></td></tr></table></figure><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。<br>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><ul><li>bash.sh &lt; file ： 将脚本的输入重定向到file，由file提供参数</li></ul><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><ul><li>bash.sh &gt; file ： 将脚本的输出数据重定向到file中，覆盖数据</li><li>bash.sh &gt;&gt; file ： 将脚本的输出数据重定向到file中，追加数据</li><li>command &gt;&gt; file 2&gt;&amp;1 ： 将 stdout 和 stderr 合并后重定向到 file</li></ul><h4 id="读取外部输入"><a href="#读取外部输入" class="headerlink" title="读取外部输入"></a>读取外部输入</h4><p>命令：<code>read arg</code> （脚本读取外部输入并赋值到变量上）<br>在shell脚本执行到上述命令时，停止脚本执行并等待外部输入，将外部输入赋值到arg变量上，继续执行脚本</p><h3 id="文件引用"><a href="#文件引用" class="headerlink" title="文件引用"></a>文件引用</h3><p>引用其他的文件之后，可以使用其变量、函数等等，相当于将引用的文件包含进了当前文件<br>两种方式：</p><ul><li><code>. file_path\file_name</code></li><li><code>source file_path\file_name</code></li></ul><h3 id="颜色标识"><a href="#颜色标识" class="headerlink" title="颜色标识"></a>颜色标识</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>  <span class="string">"\033[32m SUCCESS: yay \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span>  <span class="string">"\033[33m WARNING: hmm \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span>  <span class="string">"\033[31m ERROR: fubar \033[0m\n"</span>;</span><br></pre></td></tr></table></figure><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a><strong>输出结果：</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUCCESS: yay</span><br><span class="line">WARNING: hmm</span><br><span class="line">ERROR: fubar</span><br></pre></td></tr></table></figure><h3 id="长句换行"><a href="#长句换行" class="headerlink" title="长句换行"></a>长句换行</h3><p>在shell中为避免一个语句过长，可以使用“\”进行换行<br>使用“\”换行，在脚本执行过程中还是当做一行一个语句执行，不同于enter直接换行</p><blockquote><p>注意：\ 前添加一个空格 。 \ 后无空格直接换行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/mysql/bin/mysql \</span><br><span class="line"> -h test_host  -P 000 \</span><br><span class="line"> -u test_user -ptest_password ;</span><br></pre></td></tr></table></figure><h3 id="shell操作mysql"><a href="#shell操作mysql" class="headerlink" title="shell操作mysql"></a>shell操作mysql</h3><p>下面案例为登录mysql，并选择操作数据库，之后进行导入数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/mysql/mysql/bin/mysql \</span><br><span class="line"> -h test_host  -P 000 \</span><br><span class="line"> -u test_user -ptest_password \</span><br><span class="line"> -e<span class="string">"use test_database; source data_faile; "</span> <span class="comment"># -e 代表执行sql语句</span></span><br></pre></td></tr></table></figure><blockquote><p>-u 用户名<br>-p 用户密码<br>-h 服务器ip地址<br>-D 连接的数据库<br>-N 不输出列信息<br>-B 使用tab键 代替 分隔符<br>-e 执行的SQL语句</p></blockquote><h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p><strong>命令：exit</strong></p><p>在退出脚本时使用不同的错误码，这样可以根据错误码来判断发生了什么错误。</p><blockquote><p>在绝大多数 shell 脚本中，exit 0 表示执行成功，exit 1 表示发生错误。<br>对错误与错误码进行一对一的映射，这样有助于脚本调试。</p></blockquote><p><strong>命令：set -e 或者 set +e</strong></p><p>set -e表示从当前位置开始，如果出现任何错误都将触发exit。相反，set +e表示不管出现任何错误继续执行脚本。</p><blockquote><p>如果脚本是有状态的（每个后续步骤都依赖前一个步骤），那么请使用set -e，在脚本出现错误时立即退出脚本。<br>如果要求所有命令都要执行完（很少会这样），那么就使用set +e。</p></blockquote><h3 id="shell脚本调试"><a href="#shell脚本调试" class="headerlink" title="shell脚本调试"></a>shell脚本调试</h3><p>检查是否有语法错误<code>-n</code>：<br><code>bash -n script_name.sh</code><br>使用下面的命令来执行并调试 Shell 脚本<code>-x</code>：<br><code>bash -x script_name.sh</code><br><strong>调试count_odd_number.sh 程序案例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin.env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于计算数组中奇数的和</span></span><br><span class="line"><span class="comment"># @author liyangyang</span></span><br><span class="line"><span class="comment"># @time 2019/09/17</span></span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4;<span class="keyword">do</span></span><br><span class="line">    re=&#123;num&#125;%2</span><br><span class="line">    <span class="keyword">if</span> (( &#123;re&#125; == 1 ));<span class="keyword">then</span></span><br><span class="line">        sum=[&#123;sum&#125;+&#123;num&#125;]</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> &#123;sum&#125;</span><br></pre></td></tr></table></figure><ol><li>首先检查有无语法错误：<br><code>bash -n count_odd_number.sh</code></li><li>没有输出，说明没有错误，开始实际调试：<br><code>bash -x count_odd_number.sh</code></li><li>调试结果如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ sum=0</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=1%2</span><br><span class="line">+ ((  1%2 == 1  ))</span><br><span class="line">+ sum=1</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=2%2</span><br><span class="line">+ ((  2%2 == 1  ))</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=3%2</span><br><span class="line">+ ((  3%2 == 1  ))</span><br><span class="line">+ sum=4</span><br><span class="line">+ <span class="keyword">for</span> num <span class="keyword">in</span> 1 2 3 4</span><br><span class="line">+ re=4%2</span><br><span class="line">+ ((  4%2 == 1  ))</span><br><span class="line">+ <span class="built_in">echo</span> 4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>其中的输出显示了程序执行的每一步，通过观察程序执行的步骤是否满足预期从而达到调试的效果<br>带有 + 表示的是 Shell 调试器的输出，不带 + 表示程序的输出。</p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p>这是es（ElasticSearch）官方启动服务的脚本，看可不可以理解吧~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CONTROLLING STARTUP:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script relies on a few environment variables to determine startup</span></span><br><span class="line"><span class="comment"># behavior, those variables are:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   ES_PATH_CONF -- Path to config directory</span></span><br><span class="line"><span class="comment">#   ES_JAVA_OPTS -- External Java Opts on top of the defaults set</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Optionally, exact memory values can be set using the `ES_JAVA_OPTS`. Note that</span></span><br><span class="line"><span class="comment"># the Xms and Xmx lines in the JVM options file must be commented out. Example</span></span><br><span class="line"><span class="comment"># values are "512m", and "10g".</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   ES_JAVA_OPTS="-Xms8g -Xmx8g" ./bin/elasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="string">"`dirname "</span><span class="variable">$0</span><span class="string">"`"</span>/elasticsearch-env</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">parse_jvm_options</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"`grep "</span>^-<span class="string">" "</span><span class="variable">$1</span><span class="string">" | tr '\n' ' '`"</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES_JVM_OPTIONS=<span class="string">"<span class="variable">$ES_PATH_CONF</span>"</span>/jvm.options</span><br><span class="line"></span><br><span class="line">ES_JAVA_OPTS=<span class="string">"`parse_jvm_options "</span><span class="variable">$ES_JVM_OPTIONS</span><span class="string">"` <span class="variable">$ES_JAVA_OPTS</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># manual parsing to find out, if process should be detached</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">echo</span> $* | grep -E <span class="string">'(^-d |-d$| -d |--daemonize$|--daemonize )'</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exec</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$JAVA</span>"</span> \</span><br><span class="line">    <span class="variable">$ES_JAVA_OPTS</span> \</span><br><span class="line">    -Des.path.home=<span class="string">"<span class="variable">$ES_HOME</span>"</span> \</span><br><span class="line">    -Des.path.conf=<span class="string">"<span class="variable">$ES_PATH_CONF</span>"</span> \</span><br><span class="line">    -cp <span class="string">"<span class="variable">$ES_CLASSPATH</span>"</span> \</span><br><span class="line">    org.elasticsearch.bootstrap.Elasticsearch \</span><br><span class="line">    <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> \</span><br><span class="line">    <span class="string">"<span class="variable">$JAVA</span>"</span> \</span><br><span class="line">    <span class="variable">$ES_JAVA_OPTS</span> \</span><br><span class="line">    -Des.path.home=<span class="string">"<span class="variable">$ES_HOME</span>"</span> \</span><br><span class="line">    -Des.path.conf=<span class="string">"<span class="variable">$ES_PATH_CONF</span>"</span> \</span><br><span class="line">    -cp <span class="string">"<span class="variable">$ES_CLASSPATH</span>"</span> \</span><br><span class="line">    org.elasticsearch.bootstrap.Elasticsearch \</span><br><span class="line">    <span class="string">"<span class="variable">$@</span>"</span> \</span><br><span class="line">    &lt;&amp;- &amp;</span><br><span class="line">  retval=$?</span><br><span class="line">  pid=$!</span><br><span class="line">  [ <span class="variable">$retval</span> -eq 0 ] || <span class="built_in">exit</span> <span class="variable">$retval</span></span><br><span class="line">  <span class="keyword">if</span> [ ! -z <span class="string">"<span class="variable">$ES_STARTUP_SLEEP_TIME</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    sleep <span class="variable">$ES_STARTUP_SLEEP_TIME</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> ! ps -p <span class="variable">$pid</span> &gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> $?</span><br></pre></td></tr></table></figure><h3 id="经常来看看才能记住😭"><a href="#经常来看看才能记住😭" class="headerlink" title="经常来看看才能记住😭"></a>经常来看看才能记住😭</h3>]]></content>
    
    <summary type="html">
    
      Shell脚本命令
    
    </summary>
    
    
    
      <category term="Shell" scheme="penghui.club/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="penghui.club/2020/07/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>penghui.club/2020/07/13/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-13T12:06:19.000Z</published>
    <updated>2020-07-13T13:33:14.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我想开一家酒馆 名字就叫陈年旧事吧 这家店只深夜开门半夜打烊 这家店没有激情的音乐 这家店会有你喜欢的装修 这家店不摇头不蹦迪 这家店长会跟每一个顾客分享故事 这家店会有一个唯一的免费会员 这家店是年少时我们一起的玩笑话 这家店我想开在郑州 今年我二十岁 我想在二十五岁开。</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这次的排序没有逼格！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    quickSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (le &gt;= ri) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(a, le, ri);</span><br><span class="line">    quickSort(a, le, j - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, j + <span class="number">1</span>, ri);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = a[le];</span><br><span class="line">    <span class="keyword">int</span> i = le, j = ri + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], base)) <span class="keyword">if</span> (i == ri) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(base, a[--j])) <span class="keyword">if</span> (j == le) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, le, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i]; a[i] = a[j]; a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于以上标准快排的优化："><a href="#关于以上标准快排的优化：" class="headerlink" title="关于以上标准快排的优化："></a>关于以上标准快排的优化：</h3><p>以下使用三向切分的思路进行优化，他从左到右遍历数组一次，维护一个指针<code>lt</code>使得<code>a[lo..lt-1]</code>中的元素都小于<code>v</code>，一个指针<code>gt</code>使得<code>a[gt+1..hi]</code>中的元素都大于<code>v</code>，一个指针<code>i</code>使得<code>a[lt..i-1]</code>中的元素都等于<code>v</code>，<code>a[i..gt]</code>中的元素都还未确定。分以下三种情况：</p><ul><li><code>a[i]</code> &lt; <code>v</code>，将<code>a[lt]</code>和<code>a[i]</code>交换，将<code>lt</code>和<code>i</code>加一。</li><li><code>a[i]</code> &gt; <code>v</code>，将<code>a[gt]</code>和<code>a[i]</code>交换，将<code>gt</code>减一。</li><li><code>a[i]</code> == v，将<code>i</code>加一。</li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> le, <span class="keyword">int</span> ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (le &gt;= ri) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = le, i = le + <span class="number">1</span>, gt = ri;</span><br><span class="line">    <span class="keyword">int</span> v = a[le];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = less(a[i], v);</span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) exch(a, lt ++, i ++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) exch(a, i, gt --);</span><br><span class="line">        <span class="keyword">else</span>              i ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort(a, le, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, gt + <span class="number">1</span>, ri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>      (x &lt; y) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; y) <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[i]; a[i] = a[j]; a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我想开一家酒馆 名字就叫陈年旧事吧 这家店只深夜开门半夜打烊 这家店没有激情的音乐 这家店会有你喜欢的装修 这家店不摇头不蹦迪 这家店长会跟每一个顾客分享故事 这家店会有一个唯一的免费会员 这家店是年少时我们一起的玩笑话 这家店我想开在郑州 今年我二十岁 我想在二十五岁开。&lt;/p&gt;
&lt;p&gt;​                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="penghui.club/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯方块的Shell脚本</title>
    <link href="penghui.club/2020/07/13/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E7%9A%84Shell%E8%84%9A%E6%9C%AC/"/>
    <id>penghui.club/2020/07/13/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97%E7%9A%84Shell%E8%84%9A%E6%9C%AC/</id>
    <published>2020-07-13T03:06:29.000Z</published>
    <updated>2020-07-13T12:36:33.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>人生一世 草木一秋 即是事过三而虑 醒来时抬头 着觉时回首 醉酒时忘忧</p><p>   ​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="俄罗斯方块"><a href="#俄罗斯方块" class="headerlink" title="俄罗斯方块"></a>俄罗斯方块</h2><p>此篇纯粹为了好玩！</p><h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>首先创建一个shell脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Tetris.sh</span><br></pre></td></tr></table></figure><h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>复制以下内容，粘贴到脚本中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Tetris Game</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.21.2003 xhchen&lt;[email]xhchen@winbond.com.tw[/email]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">APP declaration</span></span><br><span class="line">APP_NAME="$&#123;0##*[\\/]&#125;"</span><br><span class="line">APP_VERSION="1.0"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">颜色定义</span></span><br><span class="line">cRed=1</span><br><span class="line">cGreen=2</span><br><span class="line">cYellow=3</span><br><span class="line">cBlue=4</span><br><span class="line">cFuchsia=5</span><br><span class="line">cCyan=6</span><br><span class="line">cWhite=7</span><br><span class="line">colorTable=($cRed $cGreen $cYellow $cBlue $cFuchsia $cCyan $cWhite)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">位置和大小</span></span><br><span class="line">iLeft=3</span><br><span class="line">iTop=2</span><br><span class="line">((iTrayLeft = iLeft + 2))</span><br><span class="line">((iTrayTop = iTop + 1))</span><br><span class="line">((iTrayWidth = 10))</span><br><span class="line">((iTrayHeight = 15))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">颜色设置</span></span><br><span class="line">cBorder=$cGreen</span><br><span class="line">cScore=$cFuchsia</span><br><span class="line">cScoreValue=$cCyan</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">控制信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash">改游戏使用两个进程，一个用于接收输入，一个用于游戏流程和显示界面;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当前者接收到上下左右等按键时，通过向后者发送signal的方式通知后者。</span></span><br><span class="line">sigRotate=25</span><br><span class="line">sigLeft=26</span><br><span class="line">sigRight=27</span><br><span class="line">sigDown=28</span><br><span class="line">sigAllDown=29</span><br><span class="line">sigExit=30</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">七中不同的方块的定义</span></span><br><span class="line"><span class="meta">#</span><span class="bash">通过旋转，每种方块的显示的样式可能有几种</span></span><br><span class="line">box0=(0 0 0 1 1 0 1 1)</span><br><span class="line">box1=(0 2 1 2 2 2 3 2 1 0 1 1 1 2 1 3)</span><br><span class="line">box2=(0 0 0 1 1 1 1 2 0 1 1 0 1 1 2 0)</span><br><span class="line">box3=(0 1 0 2 1 0 1 1 0 0 1 0 1 1 2 1)</span><br><span class="line">box4=(0 1 0 2 1 1 2 1 1 0 1 1 1 2 2 2 0 1 1 1 2 0 2 1 0 0 1 0 1 1 1 2)</span><br><span class="line">box5=(0 1 1 1 2 1 2 2 1 0 1 1 1 2 2 0 0 0 0 1 1 1 2 1 0 2 1 0 1 1 1 2)</span><br><span class="line">box6=(0 1 1 1 1 2 2 1 1 0 1 1 1 2 2 1 0 1 1 0 1 1 2 1 0 1 1 0 1 1 1 2)</span><br><span class="line"><span class="meta">#</span><span class="bash">所有其中方块的定义都放到box变量中</span></span><br><span class="line">box=($&#123;box0[@]&#125; $&#123;box1[@]&#125; $&#123;box2[@]&#125; $&#123;box3[@]&#125; $&#123;box4[@]&#125; $&#123;box5[@]&#125; $&#123;box6[@]&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash">各种方块旋转后可能的样式数目</span></span><br><span class="line">countBox=(1 2 2 2 4 4 4)</span><br><span class="line"><span class="meta">#</span><span class="bash">各种方块再box数组中的偏移</span></span><br><span class="line">offsetBox=(0 1 3 5 7 11 15)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">每提高一个速度级需要积累的分数</span></span><br><span class="line">iScoreEachLevel=50        #be greater than 7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行时数据</span></span><br><span class="line">sig=0                #接收到的signal</span><br><span class="line">iScore=0        #总分</span><br><span class="line">iLevel=0        #速度级</span><br><span class="line">boxNew=()        #新下落的方块的位置定义</span><br><span class="line">cBoxNew=0        #新下落的方块的颜色</span><br><span class="line">iBoxNewType=0        #新下落的方块的种类</span><br><span class="line">iBoxNewRotate=0        #新下落的方块的旋转角度</span><br><span class="line">boxCur=()        #当前方块的位置定义</span><br><span class="line">cBoxCur=0        #当前方块的颜色</span><br><span class="line">iBoxCurType=0        #当前方块的种类</span><br><span class="line">iBoxCurRotate=0        #当前方块的旋转角度</span><br><span class="line">boxCurX=-1        #当前方块的x坐标位置</span><br><span class="line">boxCurY=-1        #当前方块的y坐标位置</span><br><span class="line">iMap=()                #背景方块图表</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">初始化所有背景方块为-1, 表示没有方块</span></span><br><span class="line">for ((i = 0; i &lt; iTrayHeight * iTrayWidth; i++)); do iMap[$i]=-1; done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">接收输入的进程的主函数</span></span><br><span class="line">function RunAsKeyReceiver()</span><br><span class="line">&#123;</span><br><span class="line">        local pidDisplayer key aKey sig cESC sTTY</span><br><span class="line"></span><br><span class="line">        pidDisplayer=$1</span><br><span class="line">        aKey=(0 0 0)</span><br><span class="line"></span><br><span class="line">        cESC=`echo -ne "\033"`</span><br><span class="line">        cSpace=`echo -ne "\040"`</span><br><span class="line"></span><br><span class="line">        #保存终端属性。在read -s读取终端键时，终端的属性会被暂时改变。</span><br><span class="line">        #如果在read -s时程序被不幸杀掉，可能会导致终端混乱，</span><br><span class="line">        #需要在程序退出时恢复终端属性。</span><br><span class="line">        sTTY=`stty -g`</span><br><span class="line"></span><br><span class="line">        #捕捉退出信号</span><br><span class="line">        trap "MyExit;" INT TERM</span><br><span class="line">        trap "MyExitNoSub;" $sigExit</span><br><span class="line"></span><br><span class="line">        #隐藏光标</span><br><span class="line">        echo -ne "\033[?25l"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #读取输入。注-s不回显，-n读到一个字符立即返回</span><br><span class="line">                read -s -n 1 key</span><br><span class="line"></span><br><span class="line">                aKey[0]=$&#123;aKey[1]&#125;</span><br><span class="line">                aKey[1]=$&#123;aKey[2]&#125;</span><br><span class="line">                aKey[2]=$key</span><br><span class="line">                sig=0</span><br><span class="line"></span><br><span class="line">                #判断输入了何种键</span><br><span class="line">                if [[ $key == $cESC &amp;&amp; $&#123;aKey[1]&#125; == $cESC ]]</span><br><span class="line">                then</span><br><span class="line">                        #ESC键</span><br><span class="line">                        MyExit</span><br><span class="line">                elif [[ $&#123;aKey[0]&#125; == $cESC &amp;&amp; $&#123;aKey[1]&#125; == "[" ]]</span><br><span class="line">                then</span><br><span class="line">                        if [[ $key == "A" ]]; then sig=$sigRotate        #&lt;向上键&gt;</span><br><span class="line">                        elif [[ $key == "B" ]]; then sig=$sigDown        #&lt;向下键&gt;</span><br><span class="line">                        elif [[ $key == "D" ]]; then sig=$sigLeft        #&lt;向左键&gt;</span><br><span class="line">                        elif [[ $key == "C" ]]; then sig=$sigRight        #&lt;向右键&gt;</span><br><span class="line">                        fi</span><br><span class="line">                elif [[ $key == "W" || $key == "w" ]]; then sig=$sigRotate        #W, w</span><br><span class="line">                elif [[ $key == "S" || $key == "s" ]]; then sig=$sigDown        #S, s</span><br><span class="line">                elif [[ $key == "A" || $key == "a" ]]; then sig=$sigLeft        #A, a</span><br><span class="line">                elif [[ $key == "D" || $key == "d" ]]; then sig=$sigRight        #D, d</span><br><span class="line">                elif [[ "[$key]" == "[]" ]]; then sig=$sigAllDown        #空格键</span><br><span class="line">                elif [[ $key == "Q" || $key == "q" ]]                        #Q, q</span><br><span class="line">                then</span><br><span class="line">                        MyExit</span><br><span class="line">                fi</span><br><span class="line"></span><br><span class="line">                if [[ $sig != 0 ]]</span><br><span class="line">                then</span><br><span class="line">                        #向另一进程发送消息</span><br><span class="line">                        kill -$sig $pidDisplayer</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出前的恢复</span></span><br><span class="line">function MyExitNoSub()</span><br><span class="line">&#123;</span><br><span class="line">        local y</span><br><span class="line"></span><br><span class="line">        #恢复终端属性</span><br><span class="line">        stty $sTTY</span><br><span class="line">        ((y = iTop + iTrayHeight + 4))</span><br><span class="line"></span><br><span class="line">        #显示光标</span><br><span class="line">        echo -e "\033[?25h\033[$&#123;y&#125;;0H"</span><br><span class="line">        exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function MyExit()</span><br><span class="line">&#123;</span><br><span class="line">        #通知显示进程需要退出</span><br><span class="line">        kill -$sigExit $pidDisplayer</span><br><span class="line"></span><br><span class="line">        MyExitNoSub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">处理显示和游戏流程的主函数</span></span><br><span class="line">function RunAsDisplayer()</span><br><span class="line">&#123;</span><br><span class="line">        local sigThis</span><br><span class="line">        InitDraw</span><br><span class="line"></span><br><span class="line">        #挂载各种信号的处理函数</span><br><span class="line">        trap "sig=$sigRotate;" $sigRotate</span><br><span class="line">        trap "sig=$sigLeft;" $sigLeft</span><br><span class="line">        trap "sig=$sigRight;" $sigRight</span><br><span class="line">        trap "sig=$sigDown;" $sigDown</span><br><span class="line">        trap "sig=$sigAllDown;" $sigAllDown</span><br><span class="line">        trap "ShowExit;" $sigExit</span><br><span class="line"></span><br><span class="line">        while :</span><br><span class="line">        do</span><br><span class="line">                #根据当前的速度级iLevel不同，设定相应的循环的次数</span><br><span class="line">                for ((i = 0; i &lt; 21 - iLevel; i++))</span><br><span class="line">                do</span><br><span class="line">                        sleep 0.02</span><br><span class="line">                        sigThis=$sig</span><br><span class="line">                        sig=0</span><br><span class="line"></span><br><span class="line">                        #根据sig变量判断是否接受到相应的信号</span><br><span class="line">                        if ((sigThis == sigRotate)); then BoxRotate;        #旋转</span><br><span class="line">                        elif ((sigThis == sigLeft)); then BoxLeft;        #左移一列</span><br><span class="line">                        elif ((sigThis == sigRight)); then BoxRight;        #右移一列</span><br><span class="line">                        elif ((sigThis == sigDown)); then BoxDown;        #下落一行</span><br><span class="line">                        elif ((sigThis == sigAllDown)); then BoxAllDown;        #下落到底</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">                #kill -$sigDown $$</span><br><span class="line">                BoxDown        #下落一行</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">BoxMove(y, x), 测试是否可以把移动中的方块移到(x, y)的位置, 返回0则可以, 1不可以</span></span><br><span class="line">function BoxMove()</span><br><span class="line">&#123;</span><br><span class="line">        local j i x y xTest yTest</span><br><span class="line">        yTest=$1</span><br><span class="line">        xTest=$2</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + yTest))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + xTest))</span><br><span class="line">                if (( y &lt; 0 || y &gt;= iTrayHeight || x &lt; 0 || x &gt;= iTrayWidth))</span><br><span class="line">                then</span><br><span class="line">                        #撞到墙壁了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">                if (($&#123;iMap[y * iTrayWidth + x]&#125; != -1 ))</span><br><span class="line">                then</span><br><span class="line">                        #撞到其他已经存在的方块了</span><br><span class="line">                        return 1</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将当前移动中的方块放到背景方块中去,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">并计算新的分数和速度级。(即一次方块落到底部)</span></span><br><span class="line">function Box2Map()</span><br><span class="line">&#123;</span><br><span class="line">        local j i x y xp yp line</span><br><span class="line"></span><br><span class="line">        #将当前移动中的方块放到背景方块中去</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + boxCurY))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + boxCurX))</span><br><span class="line">                ((i = y * iTrayWidth + x))</span><br><span class="line">                iMap[$i]=$cBoxCur</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        #消去可被消去的行</span><br><span class="line">        line=0</span><br><span class="line">        for ((j = 0; j &lt; iTrayWidth * iTrayHeight; j += iTrayWidth))</span><br><span class="line">        do</span><br><span class="line">                for ((i = j + iTrayWidth - 1; i &gt;= j; i--))</span><br><span class="line">                do</span><br><span class="line">                        if (($&#123;iMap[$i]&#125; == -1)); then break; fi</span><br><span class="line">                done</span><br><span class="line">                if ((i &gt;= j)); then continue; fi</span><br><span class="line"></span><br><span class="line">                ((line++))</span><br><span class="line">                for ((i = j - 1; i &gt;= 0; i--))</span><br><span class="line">                do</span><br><span class="line">                        ((x = i + iTrayWidth))</span><br><span class="line">                        iMap[$x]=$&#123;iMap[$i]&#125;</span><br><span class="line">                done</span><br><span class="line">                for ((i = 0; i &lt; iTrayWidth; i++))</span><br><span class="line">                do</span><br><span class="line">                        iMap[$i]=-1</span><br><span class="line">                done</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        if ((line == 0)); then return; fi</span><br><span class="line"></span><br><span class="line">        #根据消去的行数line计算分数和速度级</span><br><span class="line">        ((x = iLeft + iTrayWidth * 2 + 7))</span><br><span class="line">        ((y = iTop + 11))</span><br><span class="line">        ((iScore += line * 2 - 1))</span><br><span class="line">        #显示新的分数</span><br><span class="line">        echo -ne "\033[1m\033[3$&#123;cScoreValue&#125;m\033[$&#123;y&#125;;$&#123;x&#125;H$&#123;iScore&#125;         "</span><br><span class="line">        if ((iScore % iScoreEachLevel &lt; line * 2 - 1))</span><br><span class="line">        then</span><br><span class="line">                if ((iLevel &lt; 20))</span><br><span class="line">                then</span><br><span class="line">                        ((iLevel++))</span><br><span class="line">                        ((y = iTop + 14))</span><br><span class="line">                        #显示新的速度级</span><br><span class="line">                        echo -ne "\033[3$&#123;cScoreValue&#125;m\033[$&#123;y&#125;;$&#123;x&#125;H$&#123;iLevel&#125;        "</span><br><span class="line">                fi</span><br><span class="line">        fi</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #重新显示背景方块</span><br><span class="line">        for ((y = 0; y &lt; iTrayHeight; y++))</span><br><span class="line">        do</span><br><span class="line">                ((yp = y + iTrayTop + 1))</span><br><span class="line">                ((xp = iTrayLeft + 1))</span><br><span class="line">                ((i = y * iTrayWidth))</span><br><span class="line">                echo -ne "\033[$&#123;yp&#125;;$&#123;xp&#125;H"</span><br><span class="line">                for ((x = 0; x &lt; iTrayWidth; x++))</span><br><span class="line">                do</span><br><span class="line">                        ((j = i + x))</span><br><span class="line">                        if (($&#123;iMap[$j]&#125; == -1))</span><br><span class="line">                        then</span><br><span class="line">                                echo -ne "  "</span><br><span class="line">                        else</span><br><span class="line">                                echo -ne "\033[1m\033[7m\033[3$&#123;iMap[$j]&#125;m\033[4$&#123;iMap[$j]&#125;m[]\033[0m"</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下落一行</span></span><br><span class="line">function BoxDown()</span><br><span class="line">&#123;</span><br><span class="line">        local y s</span><br><span class="line">        ((y = boxCurY + 1))        #新的y坐标</span><br><span class="line">        if BoxMove $y $boxCurX        #测试是否可以下落一行</span><br><span class="line">        then</span><br><span class="line">                s="`DrawCurBox 0`"        #将旧的方块抹去</span><br><span class="line">                ((boxCurY = y))</span><br><span class="line">                s="$s`DrawCurBox 1`"        #显示新的下落后方块</span><br><span class="line">                echo -ne $s</span><br><span class="line">        else</span><br><span class="line">                #走到这儿, 如果不能下落了</span><br><span class="line">                Box2Map                #将当前移动中的方块贴到背景方块中</span><br><span class="line">                RandomBox        #产生新的方块</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">左移一列</span></span><br><span class="line">function BoxLeft()</span><br><span class="line">&#123;</span><br><span class="line">        local x s</span><br><span class="line">        ((x = boxCurX - 1))</span><br><span class="line">        if BoxMove $boxCurY $x</span><br><span class="line">        then</span><br><span class="line">                s=`DrawCurBox 0`</span><br><span class="line">                ((boxCurX = x))</span><br><span class="line">                s=$s`DrawCurBox 1`</span><br><span class="line">                echo -ne $s</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">右移一列</span></span><br><span class="line">function BoxRight()</span><br><span class="line">&#123;</span><br><span class="line">        local x s</span><br><span class="line">        ((x = boxCurX + 1))</span><br><span class="line">        if BoxMove $boxCurY $x</span><br><span class="line">        then</span><br><span class="line">                s=`DrawCurBox 0`</span><br><span class="line">                ((boxCurX = x))</span><br><span class="line">                s=$s`DrawCurBox 1`</span><br><span class="line">                echo -ne $s</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下落到底</span></span><br><span class="line">function BoxAllDown()</span><br><span class="line">&#123;</span><br><span class="line">        local k j i x y iDown s</span><br><span class="line">        iDown=$iTrayHeight</span><br><span class="line"></span><br><span class="line">        #计算一共需要下落多少行</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = j + 1))</span><br><span class="line">                ((y = $&#123;boxCur[$j]&#125; + boxCurY))</span><br><span class="line">                ((x = $&#123;boxCur[$i]&#125; + boxCurX))</span><br><span class="line">                for ((k = y + 1; k &lt; iTrayHeight; k++))</span><br><span class="line">                do</span><br><span class="line">                        ((i = k * iTrayWidth + x))</span><br><span class="line">                        if (( $&#123;iMap[$i]&#125; != -1)); then break; fi</span><br><span class="line">                done</span><br><span class="line">                ((k -= y + 1))</span><br><span class="line">                if (( $iDown &gt; $k )); then iDown=$k; fi</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        s=`DrawCurBox 0`        #将旧的方块抹去</span><br><span class="line">        ((boxCurY += iDown))</span><br><span class="line">        s=$s`DrawCurBox 1`        #显示新的下落后的方块</span><br><span class="line">        echo -ne $s</span><br><span class="line">        Box2Map                #将当前移动中的方块贴到背景方块中</span><br><span class="line">        RandomBox        #产生新的方块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">旋转方块</span></span><br><span class="line">function BoxRotate()</span><br><span class="line">&#123;</span><br><span class="line">        local iCount iTestRotate boxTest j i s</span><br><span class="line">        iCount=$&#123;countBox[$iBoxCurType]&#125;        #当前的方块经旋转可以产生的样式的数目</span><br><span class="line"></span><br><span class="line">        #计算旋转后的新的样式</span><br><span class="line">        ((iTestRotate = iBoxCurRotate + 1))</span><br><span class="line">        if ((iTestRotate &gt;= iCount))</span><br><span class="line">        then</span><br><span class="line">                ((iTestRotate = 0))</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        #更新到新的样式, 保存老的样式(但不显示)</span><br><span class="line">        for ((j = 0, i = ($&#123;offsetBox[$iBoxCurType]&#125; + $iTestRotate) * 8; j &lt; 8; j++, i++))</span><br><span class="line">        do</span><br><span class="line">                boxTest[$j]=$&#123;boxCur[$j]&#125;</span><br><span class="line">                boxCur[$j]=$&#123;box[$i]&#125;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        if BoxMove $boxCurY $boxCurX        #测试旋转后是否有空间放的下</span><br><span class="line">        then</span><br><span class="line">                #抹去旧的方块</span><br><span class="line">                for ((j = 0; j &lt; 8; j++))</span><br><span class="line">                do</span><br><span class="line">                        boxCur[$j]=$&#123;boxTest[$j]&#125;</span><br><span class="line">                done</span><br><span class="line">                s=`DrawCurBox 0`</span><br><span class="line"></span><br><span class="line">                #画上新的方块</span><br><span class="line">                for ((j = 0, i = ($&#123;offsetBox[$iBoxCurType]&#125; + $iTestRotate) * 8; j &lt; 8; j++, i++))</span><br><span class="line">                do</span><br><span class="line">                        boxCur[$j]=$&#123;box[$i]&#125;</span><br><span class="line">                done</span><br><span class="line">                s=$s`DrawCurBox 1`</span><br><span class="line">                echo -ne $s</span><br><span class="line">                iBoxCurRotate=$iTestRotate</span><br><span class="line">        else</span><br><span class="line">                #不能旋转，还是继续使用老的样式</span><br><span class="line">                for ((j = 0; j &lt; 8; j++))</span><br><span class="line">                do</span><br><span class="line">                        boxCur[$j]=$&#123;boxTest[$j]&#125;</span><br><span class="line">                done</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">DrawCurBox(bDraw), 绘制当前移动中的方块, bDraw为1, 画上, bDraw为0, 抹去方块。</span></span><br><span class="line">function DrawCurBox()</span><br><span class="line">&#123;</span><br><span class="line">        local i j t bDraw sBox s</span><br><span class="line">        bDraw=$1</span><br><span class="line"></span><br><span class="line">        s=""</span><br><span class="line">        if (( bDraw == 0 ))</span><br><span class="line">        then</span><br><span class="line">                sBox="\040\040"</span><br><span class="line">        else</span><br><span class="line">                sBox="[]"</span><br><span class="line">                s=$s"\033[1m\033[7m\033[3$&#123;cBoxCur&#125;m\033[4$&#123;cBoxCur&#125;m"</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = iTrayTop + 1 + $&#123;boxCur[$j]&#125; + boxCurY))</span><br><span class="line">                ((t = iTrayLeft + 1 + 2 * (boxCurX + $&#123;boxCur[$j + 1]&#125;)))</span><br><span class="line">                #\033[y;xH, 光标到(x, y)处</span><br><span class="line">                s=$s"\033[$&#123;i&#125;;$&#123;t&#125;H$&#123;sBox&#125;"</span><br><span class="line">        done</span><br><span class="line">        s=$s"\033[0m"</span><br><span class="line">        echo -n $s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">更新新的方块</span></span><br><span class="line">function RandomBox()</span><br><span class="line">&#123;</span><br><span class="line">        local i j t</span><br><span class="line"></span><br><span class="line">        #更新当前移动的方块</span><br><span class="line">        iBoxCurType=$&#123;iBoxNewType&#125;</span><br><span class="line">        iBoxCurRotate=$&#123;iBoxNewRotate&#125;</span><br><span class="line">        cBoxCur=$&#123;cBoxNew&#125;</span><br><span class="line">        for ((j = 0; j &lt; $&#123;#boxNew[@]&#125;; j++))</span><br><span class="line">        do</span><br><span class="line">                boxCur[$j]=$&#123;boxNew[$j]&#125;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #显示当前移动的方块</span><br><span class="line">        if (( $&#123;#boxCur[@]&#125; == 8 ))</span><br><span class="line">        then</span><br><span class="line">                #计算当前方块该从顶端哪一行"冒"出来</span><br><span class="line">                for ((j = 0, t = 4; j &lt; 8; j += 2))</span><br><span class="line">                do</span><br><span class="line">                        if (($&#123;boxCur[$j]&#125; &lt; t)); then t=$&#123;boxCur[$j]&#125;; fi</span><br><span class="line">                done</span><br><span class="line">                ((boxCurY = -t))</span><br><span class="line">                for ((j = 1, i = -4, t = 20; j &lt; 8; j += 2))</span><br><span class="line">                do</span><br><span class="line">                        if (($&#123;boxCur[$j]&#125; &gt; i)); then i=$&#123;boxCur[$j]&#125;; fi</span><br><span class="line">                        if (($&#123;boxCur[$j]&#125; &lt; t)); then t=$&#123;boxCur[$j]&#125;; fi</span><br><span class="line">                done</span><br><span class="line">                ((boxCurX = (iTrayWidth - 1 - i - t) / 2))</span><br><span class="line"></span><br><span class="line">                #显示当前移动的方块</span><br><span class="line">                echo -ne `DrawCurBox 1`</span><br><span class="line"></span><br><span class="line">                #如果方块一出来就没处放，Game over!</span><br><span class="line">                if ! BoxMove $boxCurY $boxCurX</span><br><span class="line">                then</span><br><span class="line">                        kill -$sigExit $&#123;PPID&#125;</span><br><span class="line">                        ShowExit</span><br><span class="line">                fi</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #清除右边预显示的方块</span><br><span class="line">        for ((j = 0; j &lt; 4; j++))</span><br><span class="line">        do</span><br><span class="line">                ((i = iTop + 1 + j))</span><br><span class="line">                ((t = iLeft + 2 * iTrayWidth + 7))</span><br><span class="line">                echo -ne "\033[$&#123;i&#125;;$&#123;t&#125;H        "</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        #随机产生新的方块</span><br><span class="line">        ((iBoxNewType = RANDOM % $&#123;#offsetBox[@]&#125;))</span><br><span class="line">        ((iBoxNewRotate = RANDOM % $&#123;countBox[$iBoxNewType]&#125;))</span><br><span class="line">        for ((j = 0, i = ($&#123;offsetBox[$iBoxNewType]&#125; + $iBoxNewRotate) * 8; j &lt; 8; j++, i++))</span><br><span class="line">        do</span><br><span class="line">                boxNew[$j]=$&#123;box[$i]&#125;;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        ((cBoxNew = $&#123;colorTable[RANDOM % $&#123;#colorTable[@]&#125;]&#125;))</span><br><span class="line"></span><br><span class="line">        #显示右边预显示的方块</span><br><span class="line">        echo -ne "\033[1m\033[7m\033[3$&#123;cBoxNew&#125;m\033[4$&#123;cBoxNew&#125;m"</span><br><span class="line">        for ((j = 0; j &lt; 8; j += 2))</span><br><span class="line">        do</span><br><span class="line">                ((i = iTop + 1 + $&#123;boxNew[$j]&#125;))</span><br><span class="line">                ((t = iLeft + 2 * iTrayWidth + 7 + 2 * $&#123;boxNew[$j + 1]&#125;))</span><br><span class="line">                echo -ne "\033[$&#123;i&#125;;$&#123;t&#125;H[]"</span><br><span class="line">        done</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">初始绘制</span></span><br><span class="line">function InitDraw()</span><br><span class="line">&#123;</span><br><span class="line">        clear</span><br><span class="line">        RandomBox        #随机产生方块，这时右边预显示窗口中有方快了</span><br><span class="line">        RandomBox        #再随机产生方块，右边预显示窗口中的方块被更新，原先的方块将开始下落</span><br><span class="line">        local i t1 t2 t3</span><br><span class="line"></span><br><span class="line">        #显示边框</span><br><span class="line">        echo -ne "\033[1m"</span><br><span class="line">        echo -ne "\033[3$&#123;cBorder&#125;m\033[4$&#123;cBorder&#125;m"</span><br><span class="line"></span><br><span class="line">        ((t2 = iLeft + 1))</span><br><span class="line">        ((t3 = iLeft + iTrayWidth * 2 + 3))</span><br><span class="line">        for ((i = 0; i &lt; iTrayHeight; i++))</span><br><span class="line">        do</span><br><span class="line">                ((t1 = i + iTop + 2))</span><br><span class="line">                echo -ne "\033[$&#123;t1&#125;;$&#123;t2&#125;H||"</span><br><span class="line">                echo -ne "\033[$&#123;t1&#125;;$&#123;t3&#125;H||"</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        ((t2 = iTop + iTrayHeight + 2))</span><br><span class="line">        for ((i = 0; i &lt; iTrayWidth + 2; i++))</span><br><span class="line">        do</span><br><span class="line">                ((t1 = i * 2 + iLeft + 1))</span><br><span class="line">                echo -ne "\033[$&#123;iTrayTop&#125;;$&#123;t1&#125;H=="</span><br><span class="line">                echo -ne "\033[$&#123;t2&#125;;$&#123;t1&#125;H=="</span><br><span class="line">        done</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        #显示"Score"和"Level"字样</span><br><span class="line">        echo -ne "\033[1m"</span><br><span class="line">        ((t1 = iLeft + iTrayWidth * 2 + 7))</span><br><span class="line">        ((t2 = iTop + 10))</span><br><span class="line">        echo -ne "\033[3$&#123;cScore&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;HScore"</span><br><span class="line">        ((t2 = iTop + 11))</span><br><span class="line">        echo -ne "\033[3$&#123;cScoreValue&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;H$&#123;iScore&#125;"</span><br><span class="line">        ((t2 = iTop + 13))</span><br><span class="line">        echo -ne "\033[3$&#123;cScore&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;HLevel"</span><br><span class="line">        ((t2 = iTop + 14))</span><br><span class="line">        echo -ne "\033[3$&#123;cScoreValue&#125;m\033[$&#123;t2&#125;;$&#123;t1&#125;H$&#123;iLevel&#125;"</span><br><span class="line">        echo -ne "\033[0m"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">退出时显示GameOVer!</span></span><br><span class="line">function ShowExit()</span><br><span class="line">&#123;</span><br><span class="line">        local y</span><br><span class="line">        ((y = iTrayHeight + iTrayTop + 3))</span><br><span class="line">        echo -e "\033[$&#123;y&#125;;0HGameOver!\033[0m"</span><br><span class="line">        exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示用法.</span></span><br><span class="line">function Usage</span><br><span class="line">&#123;</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">Usage: $APP_NAME</span><br><span class="line">Start tetris game.</span><br><span class="line"></span><br><span class="line">  -h, --help              display this help and exit</span><br><span class="line">      --version           output version information and exit</span><br><span class="line">EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">游戏主程序在这儿开始.</span></span><br><span class="line">if [[ "$1" == "-h" || "$1" == "--help" ]]; then</span><br><span class="line">        Usage</span><br><span class="line">elif [[ "$1" == "--version" ]]; then</span><br><span class="line">        echo "$APP_NAME $APP_VERSION"</span><br><span class="line">elif [[ "$1" == "--show" ]]; then</span><br><span class="line">        #当发现具有参数--show时，运行显示函数</span><br><span class="line">        RunAsDisplayer</span><br><span class="line">else</span><br><span class="line">        bash $0 --show&amp;        #以参数--show将本程序再运行一遍</span><br><span class="line">        RunAsKeyReceiver $!        #以上一行产生的进程的进程号作为参数</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p>给当前用户执行此文件的权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 ./Tetris.sh</span><br></pre></td></tr></table></figure><h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><p>有了执行此文件的权限之后，开始执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Tetris.sh</span><br></pre></td></tr></table></figure><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594896756.jpg" alt="1594896756"></p>]]></content>
    
    <summary type="html">
    
      俄罗斯方块的Shell脚本
    
    </summary>
    
    
    
      <category term="Shell" scheme="penghui.club/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>有逼格的希尔排序</title>
    <link href="penghui.club/2020/07/13/%E6%9C%89%E9%80%BC%E6%A0%BC%E7%9A%84%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>penghui.club/2020/07/13/%E6%9C%89%E9%80%BC%E6%A0%BC%E7%9A%84%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-12T23:42:30.000Z</published>
    <updated>2020-07-13T00:21:47.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>鲸落“当鲸鱼在海洋中死去，它的尸体会最终沉入海底。生物学家赋予这个过程一个名字——鲸落（Whale Fall）。一座鲸鱼的尸体可以供养整套生命系统长达百年，这是它留给大海最后的温柔。” </p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="有逼格的希尔排序"><a href="#有逼格的希尔排序" class="headerlink" title="有逼格的希尔排序"></a>有逼格的希尔排序</h2><p>希尔排序是一种基于插入排序的快速的排序算法。希尔排序为了加快速度简单的改进了插入排序，<span style="background-color: yellow; color: red;">交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</span></p><p>希尔排序的思想是使数组中任意<code>间隔为 h</code> 的元素都是有序的。这样的数组成为 <code>h</code> 有序数组。可以这么理解：一个<code>h</code> 有序数组就是<code>h</code> 个互相独立的有序数组编织在一起组成的一个数组。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/xier.jpg" alt="xier"></p><p>实现希尔排序的一种方法是对每一个<code>h</code>，用插入排序将<code>h</code>个子数组独立的排序。但因为子数组是相互独立的，一个更简单的方法是在<code>h-</code>子数组中将每一个元素交换到比它大的元素之前。只需要在插入排序的代码中将移动元素的距离由<code>1</code>改为<code>h</code>即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> ind1, <span class="keyword">int</span> ind2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a[ind1]; a[ind1] = a[ind2]; a[ind2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;鲸落“当鲸鱼在海洋中死去，它的尸体会最终沉入海底。生物学家赋予这个过程一个名字——鲸落（Whale Fall）。一座鲸鱼的尸体可以供养整套生命系统长达百年，这是它留给大海最后的温柔。” &lt;/p&gt;
&lt;p&gt;​                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="penghui.club/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>地下城游戏</title>
    <link href="penghui.club/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/"/>
    <id>penghui.club/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</id>
    <published>2020-07-11T23:30:47.000Z</published>
    <updated>2020-07-12T00:04:03.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>我尚未遇见更好的，只好愿我惦念之人岁岁平安</p><p>​                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h2 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a></h2><p>又是 7 月的每日一题，一看题目就是典型的<code>dp</code>。一般<code>难度</code>吧<del>~</del>(让我装个逼d=====(￣▽￣*)b)。</p><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只<strong>向右</strong>或<strong>向下</strong>移动一步。</p><p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><table><thead><tr><th>-2 (K)</th><th>-3</th><th>3</th></tr></thead><tbody><tr><td>-5</td><td>-10</td><td>1</td></tr><tr><td>10</td><td>30</td><td>-5 (P)</td></tr></tbody></table><p>说明:</p><ul><li><p>骑士的健康点数没有上限。</p></li><li><p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p></li></ul><p>接下来我们就讲讲如何<span style="color: red;background-color: yellow;">英雄救美:</span></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先我们可以看出这是道动态规划问题，在我认为：动态规划就是在<strong>穷举</strong>了所有情况的时候加了个<strong>备忘录</strong>，即有状态的记录每一步的结果，当一步的值取决于我们已求出的结果。</p><h5 id="定义dp："><a href="#定义dp：" class="headerlink" title="定义dp："></a>定义dp：</h5><p>我们定义一个二维数组 <code>dp[m + 1][n + 1]</code>; 则<code>dp[j][j]</code>就表示我们移动到坐标<code>[i][j]</code>的位置时，需要的最少血量。</p><p>题目上说了，骑士每次只<strong>向右</strong>或<strong>向下</strong>移动一步。那么当前状态就和<code>右边的状态</code>和<code>下面的状态</code>有关。所以我们应逆向来搜索（即从<strong>公主的位置—&gt;&gt;骑士的位置</strong>），这不变成了<span style="color: red;background-color: yellow;">美救英雄</span>了吗？</p><p>那么状态转移方式怎么得出？接下来就分情况而定：</p><p>题目给出的坐标数组是：<code>int[][] dungeon</code>;</p><p>当<code>dungeon[i][j] &gt;= dp[i + 1][j] || dungeon[i][j] &gt;= dp[i][j + 1]</code>的时候，我们只需要将<code>dp[i][j] = 1</code>即可，为什么呢？因为我们不论是要走到右边还是下边，当前的血量已经充足够用了，只需要 <code>1</code>点血量走到<code>dungeon[i][j]</code>位置即可。并且无需做其他判断，因为 <code>1</code>是最低血量了。</p><p>其它情况：当前<code>dp[i + 1][j]</code>就和右边状态、下边状态有关了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j] - dungeon[i][j], dp[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br></pre></td></tr></table></figure><h4 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">    <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i --) dp[i][n] = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">0</span>; j --) dp[m][j] = <span class="number">1000000</span>;</span><br><span class="line">    dp[m - <span class="number">1</span>][n] = <span class="number">1</span>; dp[m][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dungeon[i][j] &gt;= dp[i + <span class="number">1</span>][j] || dungeon[i][j] &gt;= dp[i][j + <span class="number">1</span>]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = Math.min(dp[i + <span class="number">1</span>][j] - dungeon[i][j], dp[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      地下城游戏
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="penghui.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>spring相关知识点</title>
    <link href="penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>penghui.club/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-07-06T10:22:17.000Z</published>
    <updated>2020-07-08T07:06:35.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。</p><p>​                                                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h3 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h3><h4 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h4><ul><li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li><li>它是轻量级、松散耦合的。</li><li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li><li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li></ul><h4 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h4><ul><li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li><li>OC - 控制反转</li><li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h4 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h4><p>​        Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。</p><h3 id="依赖注入（IOC）"><a href="#依赖注入（IOC）" class="headerlink" title="依赖注入（IOC）"></a>依赖注入（IOC）</h3><h4 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h4><p>​        Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p><h4 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h4><p>​        在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p><h4 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h4><p>通常，依赖注入可以通过三种方式完成，即：</p><ul><li>构造函数注入</li><li>setter 注入</li><li>接口注入</li></ul><h4 id="区分构造函数注入和-setter-注入。"><a href="#区分构造函数注入和-setter-注入。" class="headerlink" title="区分构造函数注入和 setter 注入。"></a>区分构造函数注入和 setter 注入。</h4><table><thead><tr><th align="left">构造函数注入</th><th align="left">setter 注入</th></tr></thead><tbody><tr><td align="left">任意修改都会创建一个新实例</td><td align="left">任意修改不会创建一个新实例</td></tr><tr><td align="left">适用于设置很多属性</td><td align="left">适用于设置少量属性</td></tr></tbody></table><h4 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h4><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h4 id="区分-BeanFactory-和-ApplicationContext。"><a href="#区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="区分 BeanFactory 和 ApplicationContext。"></a>区分 BeanFactory 和 ApplicationContext。</h4><table><thead><tr><th>BeanFactory</th><th>ApplicationContext</th></tr></thead><tbody><tr><td>它使用懒加载</td><td>它使用即时加载</td></tr><tr><td>它使用语法显式提供资源对象</td><td>它自己创建和管理资源对象</td></tr><tr><td>不支持国际化</td><td>支持国际化</td></tr><tr><td>不支持基于依赖的注解</td><td>支持基于依赖的注解</td></tr></tbody></table><h4 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h4><p>​        Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射机制</strong>。</p><h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h3><h4 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h4><h5 id="1、基于-xml-配置"><a href="#1、基于-xml-配置" class="headerlink" title="1、基于 xml 配置"></a>1、基于 xml 配置</h5><p>​        bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentbean"</span> <span class="attr">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Edureka"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、基于注解配置"><a href="#2、基于注解配置" class="headerlink" title="2、基于注解配置"></a>2、基于注解配置</h5><p>​        您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、基于-Java-API-配置"><a href="#3、基于-Java-API-配置" class="headerlink" title="3、基于 Java API 配置"></a>3、基于 Java API 配置</h5><p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p><ol><li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h4><p> Spring bean 支持 5 种 scope： </p><ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。</li></ul><p>常用的有<code>Singleton</code>、<code>Prototype</code>。 仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。 </p><h4 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h4><p>spring bean 容器的生命周期流程如下：</p><ol><li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 <code>BeanNameAware</code> 接口，则工厂通过传递 bean 的 ID 来调用 <code>setBeanName()</code>。</li><li>如果 bean 实现 <code>BeanFactoryAware</code> 接口，工厂通过传递自身的实例来调用 <code>setBeanFactory()</code>。</li><li>如果为 bean 指定了 <code>init</code> 方法（<bean> 的 <code>init-method</code> 属性），那么将调用它。</li><li>如果存在与 bean 关联的任何 <code>BeanPostProcessors</code>，则调用 <code>postProcessBeforeInitialization()</code> 方法。</li><li>如果存在与 bean 关联的任何 <code>BeanPostProcessors</code>，则将调用 <code>postProcessAfterInitialization()</code> 方法。</li><li>如果 bean 实现 <code>DisposableBean</code> 接口，当 spring 容器关闭时，会调用 <code>destory()</code>。</li><li>如果为 bean 指定了 <code>destroy</code> 方法（<bean> 的 <code>destroy-method</code> 属性），spring 容器关闭时，那么将调用它。</li></ol><h4 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h4><p>​        当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p><h4 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h4><p>​        Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p><p>自动装配的不同模式：</p><ol><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ol><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h4><p>​        不使用 XML 来描述 bean 装配，开发人员通过在相关的类，<strong>方法或字段</strong>声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p><p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p><ul><li><code>@Bean</code> 注解扮演与 元素相同的角色。</li><li><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul><p><em>可以这么来说，当一个类使用 <code>@Configuration</code> 注解标注时，那么该类相当于一个 spring的 xml 配置文件</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h4><p>​        默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p><h4 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h4><ul><li><strong>@Component</strong>：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li><strong>@Controller</strong>：这将一个类标记为 <code>Spring Web MVC</code> 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li><strong>@Service</strong>：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 <code>@Service</code> 而不是 <code>@Component</code>，因为它以更好的方式指定了意图。</li><li><strong>@Repository</strong>：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h4 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h4><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是<span style="background-color: yellow;color: red;">类型驱动</span>的注入。</p><h4 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h4><p><code>@RequestMapping</code> 注解用于将特定 HTTP 请求方法映射到将处理相应请求的<strong>控制器</strong>中的<strong>特定类/方法</strong>。此注释可应用于两个级别：</p><ul><li>类级别（注解标注在类上）：映射请求的 URL</li><li>方法级别（注解标注在方法上）：映射 URL 以及 HTTP 请求方法</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是-AOP？"><a href="#什么是-AOP？" class="headerlink" title="什么是 AOP？"></a>什么是 AOP？</h4><p> AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong> </p><h4 id="什么是-Aspect？"><a href="#什么是-Aspect？" class="headerlink" title="什么是 Aspect？"></a>什么是 Aspect？</h4><p>​        <code>aspect</code> 由 <code>Pointcut</code> 和 <code>Advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</p><p> <strong>可以简单地认为, 使用 @Aspect 注解的类就是一个切面.</strong> </p><h4 id="什么是切点（JoinPoint）"><a href="#什么是切点（JoinPoint）" class="headerlink" title="什么是切点（JoinPoint）"></a>什么是切点（JoinPoint）</h4><p>​        程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理，在 Spring AOP 中, <code>join point</code> 就是方法的执行点。</p><h4 id="什么是通知（Advice）？"><a href="#什么是通知（Advice）？" class="headerlink" title="什么是通知（Advice）？"></a>什么是通知（Advice）？</h4><p>​        特定 <code>JoinPoint</code> 处的 <code>Aspect</code> 所采取的动作称为 <code>Advice</code>。Spring AOP 使用一个 <code>Advice</code> 作为拦截器，在 <code>JoinPoint</code> “周围”维护一系列的拦截器。</p><h4 id="有哪些类型的通知（Advice）？"><a href="#有哪些类型的通知（Advice）？" class="headerlink" title="有哪些类型的通知（Advice）？"></a>有哪些类型的通知（Advice）？</h4><ul><li><strong>Before</strong> - 这些类型的 <code>Advice</code> 在 <code>joinpoint</code> 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li><li><strong>After Returning</strong> - 这些类型的 <code>Advice</code> 在连接点方法正常执行后执行，并使用<code>@AfterReturning</code> 注解标记进行配置。</li><li><strong>After Throwing</strong> - 这些类型的 <code>Advice</code> 仅在 <code>joinpoint</code> 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li><li><strong>After (finally)</strong> - 这些类型的 <code>Advice</code> 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li><li><strong>Around</strong> - 这些类型的 <code>Advice</code> 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li></ul><h4 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h4><p>实现 AOP 的技术，主要分为两大类：</p><ul><li><strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为<strong>编译时增强</strong>；<ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li><strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为<strong>运行时增强</strong>。<ul><li>JDK 动态代理</li><li>CGLIB</li></ul></li></ul><h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h4><p>​        Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p><h4 id="Spring-MVC-工作流程"><a href="#Spring-MVC-工作流程" class="headerlink" title="Spring MVC 工作流程"></a>Spring MVC 工作流程</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1159443997.jpg" alt="1159443997"></p><p>1、用户发送请求至前端控制器<code>DispatcherServlet</code>。</p><p>2、<code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code><strong>处理器映射器。</strong></p><p>3、<strong>处理器映射器</strong>找到具体的处理器(可以根据<strong>xml</strong>配置或者<strong>注解</strong>进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给<code>DispatcherServlet</code>。</p><p>4、 <code>DispatcherServlet</code>调用<code>HandlerAdapter</code><strong>处理器适配器。</strong></p><p>5、<code>HandlerAdapter</code>经过适配调用具体的处理器(<code>Controller</code>，也叫<strong>后端控制器</strong>)。</p><p>6、<code>Controller</code>执行完成返回<code>ModelAndView</code>。</p><p>7、<code>HandlerAdapter</code>将<code>controller</code>执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code>。</p><p>8、<code>DispatcherServlet</code>将<code>ModelAndView</code>传给<code>ViewReslover</code><strong>视图解析器</strong>。</p><p>9、<code>ViewReslove</code>r解析后返回具体<strong>View</strong>。</p><p>10、<code>DispatcherServlet</code>根据<strong>View</strong>进行渲染视图（即将模型数据填充至视图中）。 </p><p>11、<code>DispatcherServlet</code>响应用户。</p><h4 id="描述一下-DispatcherServlet-的工作流程"><a href="#描述一下-DispatcherServlet-的工作流程" class="headerlink" title="描述一下 DispatcherServlet 的工作流程"></a>描述一下 DispatcherServlet 的工作流程</h4><ol><li>向服务器发送 HTTP 请求，请求被前端控制器 <code>DispatcherServlet</code> 捕获。</li><li><code>DispatcherServlet</code> 根据 <code>servlet.xml</code> 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 <code>HandlerMapping</code> 获得该 <code>Handler</code> 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以<code>HandlerExecutionChain</code> 对象的形式返回。</li><li><code>DispatcherServlet</code> 根据获得的<code>Handler</code>，选择一个合适的 <code>HandlerAdapter</code>。（附注：如果成功获得<code>HandlerAdapter</code>后，此时将开始执行拦截器的 <code>preHandler(...)</code>方法）。</li><li>提取<code>Request</code>中的模型数据，填充<code>Handler</code>入参，开始执行<code>Handler（Controller)</code>。 在填充<code>Handler</code>的入参过程中，根据你的配置，<code>Spring</code> 将帮你做一些额外的工作：<ol><li><code>HttpMessageConveter</code>： 将请求消息（如 <code>Json、xml</code> 等数据）转换成一个对象，将对象转换为指定的响应信息。</li><li>数据转换：对请求消息进行数据转换。如<code>String</code>转换成<code>Integer、Double</code>等。</li><li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</li></ol></li><li><code>Handler(Controller)</code>执行完成后，向 <code>DispatcherServlet</code> 返回一个 <code>ModelAndView</code> 对象；</li><li>根据返回的<code>ModelAndView</code>，选择一个适合的 <code>ViewResolver</code>（必须是已经注册到 Spring 容器中的<code>ViewResolver</code>)返回给<code>DispatcherServlet</code>。</li><li><code>ViewResolver</code> 结合<code>Model</code>和<code>View</code>，来渲染视图。</li><li>视图负责将渲染结果返回给客户端。</li></ol><p>原文链接：<a href="https://blog.csdn.net/qq_41701956/article/details/81389067" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81389067</a></p><p>部分内容原文链接：<a href="https://blog.csdn.net/floating_dreaming/article/details/89089214" target="_blank" rel="noopener">https://blog.csdn.net/floating_dreaming/article/details/89089214</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。&lt;/p&gt;
&lt;p&gt;​                                                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="spring" scheme="penghui.club/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>NIO之缓冲区的使用</title>
    <link href="penghui.club/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>penghui.club/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-06T08:17:56.000Z</published>
    <updated>2020-07-07T10:48:21.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>女人错过了她最想嫁的那个男人，就会变得挑剔；男人错过了那个他最想娶的女人，就会变得随意 那时候陪伴我的那个，这里的故事你是否还记得 </p><p>​                                                                                                       —– 网易云热评</p></blockquote><h2 id="NIO之缓冲区的使用"><a href="#NIO之缓冲区的使用" class="headerlink" title="NIO之缓冲区的使用"></a>NIO之缓冲区的使用</h2><p>今年寒假前，在学校图书馆里借了一本关于NIO的书，花了几天时间看完了，但是由于之前没有创建个人博客，所以今天重温一下做个笔记😁。</p><hr><h3 id="首先了解什么是NIO？"><a href="#首先了解什么是NIO？" class="headerlink" title="首先了解什么是NIO？"></a>首先了解什么是NIO？</h3><p>​        常规的 I/O （如InputStream 和 OutputStream）存在很大缺点，就是它们是阻塞的，而<code>NIO</code>解决的就是常规 I/O执行效率低的问题。即采用非阻塞高性能运行的方式来避免出现以前 “笨拙” 的同步 I/O带来的低效率问题。 <code>NIO</code>对常规的 I/O 使用的 byte[] 或 char[] 进行封装，采用 ByteBuffer 类来操作数据，再结合针对 File 或 Socket 技术的 Channel ，采用同步非阻塞技术实现高性能处理。</p><p>​        Buffer 类的信息如下：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594024381559.png" alt="1594024381559"></p><p>​        可以发现 Buffer 是个抽象类，那么它必定有子类，分别是：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594024436930.png" alt="1594024436930"></p><p>​        NIO 中Buffer是一个用于存储基本数据类型值的容器，它以类似于数组有序的方式来存储和组织数据。每个基本数据类型（除去 boolean）都有一个子类与之对应。</p><h3 id="Buffer-类的使用"><a href="#Buffer-类的使用" class="headerlink" title="Buffer 类的使用"></a>Buffer 类的使用</h3><p>​        观察上图，我们可以发现，Buffer 是个抽象类，并不能直接实例化，但是我们会发现，即使它的子类也都是抽象类，同样不可以直接实例化。那么我们该如何创建这些类的对象呢？使用方式是将上面 7 种数据类型的数组包装（wrap）进缓冲区，此时需要借助静态方法 <code>wrap()</code>进行实现。<code>wrap()</code>方法的作用是将数组放入缓冲区，来构建存储不同的数据类型缓冲区。以下以 CharBuffer 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CharBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">char</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>缓冲区为非线程安全的。</em></p><p>​        那么这个缓冲区的实例到底是由哪个类实现的呢？我们点进<code>wrap</code>方法进去看个究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CharBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapCharBuffer(array, offset, length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 具体的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapCharBuffer</span> <span class="keyword">extends</span> <span class="title">CharBuffer</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line">HeapCharBuffer(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123; <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        hb = buf;</span></span><br><span class="line"><span class="comment">        offset = 0;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super(-1, off, off + len, buf.length, buf, 0); </span></span><br><span class="line">CharBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap,   <span class="comment">// package-private</span></span><br><span class="line">                            <span class="keyword">char</span>[] hb, <span class="keyword">int</span> offset)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">    <span class="keyword">this</span>.hb = hb;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <strong>原来，<code>CharBuffer</code>是由 <code>HeapCharBuffer</code> 来具体实现的。</strong></p><h3 id="NIO技术的缓冲区的相关方法"><a href="#NIO技术的缓冲区的相关方法" class="headerlink" title="NIO技术的缓冲区的相关方法"></a>NIO技术的缓冲区的相关方法</h3><h4 id="包装数据与获得容量"><a href="#包装数据与获得容量" class="headerlink" title="包装数据与获得容量"></a>包装数据与获得容量</h4><h5 id="capacity（容量）"><a href="#capacity（容量）" class="headerlink" title="capacity（容量）"></a>capacity（容量）</h5><p>​        它代表包含元素的数量。不可是负值，不可被修改。</p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"><span class="keyword">int</span> cap = charbuffer.capacity();</span><br><span class="line">System.out.println(cap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： 3</span></span><br></pre></td></tr></table></figure><h4 id="限制获取与设置"><a href="#限制获取与设置" class="headerlink" title="限制获取与设置"></a>限制获取与设置</h4><h5 id="limit（限制）"><a href="#limit（限制）" class="headerlink" title="limit（限制）"></a>limit（限制）</h5><p>​        返回此缓冲区的限制。什么是缓冲区的限制呢？它代表第一个不应该读取或写入元素的 index（索引）。不可以是负值，并且其值不能大于<code>capacity</code>。如果<code>position</code> 大于新的 <code>limit</code>，则奖<code>position</code>设置为新的<code>limit</code>。如果<code>mark</code>已定义且大于新的<code>limit</code>，则丢弃该<code>mark</code>。<code>limit</code>的应用示例如图所示：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594026005008.jpg" alt="1594026005008"></p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"><span class="keyword">int</span> limit = charbuffer.limit();</span><br><span class="line">System.out.println(<span class="string">"修改前"</span> + limit);</span><br><span class="line"></span><br><span class="line">charbuffer.limit(<span class="number">3</span>);</span><br><span class="line">limit = charbuffer.limit();</span><br><span class="line">System.out.println(<span class="string">"修改后"</span> + limit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// put(索引，数据)</span></span><br><span class="line">charbuffer.put(<span class="number">3</span>, <span class="string">'q'</span>);<span class="comment">// 此位置是第一个不可读不可写的索引,会抛出IndexOutOfBoundException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： </span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IndexOutOfBoundException</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="位置获取与设置"><a href="#位置获取与设置" class="headerlink" title="位置获取与设置"></a>位置获取与设置</h4><h5 id="position（位置）"><a href="#position（位置）" class="headerlink" title="position（位置）"></a>position（位置）</h5><p>​        代表 “下一个” 要读取或写入元素的索引，<code>position</code>不能为负值，并且<code>position</code>不能大于其<code>limit</code>。如果<code>mark</code>已定义且大于新的<code>position</code>，则丢弃该<code>mark</code>。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594026689661.jpg" alt="1594026689661"></p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">// position 默认刚开始为 0</span></span><br><span class="line"><span class="keyword">int</span> position = charbuffer.position();</span><br><span class="line">System.out.println(<span class="string">"修改前: "</span> + position);</span><br><span class="line"></span><br><span class="line">charbuffer.position(<span class="number">3</span>);</span><br><span class="line">position = charbuffer.position();</span><br><span class="line">System.out.println(<span class="string">"修改后: "</span> + position);</span><br><span class="line"></span><br><span class="line">charbuffer.put(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i ++) </span><br><span class="line">    System.out.print(chars[i] + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： </span></span><br><span class="line">修改前: <span class="number">0</span></span><br><span class="line">修改后: <span class="number">3</span></span><br><span class="line">a b c q e</span><br></pre></td></tr></table></figure><h4 id="剩余空间大小获取"><a href="#剩余空间大小获取" class="headerlink" title="剩余空间大小获取"></a>剩余空间大小获取</h4><h5 id="remaining（剩余空间）"><a href="#remaining（剩余空间）" class="headerlink" title="remaining（剩余空间）"></a>remaining（剩余空间）</h5><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    return limit - position</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594027234062.jpg" alt="1594027234062"></p><p>上图：limit - position 会返回 2。</p><h4 id="设置标记："><a href="#设置标记：" class="headerlink" title="设置标记："></a><strong>设置标记：</strong></h4><h5 id="mark（标记）"><a href="#mark（标记）" class="headerlink" title="mark（标记）"></a>mark（标记）</h5><p>​        在此缓冲区的位置设置标记。</p><p>​        标记是一个索引，当我们调用<code>reset()</code>方法时，会将缓冲区的<code>position</code>位置重置为该索引。标记并不是必须的，同样不能是负数，并且不能让它大于<code>position</code>。如果定义<code>mark</code>，则再将<code>position</code>或<code>limit</code>调整为小于该<code>mark</code>的值时，该<code>mark</code>被丢弃，丢弃后其值为 -1。如果未定义<code>mark</code>，那么调用<code>reset()</code>方法将导致抛出<code>InvalidMarkException</code>异常。</p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="还原缓冲区的状态："><a href="#还原缓冲区的状态：" class="headerlink" title="还原缓冲区的状态："></a>还原缓冲区的状态：</h4><h5 id="clear（清除）"><a href="#clear（清除）" class="headerlink" title="clear（清除）"></a>clear（清除）</h5><p>​        还原缓冲区到初始的状态，包含将位置设置为 0 ，将限制（limit）设置为容量（capacity），并丢弃标记（mark），即 “一切为默认”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主要应用场景："><a href="#主要应用场景：" class="headerlink" title="主要应用场景："></a>主要应用场景：</h5><p><strong>对缓冲区存储数据之前调用此方法。</strong></p><h4 id="对缓冲区进行反转："><a href="#对缓冲区进行反转：" class="headerlink" title="对缓冲区进行反转："></a>对缓冲区进行反转：</h4><h5 id="flip（反转）"><a href="#flip（反转）" class="headerlink" title="flip（反转）"></a>flip（反转）</h5><p>​        反转此缓冲区。首先将限制设置为当前位置，然后将位置设置为 0 。丢弃标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注意此方法会修改 limit 为 当前 position的值。</em></p><h5 id="主要应用场景：-1"><a href="#主要应用场景：-1" class="headerlink" title="主要应用场景："></a>主要应用场景：</h5><p><strong>当向缓冲区中存储数据，然后再从缓冲区中读取这些数据时，就是使用 flip() 方法的最佳时机。</strong></p><h4 id="重绕缓冲区"><a href="#重绕缓冲区" class="headerlink" title="重绕缓冲区"></a>重绕缓冲区</h4><h5 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h5><p>​        重绕此缓冲区，将位置设置为 0 并丢弃标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="主要应用场景：-2"><a href="#主要应用场景：-2" class="headerlink" title="主要应用场景："></a>主要应用场景：</h5><p><strong>“重新写入或获取” 的操作之前调用此方法（假定已经设当设置了限制）。常在重新读取缓冲区中数据时使用。</strong></p><h3 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h3><ol><li>缓冲区的<code>capacity</code>、<code>limit</code>、<code>position</code>都不能是负数。</li><li><code>position</code>不能大于<code>limit</code>。</li><li><code>limit</code>不能大于capacity。</li><li>如果定义<code>mark</code>，在将<code>position</code>或<code>limit</code>调整为小于该<code>mark</code>的值时，该<code>mark</code>被丢弃。</li><li>未定义<code>mark</code>，调用<code>reset()</code>方法将导致抛出<code>InvalidMarkException</code>异常。</li><li>当<code>limit</code>和<code>position</code>值一样时，在指定的<code>position</code>位置写入数据会出现异常。</li></ol><p>喜欢本文的话，<strong>在评论区留个言吧😘</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="NIO" scheme="penghui.club/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>通配符匹配</title>
    <link href="penghui.club/2020/07/05/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    <id>penghui.club/2020/07/05/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</id>
    <published>2020-07-05T06:15:53.000Z</published>
    <updated>2020-07-05T08:29:13.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>到了二十多岁的年纪，我终于承认我真的很平庸，我会更加努力！加油！！！</p><p>​                                                                                                                               —– Halo</p></blockquote><a id="more"></a><h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></h2><p>今天是2020年7月5日，我仍在努力…</p><p>这道题是leetcode每日一题，典型的动态规划问题。虽说难度为<span style="color: red;">困难</span>，但是并不是很难。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;?&#39; 可以匹配任何单个字符。</span><br><span class="line">&#39;*&#39; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a><strong>说明:</strong></h3><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#39;*&#39; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</span><br></pre></td></tr></table></figure><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a><strong>示例 4:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a><strong>示例 5:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h3><p>这道题我本来想着先用递归来解，通过双指针法，不断递归，可惜超时。。。思路如下：</p><p>当 <code>s[i] == p[j]  || p[j] == &#39;?&#39;</code>，进行<code>helper(s, i + 1, p, j + 1);</code> </p><p>当 <code>p[j] == &#39;*&#39;</code>, 进行 <code>helper(s, i + 1, p, j) || helper(s, i + 1, p, j + 1) || helper(s, i, p, j + 1)</code>;</p><p>至于为什么这样做，接下来动态规划的思路会讲解。这里只提供大概得思路，时间复杂度是很高的，不建议使用此方法。</p><h4 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h4><ul><li>首先定义<strong>dp</strong>数组的含义：<code>dp[i][j]</code> 表示字符串 <strong>s</strong> 的前 i 个字符和字符串 <strong>p</strong> 的前 j 个字符是否匹配</li><li>接下来就按照情况划分：<ul><li>1、p[j] 和s[i] 相等；</li><li>2、p[j] = ‘?’；</li><li>3、p[j] = ‘*’；</li></ul></li><li><strong>1和2</strong>：可合为一种 <ul><li>只要<code>dp[i - 1][j - 1]</code>匹配，那么我们可以得出只要<code>p[j]</code> 和<code>s[i]</code> 相等或者<code>[j] = &#39;?&#39;</code>；那么 我们就能 <code>dp[i][j] = dp[i - 1][j - 1]</code>; </li></ul></li><li><strong>3</strong>：当p[j] = ‘*’，分为三种情况，只要这三种情况任意一个为true，那么<code>dp[i][j]</code>就为true：<ul><li>表示一个字符：<code>dp[i][j] = dp[i - 1][j - 1]</code>;</li><li>表示空：<code>dp[i][j] = dp[i][j - 1]</code>;</li><li>表示多个字符：<code>dp[i][j] = dp[i - 1][j]</code>;</li></ul></li></ul><p>这里我们可以使用一个小技巧，在<strong>s 和 p</strong>最前面拼接一个“ ”字符串，既可以防止为空，也可以为接下来的代码做准备：</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    s = <span class="string">" "</span> + s;</span><br><span class="line">    p = <span class="string">" "</span> + p;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> sLen = s.length(), pLen = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen + <span class="number">1</span>][pLen + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sLen; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再看看递归的做法，是不是恍然大悟了呢？😱</strong></p>]]></content>
    
    <summary type="html">
    
      通配符匹配
    
    </summary>
    
    
    
      <category term="算法" scheme="penghui.club/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="penghui.club/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Object解读</title>
    <link href="penghui.club/2020/07/03/Object%E8%A7%A3%E8%AF%BB/"/>
    <id>penghui.club/2020/07/03/Object%E8%A7%A3%E8%AF%BB/</id>
    <published>2020-07-03T09:48:04.000Z</published>
    <updated>2020-07-10T12:22:14.822Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>加油吧！</p><p>​                                                                                                                                                   —– me   </p></blockquote><a id="more"></a><h2 id="Object概述"><a href="#Object概述" class="headerlink" title="Object概述"></a>Object概述</h2><p>Object类位于java.lang包， Java中的每个类都是由这个类扩展而来，所有类都<strong>直接</strong>或者<strong>间接</strong>的<strong>继承</strong>自Object。 所以，所有类都继承了Object中的方法。首先来看看Object中都有那些方法吧！</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593774455032.jpg" alt="1593774455032.jpg"></p><p>随便挑选一个类，就会发现他也有这些个方法：</p><p>这是自己写的类</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593770525068.jpg" alt="1593770525068"></p><p>以下是它的方法：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593770564796.jpg" alt="1593770564796"></p><h3 id="Object中的构造方法"><a href="#Object中的构造方法" class="headerlink" title="Object中的构造方法"></a>Object中的构造方法</h3><p>​        有过java基础的同学都知道，java中如果没有有参的构造方法，那么该类会默认有一个无参的构造方法。</p><p> 所以Object类中具有默认的无参构造<code>Object()</code> 。 </p><h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a><strong>源码：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>方法描述第一行：<strong>返回这个对象的hashcode， 支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。</strong> </p><p>我们来运行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：21685669</span></span><br></pre></td></tr></table></figure><p>该方法把对象的地址值换算成一个整数值，当两个对象不是同一对象，其地址值不同，哈希码值也不一样。 </p><p><em>注意：不同对象的hashcode有可能相同！同一个对象的hashcode一定相同！</em></p><p>当然你可以重写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无论如何打印类对象的hashcode，都是1</span></span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>同一个对象(如果该对象没有被修改)：那么重复调用<code>hashCode()</code>那么返回的int是相同的！ </li><li><code>hashCode()</code>方法默认是由对象的地址转换而来的 </li></ul><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates whether some other object is "equal to" this one.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>返回某个对象是否与此对象“相等”。也就是比较两个对象的地址值是否相等，是否为同一对象。如果相等则返回true，不相等则返回false。 </p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        ObjectTest obj2 = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        <span class="keyword">int</span> hashCode2 = obj2.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">        System.out.println(hashCode2);</span><br><span class="line">        System.out.println(<span class="string">"obj: "</span> + obj);</span><br><span class="line">        System.out.println(<span class="string">"obj2: "</span> + obj2);</span><br><span class="line">        System.out.println(obj.equals(obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line">hashcode:  <span class="number">21685669</span></span><br><span class="line">hashcode2: <span class="number">19997786</span></span><br><span class="line">obj:  niuke.offer.ObjectTest@<span class="number">14</span>ae5a5</span><br><span class="line">obj2: niuke.offer.ObjectTest@<span class="number">131245</span>a</span><br><span class="line">对象是否相等：<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul><li>只有两个对象的地址相同，那么这两个对象才相等。当我们需要重写<code>equals()</code>方法时，<strong>必须重写hashCode()</strong>方法。</li><li><code>equals()</code>方法默认是比较对象的地址，使用的是<code>==</code>等值运算符 </li><li><code>equals()</code>方法还有5个默认的原则：<ul><li>自反性：调用<code>equals()</code>返回的是true，无论这两个对象谁调用<code>equals()</code>都好，返回的都是true 。</li><li>一致性：只要对象没有被修改，那么多次调用还是返回对应的结果！ </li><li>传递性：<code>x.equals(y)</code>和<code>y.equals(z)</code>都返回true，那么可以得出：<code>x.equals(z)</code>返回true 。</li><li>对称性：<code>x.equals(y)</code>和<code>y.equals(x)</code>结果应该是相等的。 </li><li>传入的参数为null，返回的是false </li></ul></li></ul><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><p>我们常用的String已经实现了<code>equals</code>和<code>hashCode</code>方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 地址相等那么两者对象肯定相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断两者长度，相等的话继续判断它们的值</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 发现两字符串值不相等</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 继续判断</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两者值相同返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a string representation of the object. </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p> 返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串表达式。 </p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">System.out.println(obj.toString());</span><br><span class="line"><span class="comment">// 输出：niuke.offer.ObjectTest@14ae5a5</span></span><br><span class="line"><span class="comment">// 类名@对象哈希码的无符号十六进制</span></span><br></pre></td></tr></table></figure><p>通常我们并不会需要用着这种字符串的情况，一般需要重写该方法打印该对象的一些具体信息。</p><h3 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h3><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 拷贝的对象和原对象的引用一般不相同</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 拷贝对象和原对象调用equals一般相等</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 因此往往其成员变量（如果是可变的引用）都需要拷贝一份出去（实现完全独立）</span></span><br><span class="line"><span class="comment"> * Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * 该对象没有实现Cloneable接口会抛出CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. </span></span><br><span class="line"><span class="comment"> * 字段本身不克隆称为`浅克隆`</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a "shallow copy" of this object, not a "deep copy" operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 由于Object没有实现Cloneable接口，如果在Object上调用clone方法一样会抛出异常</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><ul><li>clone方法用于对象的克隆，一般想要克隆出的对象是<strong>独立</strong>的(与原有的对象是分开的) </li><li>深拷贝指的是该对象的成员变量(如果是可变引用)都应该克隆一份，浅拷贝指的是成员变量没有被克隆一份 </li></ul><h3 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h3><h4 id="源码：-4"><a href="#源码：-4" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用wait方法会让线程处于等待状态。直到调用唤醒方法notify或者指定的时间已过</span></span><br><span class="line"><span class="comment"> * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment"> * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The current thread must own this object's monitor.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to</span></span><br><span class="line"><span class="comment"> * 处于等待状态，锁会被释放</span></span><br><span class="line"><span class="comment"> * place itself in the wait set for this object and then to relinquish</span></span><br><span class="line"><span class="comment"> * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt;</span></span><br><span class="line"><span class="comment"> * becomes disabled for thread scheduling purposes and lies dormant</span></span><br><span class="line"><span class="comment"> * until one of four things happens:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 当线程等待时间结束，会回到就绪状态。再次抢到cpu资源时，同步状态与之前调用wait方法</span></span><br><span class="line"><span class="comment"> * 时是一致的！</span></span><br><span class="line"><span class="comment"> * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this</span></span><br><span class="line"><span class="comment"> * object and re-enabled for thread scheduling. It then competes in the</span></span><br><span class="line"><span class="comment"> * usual manner with other threads for the right to synchronize on the</span></span><br><span class="line"><span class="comment"> * object; once it has gained control of the object, all its</span></span><br><span class="line"><span class="comment"> * synchronization claims on the object are restored to the status quo</span></span><br><span class="line"><span class="comment"> * ante - that is, to the situation as of the time that the &#123;<span class="doctag">@code</span> wait&#125;</span></span><br><span class="line"><span class="comment"> * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the</span></span><br><span class="line"><span class="comment"> * invocation of the &#123;<span class="doctag">@code</span> wait&#125; method. Thus, on return from the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; method, the synchronization state of the object and of</span></span><br><span class="line"><span class="comment"> * thread &#123;<span class="doctag">@code</span> T&#125; is exactly as it was when the &#123;<span class="doctag">@code</span> wait&#125; method</span></span><br><span class="line"><span class="comment"> * was invoked.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 调用wait的线程，如果线程中断会抛出InterruptedException（结束等待状态）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment"> * interrupted&#125; by any thread before or while it is waiting, then an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> InterruptedException&#125; is thrown.  This exception is not</span></span><br><span class="line"><span class="comment"> * thrown until the lock status of this object has been restored as</span></span><br><span class="line"><span class="comment"> * described above.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 只会解锁当前调用wait的对象，而该线程的其他对象是不会解锁的</span></span><br><span class="line"><span class="comment"> * Note that the &#123;<span class="doctag">@code</span> wait&#125; method, as it places the current thread</span></span><br><span class="line"><span class="comment"> * into the wait set for this object, unlocks only this object; any</span></span><br><span class="line"><span class="comment"> * other objects on which the current thread may be synchronized remain</span></span><br><span class="line"><span class="comment"> * locked while the thread waits.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><p>导致<code>wait()</code>的线程被唤醒的有4种情况：</p><ul><li>该线程发生中断</li><li>wait 时间已到</li><li>被notify 唤醒（下面会介绍）</li><li>被notifyAll 唤醒</li></ul><p>调用<code>wait()</code>的线程会释放掉锁！</p><h3 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify()方法"></a>notify()方法</h3><h4 id="源码：-5"><a href="#源码：-5" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `随机`唤醒正在等待的对象（可能不止一个等待对象）</span></span><br><span class="line"><span class="comment"> * Wakes up a single thread that is waiting on this object's</span></span><br><span class="line"><span class="comment"> * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment"> * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment"> * the discretion of the implementation. A thread waits on an object's</span></span><br><span class="line"><span class="comment"> * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 3种方式来成为监听器对象的所有者</span></span><br><span class="line"><span class="comment"> * a. 调用该实例的同步方法</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing a synchronized instance method of that object.</span></span><br><span class="line"><span class="comment"> * b. 执行该对象的同步代码块</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing the body of a &#123;<span class="doctag">@code</span> synchronized&#125; statement</span></span><br><span class="line"><span class="comment"> *     that synchronizes on the object.</span></span><br><span class="line"><span class="comment"> * c. 执行对应的静态代码块</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;For objects of type &#123;<span class="doctag">@code</span> Class,&#125; by executing a</span></span><br><span class="line"><span class="comment"> *     synchronized static method of that class.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Only one thread at a time can own an object's monitor.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒所有正在等待队列的线程</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object's monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object's monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h5 id="1、为什么wait和notify在Object方法上？"><a href="#1、为什么wait和notify在Object方法上？" class="headerlink" title="1、为什么wait和notify在Object方法上？"></a>1、为什么wait和notify在Object方法上？</h5><p> 因为我们的<strong>锁是对象锁</strong>， 每个对象都可以成为锁。<strong>让当前线程等待某个对象的锁，当然应该通过这个对象来操作了</strong>。  锁对象是<strong>任意</strong>的，所以这些方法必须定义在Object类中 。</p><h5 id="2、sleep和wait有什么区别？"><a href="#2、sleep和wait有什么区别？" class="headerlink" title="2、sleep和wait有什么区别？"></a>2、sleep和wait有什么区别？</h5><p> <code>Thread.sleep()</code>与<code>Object.wait()</code>二者都可以暂停当前线程，释放CPU控制权。 主要的区别在于<code>Object.wait()</code>在释放CPU同时，<strong>释放了对象锁的控制</strong>。  而<code>Thread.sleep()</code>没有对锁释放 。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;加油吧！&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                   —– me   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="penghui.club/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP的四次挥手</title>
    <link href="penghui.club/2020/07/01/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>penghui.club/2020/07/01/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2020-07-01T08:34:02.000Z</published>
    <updated>2020-07-01T08:44:39.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第二高峰是乔戈里峰，第三是干城章嘉峰，第四是洛子峰，第五是马卡鲁峰，，，，其实只要尽自己的能力，无论做到第几，都会有人记住的。</p><p>​                                                                                                                                                             —– 网易云热评   </p></blockquote><a id="more"></a><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a><strong>TCP四次挥手</strong></h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/v2-c8b61ed2a249700583b11bc5d16c5711_hd.jpg" alt="v2-c8b61ed2a249700583b11bc5d16c5711_hd"></p><h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a><strong>第一次挥手</strong></h3><p>若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：<br>FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。</p><ul><li>PS1：FIN=1表示该报文段是一个连接释放请求。</li><li>PS2：seq=u，u-1是A向B发送的最后一个字节的序号。</li></ul><h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a><strong>第二次挥手</strong></h3><p>B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：<br>ACK=1，seq=v，ack=u+1。</p><ul><li>PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。</li><li>PS2：seq=v，v-1是B向A发送的最后一个字节的序号。</li><li>PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。</li></ul><p>A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。</p><p>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p><h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a><strong>第三次挥手</strong></h3><p>当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</p><h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a><strong>第四次挥手</strong></h3><p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p><h3 id="为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"><a href="#为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？" class="headerlink" title="为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"></a><strong>为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？</strong></h3><p>为了保证B能收到A的确认应答。<br>若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭</p><p>转载： <a href="https://www.zhihu.com/question/24853633/answer/254224088" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633/answer/254224088</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;第二高峰是乔戈里峰，第三是干城章嘉峰，第四是洛子峰，第五是马卡鲁峰，，，，其实只要尽自己的能力，无论做到第几，都会有人记住的。&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                             —– 网易云热评   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="penghui.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP为什么要三次握手</title>
    <link href="penghui.club/2020/07/01/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>penghui.club/2020/07/01/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2020-07-01T08:10:45.000Z</published>
    <updated>2020-07-01T08:44:05.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>世界上最孤独的鲸鱼 发出的频率是52赫兹 而正常鲸鱼是15至25赫兹 世上没任何鲸鱼能听懂它 它没有鱼群 没有同类 但它没放弃大海 从千里外的太平洋游到大西洋 纵然呐喊二十五年没人应答 但大海有多浩瀚它比别的鲸鱼都清楚。</p><p>​                                                                                                                                                             —– 网易云热评   </p></blockquote><a id="more"></a><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/jisuanjiwangluo.jpg" alt="jisuanjiwangluo"></p><p>起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。<br>服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a><strong>第一次握手</strong></h3><p>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。</p><ul><li>PS1：SYN=1，ACK=0表示该报文段为连接请求报文。</li><li>PS2：x为本次TCP通信的字节流的初始序号。<br>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。</li></ul><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a><strong>第二次握手</strong></h3><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。<br>该应答发送完成后便进入SYN-RCVD状态。</p><ul><li>PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。</li><li>PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。</li><li>PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。</li></ul><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a><strong>第三次握手</strong></h3><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。<br>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。<br>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p><h3 id="为什么连接建立需要三次握手，而不是两次握手？"><a href="#为什么连接建立需要三次握手，而不是两次握手？" class="headerlink" title="为什么连接建立需要三次握手，而不是两次握手？"></a><strong>为什么连接建立需要三次握手，而不是两次握手？</strong></h3><p>防止失效的连接请求报文段被服务端接收，从而产生错误。</p><p>PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</p><p><span style="background-color: yellow; color:red;">若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</span></p><p>转载：<a href="https://www.zhihu.com/question/24853633/answer/254224088" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633/answer/254224088</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世界上最孤独的鲸鱼 发出的频率是52赫兹 而正常鲸鱼是15至25赫兹 世上没任何鲸鱼能听懂它 它没有鱼群 没有同类 但它没放弃大海 从千里外的太平洋游到大西洋 纵然呐喊二十五年没人应答 但大海有多浩瀚它比别的鲸鱼都清楚。&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                             —– 网易云热评   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="penghui.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务概念理解</title>
    <link href="penghui.club/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>penghui.club/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</id>
    <published>2020-06-25T11:26:44.000Z</published>
    <updated>2020-06-25T12:53:21.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><pre><code>有的人只要跋山涉水就可以见面。 只有少数人，需要时光机才能见面。 我在等一场意外的死亡 然后笑着去见孟婆                                                                        ----- 网易云热评</code></pre><a id="more"></a><h2 id="1、事务简介"><a href="#1、事务简介" class="headerlink" title="1、事务简介"></a>1、事务简介</h2><p><strong style="background-color: yellow; color: red;">事务，简短的说就是一组操作要么全部完成，要么全部不做，绝不允许只做其中的一部分操作。</strong ><br>比如银行转账，A账号转给B账号1000元，其中包括两个操作A-1000、B+1000，要么这两个操作全部完成，要么全部不做，决不允许只执行其中一个操作（你可以想想想如果A-1000，但是B没有+1000会有什么后果？/斜眼笑/斜眼笑）。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚:"></a><strong>事务回滚</strong>:</h3><p>当一个事务执行过程中发生了异常、错误，则重新回到最先未开始执行的过程。比如上面那个银行转账过程，假设A-1000操作已经完成，但是在执行B+1000操作时，系统发生位置错误，这时需要回到未执行该转账操作之前的状态，即A、B原来多少钱还是多少钱，一分不能少。</p><h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交:"></a>事务提交:</h3><p>当一个事务执行过程没有发生任何异常、错误，这时我们要保存这个事务的修改。比如上面的银行转账过程，假设A-1000、B+1000操作全部完成，没有出现任何异常、错误，这时需要保存事务执行状态修改（A减少了1000元，B增加了1000元），即事务提交。</p><h2 id="2、事务的特性-ACID"><a href="#2、事务的特性-ACID" class="headerlink" title="2、事务的特性(ACID)"></a>2、事务的特性(ACID)</h2><p>事务具有<strong>四大特性</strong>，如下：</p><p><strong>①、原子性(Atomicity)</strong>：整体 【原子性是指事务包含的所有操作要么全部成功，要么全部失败】<br><strong>②、一致性(Consistency)</strong>：数据 【事务提交后的状态合集称为一致，也就是数据库只包含事务提交的状态】<br><strong>③、隔离性(Isolation)</strong>：并发 【对于任意两个并发的事务A和B，在事务A看来，B要么在A开始之前就已经结束，要么在A结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。】<br><strong>④、持久性(Durability)</strong>：结果 【持久性是指一个事务一旦提交了，就保存到硬盘上，对数据库中的数据的改变就是永久性的】</p><h2 id="3、事务隔离问题"><a href="#3、事务隔离问题" class="headerlink" title="3、事务隔离问题"></a>3、事务隔离问题</h2><p>由于事务可包含多个操作，在多个客户端并发访问过程，可能会发生一个事务只做了一部分操作，此时另外一个事务也开始执行，那么前一个事务的只执行部分操作的中间状态会给第二个事务造成影响。</p><p>再举个转账的例子，比如第一个事务包含A-100000，B+100000两个操作，当它把两个操作执行完后，正准备提交，恰在此时另外一个客户端B开启了第二个事务检查它的余额，此时已经到账了100000元。但是第一个事务对应的哪个顾客发现转错人了，所以执行了事务回滚，那么A、B原来多少钱还是多少钱，此时B客户的事务再查它的余额发现之前的100000元又不见了！</p><h3 id="①、读未提交读-Read-Uncommitted-，也称脏读"><a href="#①、读未提交读-Read-Uncommitted-，也称脏读" class="headerlink" title="①、读未提交读(Read Uncommitted)，也称脏读:"></a><strong>①、读未提交读(Read Uncommitted)，也称脏读</strong>:</h3><p>一个事务读到另一个事务未提交的内容事务B读看到事务A没有提交的内容，比如对A、B账户的修改。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204113244757.jpg" alt="20191204113244757"></p><h3 id="②、不可重复读-Read-Committed"><a href="#②、不可重复读-Read-Committed" class="headerlink" title="②、不可重复读(Read Committed):"></a><strong>②、不可重复读(Read Committed)</strong>:</h3><p>一个事务读到另一个事务已提交的内容（主要是数据更新）此级别解决了读未提交读的问题，即其它事务没有提交的内容对本事务不可见。<br>但是事务B能读到事务A提交的数据更新内容。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204113555818.jpg" alt="20191204113555818"></p><h3 id="③、可重复读-Repeatable-Read-，虚读（幻读）："><a href="#③、可重复读-Repeatable-Read-，虚读（幻读）：" class="headerlink" title="③、可重复读(Repeatable Read)，虚读（幻读）："></a><strong>③、可重复读(Repeatable Read)，虚读（幻读）</strong>：</h3><p>一个事务读到另一个事务已提交的内容（主要是数据插入）此级别解决了读未提交读、不可重复读的问题，事务B能读到事务A提交的数据插入内容。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204114519339.jpg" alt="20191204114519339"></p><h3 id="④、可串行化-Serializable-："><a href="#④、可串行化-Serializable-：" class="headerlink" title="④、可串行化(Serializable)："></a><strong>④、可串行化(Serializable)</strong>：</h3><p>最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204120121806.jpg" alt="20191204120121806"></p><h2 id="4、事务锁"><a href="#4、事务锁" class="headerlink" title="4、事务锁"></a>4、事务锁</h2><p>为了解决事务隔离性问题，引入锁的概念，只有拿到锁的事务才可对数据库进行读写操作\color{red}只有拿到锁的事务才可对数据库进行读写操作只有拿到锁的事务才可对数据库进行读写操作。事务有两种锁，并且有相应的权限。</p><h3 id="①、读锁，也称为共享锁。"><a href="#①、读锁，也称为共享锁。" class="headerlink" title="①、读锁，也称为共享锁。"></a>①、读锁，也称为共享锁。</h3><p>某个事务A拿到该锁时，事务A只能进行读操作，此时其他事务也可以拿到这把锁（共享）。</p><h3 id="②、写锁，也称为排它锁。"><a href="#②、写锁，也称为排它锁。" class="headerlink" title="②、写锁，也称为排它锁。"></a>②、写锁，也称为排它锁。</h3><p>某个事务A拿到该锁时，事务A能进行读、写操作，此时其他事务不能拿到这把锁（排它）。<br>如果某个事务A拿到了读锁，其它事务可以拿到读锁（共享），但是无法获取写锁。<br>如果某个事务A拿到了写锁，其他事务既不能拿到写锁，也拿不到读锁！</p><h3 id="③、锁的粒度"><a href="#③、锁的粒度" class="headerlink" title="③、锁的粒度"></a>③、锁的粒度</h3><p>所谓锁的粒度，就是锁的范围，比如如果锁的范围是一张表，则事务A获取写锁后，只能事务A进行读、写，其他事务全部要靠边站。<br>如果锁的粒度是事务A需要操作的某几行记录，其它记录如果其他事务拿到锁仍然可以读、写。</p><p><strong>一般情况下，锁的粒度越小（锁的范围小），则并发问题解决越好（事务都是并发执行），但是效率越低，因为需要大量的资源来确保各个事务的锁的粒度没有交集、冲突。</strong></p><p><strong>锁的粒度越大（锁的范围大），则并发问题解决越差（其他事务都在等待），但是效率较高，因为不要资源来控制各个事务的锁粒度交集问题。</strong></p><h2 id="5、运用锁解决隔离性问题"><a href="#5、运用锁解决隔离性问题" class="headerlink" title="5、运用锁解决隔离性问题"></a>5、运用锁解决隔离性问题</h2><p>这里演示一下使用写锁解决读未提交读的问题，其它并发问题都可以通过类似的方法解决。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204124729517.jpg" alt="20191204124729517"></p><p>原文链接：<a href="https://blog.csdn.net/qq_41855420/article/details/103382189" target="_blank" rel="noopener">https://blog.csdn.net/qq_41855420/article/details/103382189</a></p>]]></content>
    
    <summary type="html">
    
      数据库事务概念
    
    </summary>
    
    
    
      <category term="数据库" scheme="penghui.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉搜索树详解(附C++代码实现查找、插入、删除操作)</title>
    <link href="penghui.club/2020/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%AF%A6%E8%A7%A3-%E9%99%84C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <id>penghui.club/2020/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%AF%A6%E8%A7%A3-%E9%99%84C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-24T09:43:19.000Z</published>
    <updated>2020-06-25T12:53:39.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多年以后的某个深夜。你会不会突然想起我 然后泪如泉涌 。才发现你曾亏欠我太多。你陪我一程。可我会惦记你一生。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二叉搜索树详解"><a href="#二叉搜索树详解" class="headerlink" title="二叉搜索树详解"></a>二叉搜索树详解</h2><h3 id="一、二叉搜索树简述"><a href="#一、二叉搜索树简述" class="headerlink" title="一、二叉搜索树简述"></a>一、<code>二叉搜索树</code>简述</h3><p>  二叉搜索树大致定义为二叉树的左子树任意节点的值小于根节点的值，右子树任意节点的值大于根节点的值，并且左子树、右子树同样也符合二叉搜索树的定义（递归定义）。中序遍历顺序为左根右，所以二叉搜索树的典型特征是中序遍历序列有序。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041722005953.jpg" alt="2020041722005953"></p><h3 id="二、二叉搜索树相关操作"><a href="#二、二叉搜索树相关操作" class="headerlink" title="二、二叉搜索树相关操作"></a>二、二叉搜索树相关操作</h3><p>  为了能让大家更好的理解二叉搜索树，将提供C++的编码实现。下面是TreeNode结构体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里额外添加了parent指针，主要是为了访问父节点方便</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 三个指针分别指向父节点、左子树根节点、右子树根节点</span></span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value) : value(value), parent(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value, TreeNode *parent, TreeNode *left, TreeNode *right) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right =right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color: red;">温馨提示：</span>查找、插入、删除节点三个操作的复杂度依次增加，如果觉得有点压力，请按照顺序依次阅读，稳扎稳打。</p><h4 id="1、二叉搜索树中节点的查找"><a href="#1、二叉搜索树中节点的查找" class="headerlink" title="1、二叉搜索树中节点的查找"></a>1、二叉搜索树中节点的查找</h4><p>  二叉搜索树设计成左 &lt; 根 &lt; 右（中序遍历有序），一个很重要的动机就是快速查找。有过一点算法基础的应该能想到有一种搜索策略非常相似，没错就是二分搜索，每次将target与搜索区间（递增有序）的中间值mid比较，如果target &lt; mid则缩小搜索区间为[left, mid - 1],如果target &gt; mid则缩小搜索区间为[mid + 1, right],否则target == mid。辣么再来看看二叉搜索树中查找的伪代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root 指向二叉搜索树的根，target为需要搜索的值</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> root-&gt;value == target</span><br><span class="line">        成功搜索到了 <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> root-&gt;value &gt; target</span><br><span class="line">        <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">        <span class="comment">// 既然root-&gt;value &gt; target，那么只可能出现在左子树，转移root到左子树</span></span><br><span class="line">        root = root-&gt;left</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则root-&gt;value &lt; target</span></span><br><span class="line">        <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">        <span class="comment">// 既然root-&gt;value &lt; target，那么只可能出现在右子树，转移root到右子树</span></span><br><span class="line">        root = root-&gt;right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// root == NULL，二叉搜索树中没有target</span></span><br></pre></td></tr></table></figure><h5 id="C-代码实现："><a href="#C-代码实现：" class="headerlink" title="C++代码实现："></a>C++代码实现：</h5><p>// 在二叉搜索树中查找target，存在返回对应的指针，否则返NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">searchNode</span><span class="params">(TreeNode *root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;value == target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;value &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然root-&gt;value &gt; target，那么只可能出现在左子树，转移root到左子树</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则root-&gt;value &lt; target</span></span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然root-&gt;value &lt; target，那么只可能出现在右子树，转移root到右子树</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、二叉搜索树中节点的插入"><a href="#2、二叉搜索树中节点的插入" class="headerlink" title="2、二叉搜索树中节点的插入"></a>2、二叉搜索树中节点的插入</h4><p>  二叉搜索树中查找充分利用左 &lt; 根 &lt; 右特性，辣么插入也能用上这个特性么？答案是显然的。<br>  首先思考一下，我们插入节点后是不是还需要维持二叉树仍然满足二叉搜索树特性，这是必须的，要不能你的二叉搜索树就变成一次性的了。辣么我们就先要找到它真实应该插入的位置，保证中序遍历为递增有序。下面是删除的伪代码.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root 指向二叉搜索树的根，value为需要插入的值</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">// 二叉搜索树为空，插入的节点即是根节点</span></span><br><span class="line">    root = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 我们需要找到插入的位置</span></span><br><span class="line">    TreeNode *ptr = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ptr-&gt;value == value</span><br><span class="line">            <span class="comment">// 树中已经存在这个value，不进行插入（这里简化逻辑）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ptr-&gt;value &gt; value</span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然ptr-&gt;value &gt; value，value只能插入ptr左子树</span></span><br><span class="line">            <span class="keyword">if</span> ptr-&gt;left == <span class="literal">NULL</span></span><br><span class="line">                <span class="comment">// 如果ptr左子树为空，则插入的节点正好做左子树的根</span></span><br><span class="line">                ptr-&gt;left = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则转移到左子树，继续查找</span></span><br><span class="line">                ptr = ptr-&gt;left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然ptr-&gt;value &lt; value，value只能插入ptr右子树</span></span><br><span class="line">            <span class="keyword">if</span> ptr-&gt;right == <span class="literal">NULL</span></span><br><span class="line">                <span class="comment">// 如果ptr右子树为空，则插入的节点正好做右子树的根</span></span><br><span class="line">                ptr-&gt;right = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则转移到右子树，继续查找</span></span><br><span class="line">                ptr = ptr-&gt;right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>C++代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中插入value，如果二叉树中已经存在则不进行插入（简化处理逻辑）</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">searchNode</span><span class="params">(TreeNode *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 二叉搜索树为空，插入的节点即是根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 我们需要找到插入的位置</span></span><br><span class="line">        TreeNode *ptr = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;value == value) &#123;</span><br><span class="line">                <span class="comment">// 树中已经存在这个value，不进行插入（这里简化逻辑）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;value &gt; value) &#123;</span><br><span class="line">                <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">                <span class="comment">// 既然ptr-&gt;value &gt; value，value只能插入ptr左子树</span></span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果ptr左子树为空，则插入的节点正好做左子树的根</span></span><br><span class="line">                    ptr-&gt;left = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则转移到左子树，继续查找</span></span><br><span class="line">                    ptr = ptr-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">                <span class="comment">// 既然ptr-&gt;value &lt; value，value只能插入ptr右子树</span></span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果ptr右子树为空，则插入的节点正好做右子树的根</span></span><br><span class="line">                    ptr-&gt;right = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则转移到右子树，继续查找</span></span><br><span class="line">                    ptr = ptr-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、二叉搜索树中节点的删除"><a href="#3、二叉搜索树中节点的删除" class="headerlink" title="3、二叉搜索树中节点的删除"></a>3、二叉搜索树中节点的删除</h4><p>  在二叉搜索树删除节点，首先我们应该在树中查找到这个节点的位置吧，然后将其移除，并且移除后我们需要进行调整，使其任然满足二叉搜索树。这个删除操作可以分成好几种情况，需要分别讨论。</p><h5 id="①、删除叶节点"><a href="#①、删除叶节点" class="headerlink" title="①、删除叶节点"></a>①、删除叶节点</h5><p>  删除叶节点，只要将其移除即可，不需要进行任何调整操作。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041808272493.jpg" alt="2020041808272493"></p><h5 id="②、删除非叶节点"><a href="#②、删除非叶节点" class="headerlink" title="②、删除非叶节点"></a>②、删除非叶节点</h5><p>  删除非叶节点可以细分为两种，第一种是删除有右子树的节点，删除节点后需要将右子树中序遍历第一个节点填充到删除节点A位置（为什么选右子树中序遍历第一个节点？因为整棵树的中序遍历序列中，节点A的下一个节点就是其右子树中序遍历的第一个节点）。<br>  右子树中序遍历第一个节点为某个节点的左子节点，直接将最左的左子节点填补到已删除节点的位置。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041808351744.jpg" alt="2020041808351744"></p><h5 id="a、删除节点有右子树"><a href="#a、删除节点有右子树" class="headerlink" title="a、删除节点有右子树"></a>a、删除节点有右子树</h5><p>  右子树中序遍历序列中的第一个节点为某个没有左子节点的节点B。将节点B填入已删除节点的位置，并且将节点B的右子树置于节点B的位置。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418084409899.jpg" alt="20200418084409899"></p><h5 id="b、删除节点没有右子树"><a href="#b、删除节点没有右子树" class="headerlink" title="b、删除节点没有右子树"></a>b、删除节点没有右子树</h5><p>  第二种是删除没有右子树的节点A，此时寻找整颗二叉树中序遍历中节点A的下一个节点，稍微复杂一点，需要利用parent指针。找到远祖父节点B，并且使得节点A在远祖父节点B的左子树中！远祖父节点B.value替换到节点A.value后，它自己也需要它的下一个节点来填充。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418090738723.jpg" alt="20200418090738723"><br>  <span style="color: red">备注：</span>其实根本不需要进行删除操作，只要寻找到这个节点中序遍历序列的下一个节点，然后直接替换即可。<br>C++代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中插入value，如果二叉树中已经存在则不进行插入（简化处理逻辑）</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">deleteNode</span><span class="params">(TreeNode *root, TreeNode *targetPtr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetPtr == <span class="literal">NULL</span> || root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == targetPtr &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 一、删除的是根节点，并且根节点没有右子树</span></span><br><span class="line">        <span class="comment">// 处理：切断targetPtr与左子树的关联，返回左子树，释放targetPtr</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetPtr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> targetPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (targetPtr-&gt;left == targetPtr-&gt;right) &#123;</span><br><span class="line">        <span class="comment">// 二、删除的叶节点</span></span><br><span class="line">        <span class="comment">// targetPtr-&gt;left == targetPtr-&gt;right,只能是同时为NULL</span></span><br><span class="line">        <span class="comment">// 操作：切断parent与targetPtr的关联，返回root，释放targetPtr</span></span><br><span class="line">        <span class="keyword">if</span> (targetPtr-&gt;parent-&gt;left == targetPtr) &#123;</span><br><span class="line">            targetPtr-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetPtr-&gt;parent-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切断targetPtr 与targetPtr-&gt;parent的关联</span></span><br><span class="line">        targetPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> targetPtr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetPtr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 三、删除节点右子树为空      需要找到远祖父节点</span></span><br><span class="line">        TreeNode *pParent = targetPtr;</span><br><span class="line">        <span class="comment">// 祖父节点B，并且使得节点targetPtr在远祖父节点B的左子树</span></span><br><span class="line">        <span class="keyword">while</span> (pParent-&gt;parent != <span class="literal">NULL</span> &amp;&amp; pParent-&gt;parent-&gt;right == pParent) &#123;</span><br><span class="line">            pParent = pParent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pParent-&gt;parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果targetPtr不存在一个远祖父节点B，使得leftPtr在远祖父B的左子树</span></span><br><span class="line">            <span class="comment">// 操作：只能删除这个节点，并且把左子树放到当前节点的位置</span></span><br><span class="line">            targetPtr-&gt;parent-&gt;right = targetPtr-&gt;left;</span><br><span class="line">            targetPtr-&gt;left-&gt;parent = targetPtr-&gt;parent;</span><br><span class="line">            <span class="comment">// 切断targetPtr与parent、left的关系</span></span><br><span class="line">            targetPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">            targetPtr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> targetPtr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则pParent-&gt;parent-&gt;value替换targetPtr-&gt;value，再删除pParent-&gt;parent（递归）</span></span><br><span class="line">            targetPtr-&gt;value = pParent-&gt;parent-&gt;value;</span><br><span class="line">            root = deleteNode(root, pParent-&gt;parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 四、删除节点存在右子树，直接在右子树寻找中序遍历的第一个节点</span></span><br><span class="line">        TreeNode * leftPtr = targetPtr-&gt;right;</span><br><span class="line">        <span class="comment">// 一直往left寻找</span></span><br><span class="line">        <span class="keyword">while</span> (leftPtr-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            leftPtr = leftPtr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将leftPtr-&gt;value替换到targetPtr-&gt;value</span></span><br><span class="line">        targetPtr-&gt;value = leftPtr-&gt;value;</span><br><span class="line">        <span class="comment">// targetPtr-&gt;right就是leftPtr</span></span><br><span class="line">        <span class="keyword">if</span> (targetPtr-&gt;right == leftPtr) &#123;</span><br><span class="line">            <span class="comment">// 将targetPtr-&gt;right指向leftPtr右子树</span></span><br><span class="line">            targetPtr-&gt;right = leftPtr-&gt;right;</span><br><span class="line">            <span class="comment">// 如果targetPtr-&gt;right ！= NULL，还需要设置parent</span></span><br><span class="line">            <span class="keyword">if</span> (leftPtr-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                leftPtr-&gt;right-&gt;parent = targetPtr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则leftPtr-&gt;parent与leftPtr切断关系</span></span><br><span class="line">            leftPtr-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将leftPtr于其parent切断关系并释放</span></span><br><span class="line">        leftPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> leftPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">deleteNodeByValue</span><span class="params">(TreeNode *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先查找value所在的位置</span></span><br><span class="line">    TreeNode *targetPtr = searchNode(root, value);</span><br><span class="line">    <span class="keyword">if</span> (targetPtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// value都没找到还删除啥...</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deleteNode(root, targetPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、思考与总结"><a href="#三、思考与总结" class="headerlink" title="三、思考与总结"></a>三、思考与总结</h3><p>  可以看出二叉搜索树的查找、插入还是比较简单的，删除稍微复杂一点。不过二叉搜索树可能存在退化成链表的缺陷，比如给你一个本来递增有序的序列让你插入到一颗空二叉搜索树中，这时就退化成链表了。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418111144946.jpg" alt="20200418111144946"><br>  因此我们需要将二叉搜索树增加平衡的特性，即AVL树或红黑树。<br>原文链接：<a href="https://hestyle.blog.csdn.net/article/details/105595528" target="_blank" rel="noopener">https://hestyle.blog.csdn.net/article/details/105595528</a></p>]]></content>
    
    <summary type="html">
    
      数据结构之二叉搜索树
    
    </summary>
    
    
    
      <category term="数据结构" scheme="penghui.club/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="penghui.club/tags/%E6%A0%91/"/>
    
  </entry>
  
</feed>
