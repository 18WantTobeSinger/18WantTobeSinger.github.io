<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Halo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://18wanttobesinger.github.io/"/>
  <updated>2020-07-06T11:16:59.436Z</updated>
  <id>https://18wanttobesinger.github.io/</id>
  
  <author>
    <name>Halo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring相关知识点</title>
    <link href="https://18wanttobesinger.github.io/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://18wanttobesinger.github.io/2020/07/06/spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-07-06T10:22:17.000Z</published>
    <updated>2020-07-06T11:16:59.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。</p><p>​                                                                                                        —– 网易云热评</p></blockquote><a id="more"></a><h3 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h3><h4 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h4><ul><li>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</li><li>它是轻量级、松散耦合的。</li><li>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</li><li>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</li></ul><h4 id="Spring-Framework-有哪些不同的功能？"><a href="#Spring-Framework-有哪些不同的功能？" class="headerlink" title="Spring Framework 有哪些不同的功能？"></a>Spring Framework 有哪些不同的功能？</h4><ul><li>轻量级 - Spring 在代码量和透明度方面都很轻便。</li><li>OC - 控制反转</li><li>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</li><li>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</li><li>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</li><li>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</li><li>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</li></ul><h4 id="什么是-Spring-配置文件？"><a href="#什么是-Spring-配置文件？" class="headerlink" title="什么是 Spring 配置文件？"></a>什么是 Spring 配置文件？</h4><p>​        Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。</p><h3 id="依赖注入（IOC）"><a href="#依赖注入（IOC）" class="headerlink" title="依赖注入（IOC）"></a>依赖注入（IOC）</h3><h4 id="什么是-Spring-IOC-容器？"><a href="#什么是-Spring-IOC-容器？" class="headerlink" title="什么是 Spring IOC 容器？"></a>什么是 Spring IOC 容器？</h4><p>​        Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p><h4 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h4><p>​        在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p><h4 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h4><p>通常，依赖注入可以通过三种方式完成，即：</p><ul><li>构造函数注入</li><li>setter 注入</li><li>接口注入</li></ul><h4 id="区分构造函数注入和-setter-注入。"><a href="#区分构造函数注入和-setter-注入。" class="headerlink" title="区分构造函数注入和 setter 注入。"></a>区分构造函数注入和 setter 注入。</h4><table><thead><tr><th align="left">构造函数注入</th><th align="left">setter 注入</th></tr></thead><tbody><tr><td align="left">任意修改都会创建一个新实例</td><td align="left">任意修改不会创建一个新实例</td></tr><tr><td align="left">适用于设置很多属性</td><td align="left">适用于设置少量属性</td></tr></tbody></table><h4 id="spring-中有多少种-IOC-容器？"><a href="#spring-中有多少种-IOC-容器？" class="headerlink" title="spring 中有多少种 IOC 容器？"></a>spring 中有多少种 IOC 容器？</h4><ul><li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li><li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li></ul><h4 id="区分-BeanFactory-和-ApplicationContext。"><a href="#区分-BeanFactory-和-ApplicationContext。" class="headerlink" title="区分 BeanFactory 和 ApplicationContext。"></a>区分 BeanFactory 和 ApplicationContext。</h4><table><thead><tr><th>BeanFactory</th><th>ApplicationContext</th></tr></thead><tbody><tr><td>它使用懒加载</td><td>它使用即时加载</td></tr><tr><td>它使用语法显式提供资源对象</td><td>它自己创建和管理资源对象</td></tr><tr><td>不支持国际化</td><td>支持国际化</td></tr><tr><td>不支持基于依赖的注解</td><td>支持基于依赖的注解</td></tr></tbody></table><h4 id="Spring-IoC-的实现机制。"><a href="#Spring-IoC-的实现机制。" class="headerlink" title="Spring IoC 的实现机制。"></a>Spring IoC 的实现机制。</h4><p>​        Spring 中的 IoC 的实现原理就是<strong>工厂模式加反射机制</strong>。</p><h3 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h3><h4 id="spring-提供了哪些配置方式？"><a href="#spring-提供了哪些配置方式？" class="headerlink" title="spring 提供了哪些配置方式？"></a>spring 提供了哪些配置方式？</h4><h5 id="1、基于-xml-配置"><a href="#1、基于-xml-配置" class="headerlink" title="1、基于 xml 配置"></a>1、基于 xml 配置</h5><p>​        bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentbean"</span> <span class="attr">class</span>=<span class="string">"org.edureka.firstSpring.StudentBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Edureka"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、基于注解配置"><a href="#2、基于注解配置" class="headerlink" title="2、基于注解配置"></a>2、基于注解配置</h5><p>​        您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、基于-Java-API-配置"><a href="#3、基于-Java-API-配置" class="headerlink" title="3、基于 Java API 配置"></a>3、基于 Java API 配置</h5><p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p><ol><li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。<br>例如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spring-支持集中-bean-scope？"><a href="#spring-支持集中-bean-scope？" class="headerlink" title="spring 支持集中 bean scope？"></a>spring 支持集中 bean scope？</h4><p> Spring bean 支持 5 种 scope： </p><ul><li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li><li>Prototype - 每次请求都会产生一个新的实例。</li><li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li><li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li><li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。</li></ul><p>常用的有<code>Singleton</code>、<code>Prototype</code>。 仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。 </p><h4 id="spring-bean-容器的生命周期是什么样的？"><a href="#spring-bean-容器的生命周期是什么样的？" class="headerlink" title="spring bean 容器的生命周期是什么样的？"></a>spring bean 容器的生命周期是什么样的？</h4><p>spring bean 容器的生命周期流程如下：</p><ol><li>Spring 容器根据配置中的 bean 定义中实例化 bean。</li><li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li><li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li><li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li><li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li><li>如果为 bean 指定了 init 方法（<bean> 的 init-method 属性），那么将调用它。</li><li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li><li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。<br>如果为 bean 指定了 destroy 方法（<bean> 的 destroy-method 属性），那么将调用它。</li></ol><h4 id="什么是-spring-装配"><a href="#什么是-spring-装配" class="headerlink" title="什么是 spring 装配"></a>什么是 spring 装配</h4><p>​        当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p><h4 id="自动装配有哪些方式？"><a href="#自动装配有哪些方式？" class="headerlink" title="自动装配有哪些方式？"></a>自动装配有哪些方式？</h4><p>​        Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p><p>自动装配的不同模式：</p><ol><li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li><li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li><li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li><li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li><li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li></ol><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="什么是基于注解的容器配置"><a href="#什么是基于注解的容器配置" class="headerlink" title="什么是基于注解的容器配置"></a>什么是基于注解的容器配置</h4><p>​        不使用 XML 来描述 bean 装配，开发人员通过在相关的类，<strong>方法或字段</strong>声明上使用注解将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p><p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p><ul><li>@Bean 注解扮演与 元素相同的角色。</li><li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li></ul><p><em>可以这么来说，当一个类使用<code>@Configuration</code>注解标注时，那么该类相当于一个spring的 xml 配置文件</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentBean <span class="title">myStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何在-spring-中启动注解装配？"><a href="#如何在-spring-中启动注解装配？" class="headerlink" title="如何在 spring 中启动注解装配？"></a>如何在 spring 中启动注解装配？</h4><p>​        默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置<code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p><h4 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h4><ul><li><strong>@Component</strong>：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li><li><strong>@Controller</strong>：这将一个类标记为 <code>Spring Web MVC</code> 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li><li><strong>@Service</strong>：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 <code>@Service</code> 而不是 <code>@Component</code>，因为它以更好的方式指定了意图。</li><li><strong>@Repository</strong>：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li></ul><h4 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h4><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是<span style="background-color: yellow;color: red;">类型驱动</span>的注入。</p><h4 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h4><p><code>@RequestMapping</code> 注解用于将特定 HTTP 请求方法映射到将处理相应请求的<strong>控制器</strong>中的<strong>特定类/方法</strong>。此注释可应用于两个级别：</p><ul><li>类级别（注解标注在类上）：映射请求的 URL</li><li>方法级别（注解标注在方法上）：映射 URL 以及 HTTP 请求方法</li></ul><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="什么是-AOP？"><a href="#什么是-AOP？" class="headerlink" title="什么是 AOP？"></a>什么是 AOP？</h4><p> AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong> </p><h4 id="什么是-Aspect？"><a href="#什么是-Aspect？" class="headerlink" title="什么是 Aspect？"></a>什么是 Aspect？</h4><pre><code>`aspect` 由 `pointcount` 和 `advice` 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP 就是负责实施切面的框架, 它将切面所定义的横切逻辑编织到切面所指定的连接点中.</code></pre><p> <strong>可以简单地认为, 使用 @Aspect 注解的类就是一个切面.</strong> </p><h4 id="什么是切点（JoinPoint）"><a href="#什么是切点（JoinPoint）" class="headerlink" title="什么是切点（JoinPoint）"></a>什么是切点（JoinPoint）</h4><p>​        程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理，在 Spring AOP 中, <code>join point</code> 就是方法的执行点。</p><h4 id="什么是通知（Advice）？"><a href="#什么是通知（Advice）？" class="headerlink" title="什么是通知（Advice）？"></a>什么是通知（Advice）？</h4><p>​        特定 <code>JoinPoint</code> 处的 <code>Aspect</code> 所采取的动作称为 <code>Advice</code>。Spring AOP 使用一个 <code>Advice</code> 作为拦截器，在 <code>JoinPoint</code> “周围”维护一系列的拦截器。</p><h4 id="有哪些类型的通知（Advice）？"><a href="#有哪些类型的通知（Advice）？" class="headerlink" title="有哪些类型的通知（Advice）？"></a>有哪些类型的通知（Advice）？</h4><ul><li><strong>Before</strong> - 这些类型的 <code>Advice</code> 在 <code>joinpoint</code> 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li><li><strong>After Returning</strong> - 这些类型的 <code>Advice</code> 在连接点方法正常执行后执行，并使用<code>@AfterReturning</code> 注解标记进行配置。</li><li><strong>After Throwing</strong> - 这些类型的 <code>Advice</code> 仅在 <code>joinpoint</code> 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li><li><strong>After (finally)</strong> - 这些类型的 <code>Advice</code> 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li><li><strong>Around</strong> - 这些类型的 <code>Advice</code> 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li></ul><h4 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h4><p>实现 AOP 的技术，主要分为两大类：</p><ul><li><strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为<strong>编译时增强</strong>；<ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul></li><li><strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为<strong>运行时增强</strong>。<ul><li>JDK 动态代理</li><li>CGLIB</li></ul></li></ul><h4 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h4><p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。<br>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h4><p>​        Spring Web MVC 框架提供 <strong>模型-视图-控制器</strong> 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p><h4 id="描述一下-DispatcherServlet-的工作流程"><a href="#描述一下-DispatcherServlet-的工作流程" class="headerlink" title="描述一下 DispatcherServlet 的工作流程"></a>描述一下 DispatcherServlet 的工作流程</h4><ol><li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li><li>DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li><li>DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li><li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：<ol><li>HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li><li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</li><li>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</li></ol></li><li>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</li><li>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</li><li>ViewResolver 结合Model和View，来渲染视图。</li><li>视图负责将渲染结果返回给客户端。</li></ol><p>原文链接：<a href="https://blog.csdn.net/qq_41701956/article/details/81389067" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81389067</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这首歌（老街）听了四年了，可忘不掉的是什么我还是也不知道。&lt;/p&gt;
&lt;p&gt;​                                                                                                        —– 网易云热评&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="spring" scheme="https://18wanttobesinger.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>NIO之缓冲区的使用</title>
    <link href="https://18wanttobesinger.github.io/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://18wanttobesinger.github.io/2020/07/06/NIO%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-06T08:17:56.000Z</published>
    <updated>2020-07-06T09:42:59.156Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>女人错过了她最想嫁的那个男人，就会变得挑剔；男人错过了那个他最想娶的女人，就会变得随意 那时候陪伴我的那个，这里的故事你是否还记得 </p><p>​                                                                                                       —– 网易云热评</p></blockquote><h2 id="NIO之缓冲区的使用"><a href="#NIO之缓冲区的使用" class="headerlink" title="NIO之缓冲区的使用"></a>NIO之缓冲区的使用</h2><p>今年寒假前，在学校图书馆里借了一本关于NIO的书，花了几天时间看完了，但是由于之前没有创建个人博客，所以今天重温一下做个笔记😁。</p><hr><h3 id="首先了解什么是NIO？"><a href="#首先了解什么是NIO？" class="headerlink" title="首先了解什么是NIO？"></a>首先了解什么是NIO？</h3><p>​        常规的 I/O （如InputStream 和 OutputStream）存在很大缺点，就是它们是阻塞的，而<code>NIO</code>解决的就是常规 I/O执行效率低的问题。即采用非阻塞高性能运行的方式来避免出现以前 “笨拙” 的同步 I/O带来的低效率问题。 <code>NIO</code>对常规的 I/O 使用的 byte[] 或 char[] 进行封装，采用 ByteBuffer 类来操作数据，再结合针对 File 或 Socket 技术的 Channel ，采用同步非阻塞技术实现高性能处理。</p><p>​        Buffer 类的信息如下：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594024381559.png" alt="1594024381559"></p><p>​        可以发现 Buffer 是个抽象类，那么它必定有子类，分别是：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594024436930.png" alt="1594024436930"></p><p>​        NIO 中Buffer是一个用于存储基本数据类型值的容器，它以类似于数组有序的方式来存储和组织数据。每个基本数据类型（除去 boolean）都有一个子类与之对应。</p><h3 id="Buffer-类的使用"><a href="#Buffer-类的使用" class="headerlink" title="Buffer 类的使用"></a>Buffer 类的使用</h3><p>​        观察上图，我们可以发现，Buffer 是个抽象类，并不能直接实例化，但是我们会发现，即使它的子类也都是抽象类，同样不可以直接实例化。那么我们该如何创建这些类的对象呢？使用方式是将上面 7 种数据类型的数组包装（wrap）进缓冲区，此时需要借助静态方法 <code>wrap()</code>进行实现。<code>wrap()</code>方法的作用是将数组放入缓冲区，来构建存储不同的数据类型缓冲区。以下以 CharBuffer 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CharBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">char</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>缓冲区为非线程安全的。</em></p><h3 id="NIO技术的缓冲区的-4-个核心技术点"><a href="#NIO技术的缓冲区的-4-个核心技术点" class="headerlink" title="NIO技术的缓冲区的 4 个核心技术点"></a>NIO技术的缓冲区的 4 个核心技术点</h3><h4 id="包装数据与获得容量"><a href="#包装数据与获得容量" class="headerlink" title="包装数据与获得容量"></a>包装数据与获得容量</h4><h5 id="capacity（容量）"><a href="#capacity（容量）" class="headerlink" title="capacity（容量）"></a>capacity（容量）</h5><p>​        它代表包含元素的数量。不可是负值，不可被修改。</p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"><span class="keyword">int</span> cap = charbuffer.capacity();</span><br><span class="line">System.out.println(cap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： 3</span></span><br></pre></td></tr></table></figure><h4 id="限制获取与设置"><a href="#限制获取与设置" class="headerlink" title="限制获取与设置"></a>限制获取与设置</h4><h5 id="limit（限制）"><a href="#limit（限制）" class="headerlink" title="limit（限制）"></a>limit（限制）</h5><p>​        返回此缓冲区的限制。什么是缓冲区的限制呢？它代表第一个不应该读取或写入元素的 index（索引）。不可以是负值，并且其值不能大于<code>capacity</code>。如果<code>position</code> 大于新的 <code>limit</code>，则奖<code>position</code>设置为新的<code>limit</code>。如果<code>mark</code>已定义且大于新的<code>limit</code>，则丢弃该<code>mark</code>。<code>limit</code>的应用示例如图所示：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594026005008.jpg" alt="1594026005008"></p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"><span class="keyword">int</span> limit = charbuffer.limit();</span><br><span class="line">System.out.println(<span class="string">"修改前"</span> + limit);</span><br><span class="line"></span><br><span class="line">charbuffer.limit(<span class="number">3</span>);</span><br><span class="line">limit = charbuffer.limit();</span><br><span class="line">System.out.println(<span class="string">"修改后"</span> + limit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// put(索引，数据)</span></span><br><span class="line">charbuffer.put(<span class="number">3</span>, <span class="string">'q'</span>);<span class="comment">// 此位置是第一个不可读不可写的索引,会抛出IndexOutOfBoundException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： </span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IndexOutOfBoundException</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="位置获取与设置"><a href="#位置获取与设置" class="headerlink" title="位置获取与设置"></a>位置获取与设置</h4><h5 id="position（位置）"><a href="#position（位置）" class="headerlink" title="position（位置）"></a>position（位置）</h5><p>​        代表 “下一个” 要读取或写入元素的索引，<code>position</code>不能为负值，并且<code>position</code>不能大于其<code>limit</code>。如果<code>mark</code>已定义且大于新的<code>position</code>，则丢弃该<code>mark</code>。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594026689661.jpg" alt="1594026689661"></p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span></span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">CharBuffer charbuffer = CharBuffer.wrap(chars);</span><br><span class="line"></span><br><span class="line"><span class="comment">// position 默认刚开始为 0</span></span><br><span class="line"><span class="keyword">int</span> position = charbuffer.position();</span><br><span class="line">System.out.println(<span class="string">"修改前: "</span> + position);</span><br><span class="line"></span><br><span class="line">charbuffer.position(<span class="number">3</span>);</span><br><span class="line">position = charbuffer.position();</span><br><span class="line">System.out.println(<span class="string">"修改后: "</span> + position);</span><br><span class="line"></span><br><span class="line">charbuffer.put(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i ++) </span><br><span class="line">    System.out.print(chars[i] + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果： </span></span><br><span class="line">修改前: <span class="number">0</span></span><br><span class="line">修改后: <span class="number">3</span></span><br><span class="line">a b c q e</span><br></pre></td></tr></table></figure><h4 id="剩余空间大小获取"><a href="#剩余空间大小获取" class="headerlink" title="剩余空间大小获取"></a>剩余空间大小获取</h4><h5 id="remaining（剩余空间）"><a href="#remaining（剩余空间）" class="headerlink" title="remaining（剩余空间）"></a>remaining（剩余空间）</h5><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    return limit - position</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1594027234062.jpg" alt="1594027234062"></p><p>上图：limit - position 会返回 2。</p><h4 id="设置标记："><a href="#设置标记：" class="headerlink" title="设置标记："></a><strong>设置标记：</strong></h4><h5 id="mark（标记）"><a href="#mark（标记）" class="headerlink" title="mark（标记）"></a>mark（标记）</h5><p>​        在此缓冲区的位置设置标记。</p><p>​        标记是一个索引，当我们调用<code>reset()</code>方法时，会将缓冲区的<code>position</code>位置重置为该索引。标记并不是必须的，同样不能是负数，并且不能让它大于<code>position</code>。如果定义<code>mark</code>，则再将<code>position</code>或<code>limit</code>调整为小于该<code>mark</code>的值时，该<code>mark</code>被丢弃，丢弃后其值为 -1。如果未定义<code>mark</code>，那么调用<code>reset()</code>方法将导致抛出<code>InvalidMarkException</code>异常。</p><p><strong>相关方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h3><ol><li>缓冲区的<code>capacity</code>、<code>limit</code>、<code>position</code>都不能是负数。</li><li><code>position</code>不能大于<code>limit</code>。</li><li><code>limit</code>不能大于capacity。</li><li>如果定义<code>mark</code>，在将<code>position</code>或<code>limit</code>调整为小于该<code>mark</code>的值时，该<code>mark</code>被丢弃。</li><li>未定义<code>mark</code>，调用<code>reset()</code>方法将导致抛出<code>InvalidMarkException</code>异常。</li><li>当<code>limit</code>和<code>position</code>值一样时，在指定的<code>position</code>位置写入数据会出现异常。</li></ol><p>喜欢本文的话，<strong>在评论区留个言吧😘</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="NIO" scheme="https://18wanttobesinger.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>通配符匹配</title>
    <link href="https://18wanttobesinger.github.io/2020/07/05/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/"/>
    <id>https://18wanttobesinger.github.io/2020/07/05/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</id>
    <published>2020-07-05T06:15:53.000Z</published>
    <updated>2020-07-05T08:29:13.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>到了二十多岁的年纪，我终于承认我真的很平庸，我会更加努力！加油！！！</p><p>​                                                                                                                               —– Halo</p></blockquote><a id="more"></a><h2 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></h2><p>今天是2020年7月5日，我仍在努力…</p><p>这道题是leetcode每日一题，典型的动态规划问题。虽说难度为<span style="color: red;">困难</span>，但是并不是很难。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;?&#39; 可以匹配任何单个字符。</span><br><span class="line">&#39;*&#39; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure><p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a><strong>说明:</strong></h3><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a><strong>示例 1:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a><strong>示例 2:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#39;*&#39; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a><strong>示例 3:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</span><br></pre></td></tr></table></figure><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a><strong>示例 4:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a><strong>示例 5:</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h3><p>这道题我本来想着先用递归来解，通过双指针法，不断递归，可惜超时。。。思路如下：</p><p>当 <code>s[i] == p[j]  || p[j] == &#39;?&#39;</code>，进行<code>helper(s, i + 1, p, j + 1);</code> </p><p>当 <code>p[j] == &#39;*&#39;</code>, 进行 <code>helper(s, i + 1, p, j) || helper(s, i + 1, p, j + 1) || helper(s, i, p, j + 1)</code>;</p><p>至于为什么这样做，接下来动态规划的思路会讲解。这里只提供大概得思路，时间复杂度是很高的，不建议使用此方法。</p><h4 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h4><ul><li>首先定义<strong>dp</strong>数组的含义：<code>dp[i][j]</code> 表示字符串 <strong>s</strong> 的前 i 个字符和字符串 <strong>p</strong> 的前 j 个字符是否匹配</li><li>接下来就按照情况划分：<ul><li>1、p[j] 和s[i] 相等；</li><li>2、p[j] = ‘?’；</li><li>3、p[j] = ‘*’；</li></ul></li><li><strong>1和2</strong>：可合为一种 <ul><li>只要<code>dp[i - 1][j - 1]</code>匹配，那么我们可以得出只要<code>p[j]</code> 和<code>s[i]</code> 相等或者<code>[j] = &#39;?&#39;</code>；那么 我们就能 <code>dp[i][j] = dp[i - 1][j - 1]</code>; </li></ul></li><li><strong>3</strong>：当p[j] = ‘*’，分为三种情况，只要这三种情况任意一个为true，那么<code>dp[i][j]</code>就为true：<ul><li>表示一个字符：<code>dp[i][j] = dp[i - 1][j - 1]</code>;</li><li>表示空：<code>dp[i][j] = dp[i][j - 1]</code>;</li><li>表示多个字符：<code>dp[i][j] = dp[i - 1][j]</code>;</li></ul></li></ul><p>这里我们可以使用一个小技巧，在<strong>s 和 p</strong>最前面拼接一个“ ”字符串，既可以防止为空，也可以为接下来的代码做准备：</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    s = <span class="string">" "</span> + s;</span><br><span class="line">    p = <span class="string">" "</span> + p;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> sLen = s.length(), pLen = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sLen + <span class="number">1</span>][pLen + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sLen; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pLen; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sLen][pLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再看看递归的做法，是不是恍然大悟了呢？😱</strong></p>]]></content>
    
    <summary type="html">
    
      通配符匹配
    
    </summary>
    
    
    
      <category term="算法" scheme="https://18wanttobesinger.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://18wanttobesinger.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Object解读</title>
    <link href="https://18wanttobesinger.github.io/2020/07/03/Object%E8%A7%A3%E8%AF%BB/"/>
    <id>https://18wanttobesinger.github.io/2020/07/03/Object%E8%A7%A3%E8%AF%BB/</id>
    <published>2020-07-03T09:48:04.000Z</published>
    <updated>2020-07-05T08:34:44.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>加油吧！</p><p>​                                                                                                                                                   —– me   </p></blockquote><a id="more"></a><h2 id="Object概述"><a href="#Object概述" class="headerlink" title="Object概述"></a>Object概述</h2><p>Object类位于java.lang包， Java中的每个类都是由这个类扩展而来，所有类都<strong>直接</strong>或者<strong>间接</strong>的<strong>继承</strong>自Object。 所以，所有类都继承了Object中的方法。首先来看看Object中都有那些方法吧！</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593774455032.jpg" alt="1593774455032.jpg"></p><p>随便挑选一个类，就会发现他也有这些个方法：</p><p>这是自己写的类</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593770525068.jpg" alt="1593770525068"></p><p>以下是它的方法：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/1593770564796.jpg" alt="1593770564796"></p><h3 id="Object中的构造方法"><a href="#Object中的构造方法" class="headerlink" title="Object中的构造方法"></a>Object中的构造方法</h3><p>​        有过java基础的同学都知道，java中如果没有有参的构造方法，那么该类会默认有一个无参的构造方法。</p><p> 所以Object类中具有默认的无参构造<code>Object()</code> 。 </p><h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a>hashCode()方法</h3><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a><strong>源码：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a hash code value for the object. This method is</span></span><br><span class="line"><span class="comment"> * supported for the benefit of hash tables such as those provided by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.util.HashMap&#125;.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>方法描述第一行：<strong>返回这个对象的hashcode， 支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。</strong> </p><p>我们来运行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：21685669</span></span><br></pre></td></tr></table></figure><p>该方法把对象的地址值换算成一个整数值，当两个对象不是同一对象，其地址值不同，哈希码值也不一样。 </p><p><em>注意：不同对象的hashcode有可能相同！同一个对象的hashcode一定相同！</em></p><p>当然你可以重写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无论如何打印类对象的hashcode，都是1</span></span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>同一个对象(如果该对象没有被修改)：那么重复调用<code>hashCode()</code>那么返回的int是相同的！ </li><li><code>hashCode()</code>方法默认是由对象的地址转换而来的 </li></ul><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><h4 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates whether some other object is "equal to" this one.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>返回某个对象是否与此对象“相等”。也就是比较两个对象的地址值是否相等，是否为同一对象。如果相等则返回true，不相等则返回false。 </p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        ObjectTest obj2 = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">        <span class="keyword">int</span> hashCode = obj.hashCode();</span><br><span class="line">        <span class="keyword">int</span> hashCode2 = obj2.hashCode();</span><br><span class="line">        System.out.println(hashCode);</span><br><span class="line">        System.out.println(hashCode2);</span><br><span class="line">        System.out.println(<span class="string">"obj: "</span> + obj);</span><br><span class="line">        System.out.println(<span class="string">"obj2: "</span> + obj2);</span><br><span class="line">        System.out.println(obj.equals(obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line">hashcode:  <span class="number">21685669</span></span><br><span class="line">hashcode2: <span class="number">19997786</span></span><br><span class="line">obj:  niuke.offer.ObjectTest@<span class="number">14</span>ae5a5</span><br><span class="line">obj2: niuke.offer.ObjectTest@<span class="number">131245</span>a</span><br><span class="line">对象是否相等：<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><ul><li>只有两个对象的地址相同，那么这两个对象才相等。当我们需要重写<code>equals()</code>方法时，<strong>必须重写hashCode()</strong>方法。</li><li><code>equals()</code>方法默认是比较对象的地址，使用的是<code>==</code>等值运算符 </li><li><code>equals()</code>方法还有5个默认的原则：<ul><li>自反性：调用<code>equals()</code>返回的是true，无论这两个对象谁调用<code>equals()</code>都好，返回的都是true 。</li><li>一致性：只要对象没有被修改，那么多次调用还是返回对应的结果！ </li><li>传递性：<code>x.equals(y)</code>和<code>y.equals(z)</code>都返回true，那么可以得出：<code>x.equals(z)</code>返回true 。</li><li>对称性：<code>x.equals(y)</code>和<code>y.equals(x)</code>结果应该是相等的。 </li><li>传入的参数为null，返回的是false </li></ul></li></ul><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><p>我们常用的String已经实现了<code>equals</code>和<code>hashCode</code>方法 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 地址相等那么两者对象肯定相等</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 判断两者长度，相等的话继续判断它们的值</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 发现两字符串值不相等</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 继续判断</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两者值相同返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><h4 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a string representation of the object. </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><p> 返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串表达式。 </p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectTest obj = <span class="keyword">new</span> ObjectTest();</span><br><span class="line">System.out.println(obj.toString());</span><br><span class="line"><span class="comment">// 输出：niuke.offer.ObjectTest@14ae5a5</span></span><br><span class="line"><span class="comment">// 类名@对象哈希码的无符号十六进制</span></span><br></pre></td></tr></table></figure><p>通常我们并不会需要用着这种字符串的情况，一般需要重写该方法打印该对象的一些具体信息。</p><h3 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h3><h4 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns a copy of this object.  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 拷贝的对象和原对象的引用一般不相同</span></span><br><span class="line"><span class="comment"> * x.clone() != x&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be true, and that the expression:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 拷贝对象和原对象调用equals一般相等</span></span><br><span class="line"><span class="comment"> * x.clone().equals(x)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * will be &#123;<span class="doctag">@code</span> true&#125;, this is not an absolute requirement.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * By convention, the object returned by this method should be independent</span></span><br><span class="line"><span class="comment"> * of this object (which is being cloned).  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 因此往往其成员变量（如果是可变的引用）都需要拷贝一份出去（实现完全独立）</span></span><br><span class="line"><span class="comment"> * Typically, this means</span></span><br><span class="line"><span class="comment"> * copying any mutable objects that comprise the internal "deep structure"</span></span><br><span class="line"><span class="comment"> * of the object being cloned and replacing the references to these</span></span><br><span class="line"><span class="comment"> * objects with references to the copies.  </span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@code</span> clone&#125; for class &#123;<span class="doctag">@code</span> Object&#125; performs a</span></span><br><span class="line"><span class="comment"> * 该对象没有实现Cloneable接口会抛出CloneNotSupportedException</span></span><br><span class="line"><span class="comment"> * specific cloning operation. First, if the class of this object does</span></span><br><span class="line"><span class="comment"> * not implement the interface &#123;<span class="doctag">@code</span> Cloneable&#125;, then a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> CloneNotSupportedException&#125; is thrown. </span></span><br><span class="line"><span class="comment"> * 字段本身不克隆称为`浅克隆`</span></span><br><span class="line"><span class="comment"> * contents of the fields are not themselves cloned. Thus, this method</span></span><br><span class="line"><span class="comment"> * performs a "shallow copy" of this object, not a "deep copy" operation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 由于Object没有实现Cloneable接口，如果在Object上调用clone方法一样会抛出异常</span></span><br><span class="line"><span class="comment"> * The class &#123;<span class="doctag">@code</span> Object&#125; does not itself implement the interface</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Cloneable&#125;, so calling the &#123;<span class="doctag">@code</span> clone&#125; method on an object</span></span><br><span class="line"><span class="comment"> * whose class is &#123;<span class="doctag">@code</span> Object&#125; will result in throwing an</span></span><br><span class="line"><span class="comment"> * exception at run time.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><ul><li>clone方法用于对象的克隆，一般想要克隆出的对象是<strong>独立</strong>的(与原有的对象是分开的) </li><li>深拷贝指的是该对象的成员变量(如果是可变引用)都应该克隆一份，浅拷贝指的是成员变量没有被克隆一份 </li></ul><h3 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h3><h4 id="源码：-4"><a href="#源码：-4" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用wait方法会让线程处于等待状态。直到调用唤醒方法notify或者指定的时间已过</span></span><br><span class="line"><span class="comment"> * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment"> * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The current thread must own this object's monitor.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method causes the current thread (call it &lt;var&gt;T&lt;/var&gt;) to</span></span><br><span class="line"><span class="comment"> * 处于等待状态，锁会被释放</span></span><br><span class="line"><span class="comment"> * place itself in the wait set for this object and then to relinquish</span></span><br><span class="line"><span class="comment"> * any and all synchronization claims on this object. Thread &lt;var&gt;T&lt;/var&gt;</span></span><br><span class="line"><span class="comment"> * becomes disabled for thread scheduling purposes and lies dormant</span></span><br><span class="line"><span class="comment"> * until one of four things happens:</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 当线程等待时间结束，会回到就绪状态。再次抢到cpu资源时，同步状态与之前调用wait方法</span></span><br><span class="line"><span class="comment"> * 时是一致的！</span></span><br><span class="line"><span class="comment"> * The thread &lt;var&gt;T&lt;/var&gt; is then removed from the wait set for this</span></span><br><span class="line"><span class="comment"> * object and re-enabled for thread scheduling. It then competes in the</span></span><br><span class="line"><span class="comment"> * usual manner with other threads for the right to synchronize on the</span></span><br><span class="line"><span class="comment"> * object; once it has gained control of the object, all its</span></span><br><span class="line"><span class="comment"> * synchronization claims on the object are restored to the status quo</span></span><br><span class="line"><span class="comment"> * ante - that is, to the situation as of the time that the &#123;<span class="doctag">@code</span> wait&#125;</span></span><br><span class="line"><span class="comment"> * method was invoked. Thread &lt;var&gt;T&lt;/var&gt; then returns from the</span></span><br><span class="line"><span class="comment"> * invocation of the &#123;<span class="doctag">@code</span> wait&#125; method. Thus, on return from the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; method, the synchronization state of the object and of</span></span><br><span class="line"><span class="comment"> * thread &#123;<span class="doctag">@code</span> T&#125; is exactly as it was when the &#123;<span class="doctag">@code</span> wait&#125; method</span></span><br><span class="line"><span class="comment"> * was invoked.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 调用wait的线程，如果线程中断会抛出InterruptedException（结束等待状态）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment"> * interrupted&#125; by any thread before or while it is waiting, then an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> InterruptedException&#125; is thrown.  This exception is not</span></span><br><span class="line"><span class="comment"> * thrown until the lock status of this object has been restored as</span></span><br><span class="line"><span class="comment"> * described above.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 只会解锁当前调用wait的对象，而该线程的其他对象是不会解锁的</span></span><br><span class="line"><span class="comment"> * Note that the &#123;<span class="doctag">@code</span> wait&#125; method, as it places the current thread</span></span><br><span class="line"><span class="comment"> * into the wait set for this object, unlocks only this object; any</span></span><br><span class="line"><span class="comment"> * other objects on which the current thread may be synchronized remain</span></span><br><span class="line"><span class="comment"> * locked while the thread waits.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><p>导致<code>wait()</code>的线程被唤醒的有4种情况：</p><ul><li>该线程发生中断</li><li>wait 时间已到</li><li>被notify 唤醒（下面会介绍）</li><li>被notifyAll 唤醒</li></ul><p>调用<code>wait()</code>的线程会释放掉锁！</p><h3 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify()方法"></a>notify()方法</h3><h4 id="源码：-5"><a href="#源码：-5" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `随机`唤醒正在等待的对象（可能不止一个等待对象）</span></span><br><span class="line"><span class="comment"> * Wakes up a single thread that is waiting on this object's</span></span><br><span class="line"><span class="comment"> * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment"> * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment"> * the discretion of the implementation. A thread waits on an object's</span></span><br><span class="line"><span class="comment"> * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> * 3种方式来成为监听器对象的所有者</span></span><br><span class="line"><span class="comment"> * a. 调用该实例的同步方法</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing a synchronized instance method of that object.</span></span><br><span class="line"><span class="comment"> * b. 执行该对象的同步代码块</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;By executing the body of a &#123;<span class="doctag">@code</span> synchronized&#125; statement</span></span><br><span class="line"><span class="comment"> *     that synchronizes on the object.</span></span><br><span class="line"><span class="comment"> * c. 执行对应的静态代码块</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;For objects of type &#123;<span class="doctag">@code</span> Class,&#125; by executing a</span></span><br><span class="line"><span class="comment"> *     synchronized static method of that class.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Only one thread at a time can own an object's monitor.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒所有正在等待队列的线程</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object's monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object's monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h5 id="1、为什么wait和notify在Object方法上？"><a href="#1、为什么wait和notify在Object方法上？" class="headerlink" title="1、为什么wait和notify在Object方法上？"></a>1、为什么wait和notify在Object方法上？</h5><pre><code>因为我们的**锁是对象锁**， 每个对象都可以成为锁。**让当前线程等待某个对象的锁，当然应该通过这个对象来操作了**。  锁对象是**任意**的，所以这些方法必须定义在Object类中 。</code></pre><h5 id="2、sleep和wait有什么区别？"><a href="#2、sleep和wait有什么区别？" class="headerlink" title="2、sleep和wait有什么区别？"></a>2、sleep和wait有什么区别？</h5><pre><code>`Thread.sleep()`与`Object.wait()`二者都可以暂停当前线程，释放CPU控制权。 主要的区别在于`Object.wait()`在释放CPU同时，**释放了对象锁的控制**。  而`Thread.sleep()`没有对锁释放 </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;加油吧！&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                   —– me   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://18wanttobesinger.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP的四次挥手</title>
    <link href="https://18wanttobesinger.github.io/2020/07/01/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://18wanttobesinger.github.io/2020/07/01/TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2020-07-01T08:34:02.000Z</published>
    <updated>2020-07-01T08:44:39.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>第二高峰是乔戈里峰，第三是干城章嘉峰，第四是洛子峰，第五是马卡鲁峰，，，，其实只要尽自己的能力，无论做到第几，都会有人记住的。</p><p>​                                                                                                                                                             —– 网易云热评   </p></blockquote><a id="more"></a><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a><strong>TCP四次挥手</strong></h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/v2-c8b61ed2a249700583b11bc5d16c5711_hd.jpg" alt="v2-c8b61ed2a249700583b11bc5d16c5711_hd"></p><h3 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a><strong>第一次挥手</strong></h3><p>若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：<br>FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。</p><ul><li>PS1：FIN=1表示该报文段是一个连接释放请求。</li><li>PS2：seq=u，u-1是A向B发送的最后一个字节的序号。</li></ul><h3 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a><strong>第二次挥手</strong></h3><p>B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：<br>ACK=1，seq=v，ack=u+1。</p><ul><li>PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。</li><li>PS2：seq=v，v-1是B向A发送的最后一个字节的序号。</li><li>PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。</li></ul><p>A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。</p><p>第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。</p><h3 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a><strong>第三次挥手</strong></h3><p>当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。</p><h3 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a><strong>第四次挥手</strong></h3><p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。</p><h3 id="为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"><a href="#为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？" class="headerlink" title="为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"></a><strong>为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？</strong></h3><p>为了保证B能收到A的确认应答。<br>若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭</p><p>转载： <a href="https://www.zhihu.com/question/24853633/answer/254224088" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633/answer/254224088</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;第二高峰是乔戈里峰，第三是干城章嘉峰，第四是洛子峰，第五是马卡鲁峰，，，，其实只要尽自己的能力，无论做到第几，都会有人记住的。&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                             —– 网易云热评   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="https://18wanttobesinger.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP为什么要三次握手</title>
    <link href="https://18wanttobesinger.github.io/2020/07/01/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://18wanttobesinger.github.io/2020/07/01/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2020-07-01T08:10:45.000Z</published>
    <updated>2020-07-01T08:44:05.172Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>世界上最孤独的鲸鱼 发出的频率是52赫兹 而正常鲸鱼是15至25赫兹 世上没任何鲸鱼能听懂它 它没有鱼群 没有同类 但它没放弃大海 从千里外的太平洋游到大西洋 纵然呐喊二十五年没人应答 但大海有多浩瀚它比别的鲸鱼都清楚。</p><p>​                                                                                                                                                             —– 网易云热评   </p></blockquote><a id="more"></a><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/jisuanjiwangluo.jpg" alt="jisuanjiwangluo"></p><p>起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。<br>服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。</p><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a><strong>第一次握手</strong></h3><p>客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。</p><ul><li>PS1：SYN=1，ACK=0表示该报文段为连接请求报文。</li><li>PS2：x为本次TCP通信的字节流的初始序号。<br>TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。</li></ul><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a><strong>第二次握手</strong></h3><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。<br>该应答发送完成后便进入SYN-RCVD状态。</p><ul><li>PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。</li><li>PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。</li><li>PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。</li></ul><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a><strong>第三次握手</strong></h3><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。<br>该报文段的头部为：ACK=1，seq=x+1，ack=y+1。<br>客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！</p><h3 id="为什么连接建立需要三次握手，而不是两次握手？"><a href="#为什么连接建立需要三次握手，而不是两次握手？" class="headerlink" title="为什么连接建立需要三次握手，而不是两次握手？"></a><strong>为什么连接建立需要三次握手，而不是两次握手？</strong></h3><p>防止失效的连接请求报文段被服务端接收，从而产生错误。</p><p>PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</p><p><span style="background-color: yellow; color:red;">若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</span></p><p>转载：<a href="https://www.zhihu.com/question/24853633/answer/254224088" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633/answer/254224088</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世界上最孤独的鲸鱼 发出的频率是52赫兹 而正常鲸鱼是15至25赫兹 世上没任何鲸鱼能听懂它 它没有鱼群 没有同类 但它没放弃大海 从千里外的太平洋游到大西洋 纵然呐喊二十五年没人应答 但大海有多浩瀚它比别的鲸鱼都清楚。&lt;/p&gt;
&lt;p&gt;​                                                                                                                                                             —– 网易云热评   &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="https://18wanttobesinger.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务概念理解</title>
    <link href="https://18wanttobesinger.github.io/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>https://18wanttobesinger.github.io/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</id>
    <published>2020-06-25T11:26:44.000Z</published>
    <updated>2020-06-25T12:53:21.149Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><pre><code>有的人只要跋山涉水就可以见面。 只有少数人，需要时光机才能见面。 我在等一场意外的死亡 然后笑着去见孟婆                                                                        ----- 网易云热评</code></pre><a id="more"></a><h2 id="1、事务简介"><a href="#1、事务简介" class="headerlink" title="1、事务简介"></a>1、事务简介</h2><p><strong style="background-color: yellow; color: red;">事务，简短的说就是一组操作要么全部完成，要么全部不做，绝不允许只做其中的一部分操作。</strong ><br>比如银行转账，A账号转给B账号1000元，其中包括两个操作A-1000、B+1000，要么这两个操作全部完成，要么全部不做，决不允许只执行其中一个操作（你可以想想想如果A-1000，但是B没有+1000会有什么后果？/斜眼笑/斜眼笑）。</p><h3 id="事务回滚"><a href="#事务回滚" class="headerlink" title="事务回滚:"></a><strong>事务回滚</strong>:</h3><p>当一个事务执行过程中发生了异常、错误，则重新回到最先未开始执行的过程。比如上面那个银行转账过程，假设A-1000操作已经完成，但是在执行B+1000操作时，系统发生位置错误，这时需要回到未执行该转账操作之前的状态，即A、B原来多少钱还是多少钱，一分不能少。</p><h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交:"></a>事务提交:</h3><p>当一个事务执行过程没有发生任何异常、错误，这时我们要保存这个事务的修改。比如上面的银行转账过程，假设A-1000、B+1000操作全部完成，没有出现任何异常、错误，这时需要保存事务执行状态修改（A减少了1000元，B增加了1000元），即事务提交。</p><h2 id="2、事务的特性-ACID"><a href="#2、事务的特性-ACID" class="headerlink" title="2、事务的特性(ACID)"></a>2、事务的特性(ACID)</h2><p>事务具有<strong>四大特性</strong>，如下：</p><p><strong>①、原子性(Atomicity)</strong>：整体 【原子性是指事务包含的所有操作要么全部成功，要么全部失败】<br><strong>②、一致性(Consistency)</strong>：数据 【事务提交后的状态合集称为一致，也就是数据库只包含事务提交的状态】<br><strong>③、隔离性(Isolation)</strong>：并发 【对于任意两个并发的事务A和B，在事务A看来，B要么在A开始之前就已经结束，要么在A结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。】<br><strong>④、持久性(Durability)</strong>：结果 【持久性是指一个事务一旦提交了，就保存到硬盘上，对数据库中的数据的改变就是永久性的】</p><h2 id="3、事务隔离问题"><a href="#3、事务隔离问题" class="headerlink" title="3、事务隔离问题"></a>3、事务隔离问题</h2><p>由于事务可包含多个操作，在多个客户端并发访问过程，可能会发生一个事务只做了一部分操作，此时另外一个事务也开始执行，那么前一个事务的只执行部分操作的中间状态会给第二个事务造成影响。</p><p>再举个转账的例子，比如第一个事务包含A-100000，B+100000两个操作，当它把两个操作执行完后，正准备提交，恰在此时另外一个客户端B开启了第二个事务检查它的余额，此时已经到账了100000元。但是第一个事务对应的哪个顾客发现转错人了，所以执行了事务回滚，那么A、B原来多少钱还是多少钱，此时B客户的事务再查它的余额发现之前的100000元又不见了！</p><h3 id="①、读未提交读-Read-Uncommitted-，也称脏读"><a href="#①、读未提交读-Read-Uncommitted-，也称脏读" class="headerlink" title="①、读未提交读(Read Uncommitted)，也称脏读:"></a><strong>①、读未提交读(Read Uncommitted)，也称脏读</strong>:</h3><p>一个事务读到另一个事务未提交的内容事务B读看到事务A没有提交的内容，比如对A、B账户的修改。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204113244757.jpg" alt="20191204113244757"></p><h3 id="②、不可重复读-Read-Committed"><a href="#②、不可重复读-Read-Committed" class="headerlink" title="②、不可重复读(Read Committed):"></a><strong>②、不可重复读(Read Committed)</strong>:</h3><p>一个事务读到另一个事务已提交的内容（主要是数据更新）此级别解决了读未提交读的问题，即其它事务没有提交的内容对本事务不可见。<br>但是事务B能读到事务A提交的数据更新内容。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204113555818.jpg" alt="20191204113555818"></p><h3 id="③、可重复读-Repeatable-Read-，虚读（幻读）："><a href="#③、可重复读-Repeatable-Read-，虚读（幻读）：" class="headerlink" title="③、可重复读(Repeatable Read)，虚读（幻读）："></a><strong>③、可重复读(Repeatable Read)，虚读（幻读）</strong>：</h3><p>一个事务读到另一个事务已提交的内容（主要是数据插入）此级别解决了读未提交读、不可重复读的问题，事务B能读到事务A提交的数据插入内容。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204114519339.jpg" alt="20191204114519339"></p><h3 id="④、可串行化-Serializable-："><a href="#④、可串行化-Serializable-：" class="headerlink" title="④、可串行化(Serializable)："></a><strong>④、可串行化(Serializable)</strong>：</h3><p>最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204120121806.jpg" alt="20191204120121806"></p><h2 id="4、事务锁"><a href="#4、事务锁" class="headerlink" title="4、事务锁"></a>4、事务锁</h2><p>为了解决事务隔离性问题，引入锁的概念，只有拿到锁的事务才可对数据库进行读写操作\color{red}只有拿到锁的事务才可对数据库进行读写操作只有拿到锁的事务才可对数据库进行读写操作。事务有两种锁，并且有相应的权限。</p><h3 id="①、读锁，也称为共享锁。"><a href="#①、读锁，也称为共享锁。" class="headerlink" title="①、读锁，也称为共享锁。"></a>①、读锁，也称为共享锁。</h3><p>某个事务A拿到该锁时，事务A只能进行读操作，此时其他事务也可以拿到这把锁（共享）。</p><h3 id="②、写锁，也称为排它锁。"><a href="#②、写锁，也称为排它锁。" class="headerlink" title="②、写锁，也称为排它锁。"></a>②、写锁，也称为排它锁。</h3><p>某个事务A拿到该锁时，事务A能进行读、写操作，此时其他事务不能拿到这把锁（排它）。<br>如果某个事务A拿到了读锁，其它事务可以拿到读锁（共享），但是无法获取写锁。<br>如果某个事务A拿到了写锁，其他事务既不能拿到写锁，也拿不到读锁！</p><h3 id="③、锁的粒度"><a href="#③、锁的粒度" class="headerlink" title="③、锁的粒度"></a>③、锁的粒度</h3><p>所谓锁的粒度，就是锁的范围，比如如果锁的范围是一张表，则事务A获取写锁后，只能事务A进行读、写，其他事务全部要靠边站。<br>如果锁的粒度是事务A需要操作的某几行记录，其它记录如果其他事务拿到锁仍然可以读、写。</p><p><strong>一般情况下，锁的粒度越小（锁的范围小），则并发问题解决越好（事务都是并发执行），但是效率越低，因为需要大量的资源来确保各个事务的锁的粒度没有交集、冲突。</strong></p><p><strong>锁的粒度越大（锁的范围大），则并发问题解决越差（其他事务都在等待），但是效率较高，因为不要资源来控制各个事务的锁粒度交集问题。</strong></p><h2 id="5、运用锁解决隔离性问题"><a href="#5、运用锁解决隔离性问题" class="headerlink" title="5、运用锁解决隔离性问题"></a>5、运用锁解决隔离性问题</h2><p>这里演示一下使用写锁解决读未提交读的问题，其它并发问题都可以通过类似的方法解决。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20191204124729517.jpg" alt="20191204124729517"></p><p>原文链接：<a href="https://blog.csdn.net/qq_41855420/article/details/103382189" target="_blank" rel="noopener">https://blog.csdn.net/qq_41855420/article/details/103382189</a></p>]]></content>
    
    <summary type="html">
    
      数据库事务概念
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://18wanttobesinger.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉搜索树详解(附C++代码实现查找、插入、删除操作)</title>
    <link href="https://18wanttobesinger.github.io/2020/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%AF%A6%E8%A7%A3-%E9%99%84C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/"/>
    <id>https://18wanttobesinger.github.io/2020/06/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%AF%A6%E8%A7%A3-%E9%99%84C-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</id>
    <published>2020-06-24T09:43:19.000Z</published>
    <updated>2020-06-25T12:53:39.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多年以后的某个深夜。你会不会突然想起我 然后泪如泉涌 。才发现你曾亏欠我太多。你陪我一程。可我会惦记你一生。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二叉搜索树详解"><a href="#二叉搜索树详解" class="headerlink" title="二叉搜索树详解"></a>二叉搜索树详解</h2><h3 id="一、二叉搜索树简述"><a href="#一、二叉搜索树简述" class="headerlink" title="一、二叉搜索树简述"></a>一、<code>二叉搜索树</code>简述</h3><p>  二叉搜索树大致定义为二叉树的左子树任意节点的值小于根节点的值，右子树任意节点的值大于根节点的值，并且左子树、右子树同样也符合二叉搜索树的定义（递归定义）。中序遍历顺序为左根右，所以二叉搜索树的典型特征是中序遍历序列有序。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041722005953.jpg" alt="2020041722005953"></p><h3 id="二、二叉搜索树相关操作"><a href="#二、二叉搜索树相关操作" class="headerlink" title="二、二叉搜索树相关操作"></a>二、二叉搜索树相关操作</h3><p>  为了能让大家更好的理解二叉搜索树，将提供C++的编码实现。下面是TreeNode结构体实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里额外添加了parent指针，主要是为了访问父节点方便</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 三个指针分别指向父节点、左子树根节点、右子树根节点</span></span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value) : value(value), parent(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> value, TreeNode *parent, TreeNode *left, TreeNode *right) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right =right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color: red;">温馨提示：</span>查找、插入、删除节点三个操作的复杂度依次增加，如果觉得有点压力，请按照顺序依次阅读，稳扎稳打。</p><h4 id="1、二叉搜索树中节点的查找"><a href="#1、二叉搜索树中节点的查找" class="headerlink" title="1、二叉搜索树中节点的查找"></a>1、二叉搜索树中节点的查找</h4><p>  二叉搜索树设计成左 &lt; 根 &lt; 右（中序遍历有序），一个很重要的动机就是快速查找。有过一点算法基础的应该能想到有一种搜索策略非常相似，没错就是二分搜索，每次将target与搜索区间（递增有序）的中间值mid比较，如果target &lt; mid则缩小搜索区间为[left, mid - 1],如果target &gt; mid则缩小搜索区间为[mid + 1, right],否则target == mid。辣么再来看看二叉搜索树中查找的伪代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root 指向二叉搜索树的根，target为需要搜索的值</span><br><span class="line"><span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> root-&gt;value == target</span><br><span class="line">        成功搜索到了 <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> root-&gt;value &gt; target</span><br><span class="line">        <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">        <span class="comment">// 既然root-&gt;value &gt; target，那么只可能出现在左子树，转移root到左子树</span></span><br><span class="line">        root = root-&gt;left</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则root-&gt;value &lt; target</span></span><br><span class="line">        <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">        <span class="comment">// 既然root-&gt;value &lt; target，那么只可能出现在右子树，转移root到右子树</span></span><br><span class="line">        root = root-&gt;right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// root == NULL，二叉搜索树中没有target</span></span><br></pre></td></tr></table></figure><h5 id="C-代码实现："><a href="#C-代码实现：" class="headerlink" title="C++代码实现："></a>C++代码实现：</h5><p>// 在二叉搜索树中查找target，存在返回对应的指针，否则返NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">searchNode</span><span class="params">(TreeNode *root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;value == target) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;value &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然root-&gt;value &gt; target，那么只可能出现在左子树，转移root到左子树</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则root-&gt;value &lt; target</span></span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：root的右子树比root-&gt;value都大，root的左子树比root-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然root-&gt;value &lt; target，那么只可能出现在右子树，转移root到右子树</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、二叉搜索树中节点的插入"><a href="#2、二叉搜索树中节点的插入" class="headerlink" title="2、二叉搜索树中节点的插入"></a>2、二叉搜索树中节点的插入</h4><p>  二叉搜索树中查找充分利用左 &lt; 根 &lt; 右特性，辣么插入也能用上这个特性么？答案是显然的。<br>  首先思考一下，我们插入节点后是不是还需要维持二叉树仍然满足二叉搜索树特性，这是必须的，要不能你的二叉搜索树就变成一次性的了。辣么我们就先要找到它真实应该插入的位置，保证中序遍历为递增有序。下面是删除的伪代码.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">root 指向二叉搜索树的根，value为需要插入的值</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">// 二叉搜索树为空，插入的节点即是根节点</span></span><br><span class="line">    root = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 我们需要找到插入的位置</span></span><br><span class="line">    TreeNode *ptr = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ptr-&gt;value == value</span><br><span class="line">            <span class="comment">// 树中已经存在这个value，不进行插入（这里简化逻辑）</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ptr-&gt;value &gt; value</span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然ptr-&gt;value &gt; value，value只能插入ptr左子树</span></span><br><span class="line">            <span class="keyword">if</span> ptr-&gt;left == <span class="literal">NULL</span></span><br><span class="line">                <span class="comment">// 如果ptr左子树为空，则插入的节点正好做左子树的根</span></span><br><span class="line">                ptr-&gt;left = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则转移到左子树，继续查找</span></span><br><span class="line">                ptr = ptr-&gt;left</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">            <span class="comment">// 既然ptr-&gt;value &lt; value，value只能插入ptr右子树</span></span><br><span class="line">            <span class="keyword">if</span> ptr-&gt;right == <span class="literal">NULL</span></span><br><span class="line">                <span class="comment">// 如果ptr右子树为空，则插入的节点正好做右子树的根</span></span><br><span class="line">                ptr-&gt;right = <span class="keyword">new</span> TreeNode(value)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则转移到右子树，继续查找</span></span><br><span class="line">                ptr = ptr-&gt;right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>C++代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中插入value，如果二叉树中已经存在则不进行插入（简化处理逻辑）</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">searchNode</span><span class="params">(TreeNode *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 二叉搜索树为空，插入的节点即是根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 我们需要找到插入的位置</span></span><br><span class="line">        TreeNode *ptr = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;value == value) &#123;</span><br><span class="line">                <span class="comment">// 树中已经存在这个value，不进行插入（这里简化逻辑）</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;value &gt; value) &#123;</span><br><span class="line">                <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">                <span class="comment">// 既然ptr-&gt;value &gt; value，value只能插入ptr左子树</span></span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果ptr左子树为空，则插入的节点正好做左子树的根</span></span><br><span class="line">                    ptr-&gt;left = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则转移到左子树，继续查找</span></span><br><span class="line">                    ptr = ptr-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意二叉搜索树的特征：ptr的右子树比ptr-&gt;value都大，ptr的左子树比ptr-&gt;value都小</span></span><br><span class="line">                <span class="comment">// 既然ptr-&gt;value &lt; value，value只能插入ptr右子树</span></span><br><span class="line">                <span class="keyword">if</span> (ptr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果ptr右子树为空，则插入的节点正好做右子树的根</span></span><br><span class="line">                    ptr-&gt;right = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则转移到右子树，继续查找</span></span><br><span class="line">                    ptr = ptr-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、二叉搜索树中节点的删除"><a href="#3、二叉搜索树中节点的删除" class="headerlink" title="3、二叉搜索树中节点的删除"></a>3、二叉搜索树中节点的删除</h4><p>  在二叉搜索树删除节点，首先我们应该在树中查找到这个节点的位置吧，然后将其移除，并且移除后我们需要进行调整，使其任然满足二叉搜索树。这个删除操作可以分成好几种情况，需要分别讨论。</p><h5 id="①、删除叶节点"><a href="#①、删除叶节点" class="headerlink" title="①、删除叶节点"></a>①、删除叶节点</h5><p>  删除叶节点，只要将其移除即可，不需要进行任何调整操作。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041808272493.jpg" alt="2020041808272493"></p><h5 id="②、删除非叶节点"><a href="#②、删除非叶节点" class="headerlink" title="②、删除非叶节点"></a>②、删除非叶节点</h5><p>  删除非叶节点可以细分为两种，第一种是删除有右子树的节点，删除节点后需要将右子树中序遍历第一个节点填充到删除节点A位置（为什么选右子树中序遍历第一个节点？因为整棵树的中序遍历序列中，节点A的下一个节点就是其右子树中序遍历的第一个节点）。<br>  右子树中序遍历第一个节点为某个节点的左子节点，直接将最左的左子节点填补到已删除节点的位置。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020041808351744.jpg" alt="2020041808351744"></p><h5 id="a、删除节点有右子树"><a href="#a、删除节点有右子树" class="headerlink" title="a、删除节点有右子树"></a>a、删除节点有右子树</h5><p>  右子树中序遍历序列中的第一个节点为某个没有左子节点的节点B。将节点B填入已删除节点的位置，并且将节点B的右子树置于节点B的位置。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418084409899.jpg" alt="20200418084409899"></p><h5 id="b、删除节点没有右子树"><a href="#b、删除节点没有右子树" class="headerlink" title="b、删除节点没有右子树"></a>b、删除节点没有右子树</h5><p>  第二种是删除没有右子树的节点A，此时寻找整颗二叉树中序遍历中节点A的下一个节点，稍微复杂一点，需要利用parent指针。找到远祖父节点B，并且使得节点A在远祖父节点B的左子树中！远祖父节点B.value替换到节点A.value后，它自己也需要它的下一个节点来填充。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418090738723.jpg" alt="20200418090738723"><br>  <span style="color: red">备注：</span>其实根本不需要进行删除操作，只要寻找到这个节点中序遍历序列的下一个节点，然后直接替换即可。<br>C++代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉搜索树中插入value，如果二叉树中已经存在则不进行插入（简化处理逻辑）</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">deleteNode</span><span class="params">(TreeNode *root, TreeNode *targetPtr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetPtr == <span class="literal">NULL</span> || root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == targetPtr &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 一、删除的是根节点，并且根节点没有右子树</span></span><br><span class="line">        <span class="comment">// 处理：切断targetPtr与左子树的关联，返回左子树，释放targetPtr</span></span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetPtr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> targetPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (targetPtr-&gt;left == targetPtr-&gt;right) &#123;</span><br><span class="line">        <span class="comment">// 二、删除的叶节点</span></span><br><span class="line">        <span class="comment">// targetPtr-&gt;left == targetPtr-&gt;right,只能是同时为NULL</span></span><br><span class="line">        <span class="comment">// 操作：切断parent与targetPtr的关联，返回root，释放targetPtr</span></span><br><span class="line">        <span class="keyword">if</span> (targetPtr-&gt;parent-&gt;left == targetPtr) &#123;</span><br><span class="line">            targetPtr-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetPtr-&gt;parent-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切断targetPtr 与targetPtr-&gt;parent的关联</span></span><br><span class="line">        targetPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> targetPtr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetPtr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 三、删除节点右子树为空      需要找到远祖父节点</span></span><br><span class="line">        TreeNode *pParent = targetPtr;</span><br><span class="line">        <span class="comment">// 祖父节点B，并且使得节点targetPtr在远祖父节点B的左子树</span></span><br><span class="line">        <span class="keyword">while</span> (pParent-&gt;parent != <span class="literal">NULL</span> &amp;&amp; pParent-&gt;parent-&gt;right == pParent) &#123;</span><br><span class="line">            pParent = pParent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pParent-&gt;parent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果targetPtr不存在一个远祖父节点B，使得leftPtr在远祖父B的左子树</span></span><br><span class="line">            <span class="comment">// 操作：只能删除这个节点，并且把左子树放到当前节点的位置</span></span><br><span class="line">            targetPtr-&gt;parent-&gt;right = targetPtr-&gt;left;</span><br><span class="line">            targetPtr-&gt;left-&gt;parent = targetPtr-&gt;parent;</span><br><span class="line">            <span class="comment">// 切断targetPtr与parent、left的关系</span></span><br><span class="line">            targetPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">            targetPtr-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> targetPtr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则pParent-&gt;parent-&gt;value替换targetPtr-&gt;value，再删除pParent-&gt;parent（递归）</span></span><br><span class="line">            targetPtr-&gt;value = pParent-&gt;parent-&gt;value;</span><br><span class="line">            root = deleteNode(root, pParent-&gt;parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 四、删除节点存在右子树，直接在右子树寻找中序遍历的第一个节点</span></span><br><span class="line">        TreeNode * leftPtr = targetPtr-&gt;right;</span><br><span class="line">        <span class="comment">// 一直往left寻找</span></span><br><span class="line">        <span class="keyword">while</span> (leftPtr-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            leftPtr = leftPtr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将leftPtr-&gt;value替换到targetPtr-&gt;value</span></span><br><span class="line">        targetPtr-&gt;value = leftPtr-&gt;value;</span><br><span class="line">        <span class="comment">// targetPtr-&gt;right就是leftPtr</span></span><br><span class="line">        <span class="keyword">if</span> (targetPtr-&gt;right == leftPtr) &#123;</span><br><span class="line">            <span class="comment">// 将targetPtr-&gt;right指向leftPtr右子树</span></span><br><span class="line">            targetPtr-&gt;right = leftPtr-&gt;right;</span><br><span class="line">            <span class="comment">// 如果targetPtr-&gt;right ！= NULL，还需要设置parent</span></span><br><span class="line">            <span class="keyword">if</span> (leftPtr-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                leftPtr-&gt;right-&gt;parent = targetPtr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则leftPtr-&gt;parent与leftPtr切断关系</span></span><br><span class="line">            leftPtr-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将leftPtr于其parent切断关系并释放</span></span><br><span class="line">        leftPtr-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> leftPtr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">deleteNodeByValue</span><span class="params">(TreeNode *root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先查找value所在的位置</span></span><br><span class="line">    TreeNode *targetPtr = searchNode(root, value);</span><br><span class="line">    <span class="keyword">if</span> (targetPtr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// value都没找到还删除啥...</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deleteNode(root, targetPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、思考与总结"><a href="#三、思考与总结" class="headerlink" title="三、思考与总结"></a>三、思考与总结</h3><p>  可以看出二叉搜索树的查找、插入还是比较简单的，删除稍微复杂一点。不过二叉搜索树可能存在退化成链表的缺陷，比如给你一个本来递增有序的序列让你插入到一颗空二叉搜索树中，这时就退化成链表了。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200418111144946.jpg" alt="20200418111144946"><br>  因此我们需要将二叉搜索树增加平衡的特性，即AVL树或红黑树。<br>原文链接：<a href="https://hestyle.blog.csdn.net/article/details/105595528" target="_blank" rel="noopener">https://hestyle.blog.csdn.net/article/details/105595528</a></p>]]></content>
    
    <summary type="html">
    
      数据结构之二叉搜索树
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://18wanttobesinger.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://18wanttobesinger.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉树、AVL树、红黑树、Trie树、B树、B+树、B*树浅析</title>
    <link href="https://18wanttobesinger.github.io/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81Trie%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E6%B5%85%E6%9E%90/"/>
    <id>https://18wanttobesinger.github.io/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81AVL%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E3%80%81Trie%E6%A0%91%E3%80%81B%E6%A0%91%E3%80%81B-%E6%A0%91%E3%80%81B-%E6%A0%91%E6%B5%85%E6%9E%90/</id>
    <published>2020-06-23T10:31:53.000Z</published>
    <updated>2020-06-24T06:24:27.444Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">夏天迟暮的霞光，正如皆是笑意的你。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="数据结构之二叉树、AVL树、红黑树、Trie树、B树、B-树、B-树浅析"><a href="#数据结构之二叉树、AVL树、红黑树、Trie树、B树、B-树、B-树浅析" class="headerlink" title="数据结构之二叉树、AVL树、红黑树、Trie树、B树、B+树、B*树浅析"></a>数据结构之二叉树、AVL树、红黑树、Trie树、B树、B+树、B*树浅析</h2><p>树，作为五大经典数据结构之一，有许多运用场景，比如MySQL数据库的B+树（数据结构的重要性不用强调了吧）。下面将对二叉树、红黑树、B树、B+树等树结构进行一些概念区分与总结，此篇博客适合新手、有一定数据结构基础的小伙伴。</p><h3 id="一、树的划分"><a href="#一、树的划分" class="headerlink" title="一、树的划分"></a>一、树的划分</h3><p>  根据子节点的个数可以划分成N叉树（一般N ≥ 2），N叉树拥有的特征是每个节点至多有N个子节点。</p><p>比如，N = 2时，称为二叉树，每个节点至多只有2个节点。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407082832601.jpg" alt="20200407082832601"><br>比如，N = 3时，称为三叉树，每个节点至多只有3个节点。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407083131618.jpg" alt="20200407083131618"><br><span style="color: red;">注意：</span>特别的当N = 1时，此时是”一叉树”（一般没有这个概念，这只是我个人这么叫），其实”一叉树”就是链表。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407083801385.jpg" alt="20200407083801385"><br>还有一点，树的定义并不是很严谨，因为它强调的是每个节点至多有N个子节点，那么，如果某N叉树的每个节点都至多只有N - 1个节点，那么它也可以称为N - 1叉树，反过来，它也可以称为K叉树（K ≥ N）。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407084732264.jpg" alt="20200407084732264"></p><h3 id="二、二叉树（重点）"><a href="#二、二叉树（重点）" class="headerlink" title="二、二叉树（重点）"></a>二、二叉树（重点）</h3><p>  由上面的概念可知，当N = 2时，称为二叉树。在二叉树还有左子树、右子树、左孩子、右孩子的概念。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407085832323.jpg" alt="20200407085832323"></p><h4 id="1、二叉树的遍历方式"><a href="#1、二叉树的遍历方式" class="headerlink" title="1、二叉树的遍历方式"></a>1、二叉树的遍历方式</h4><p>  由二叉树的结构可知，每个节点都是由左子节点、右子节点、父节点构成（有些节点的左或右子节点为空，但不能说它没有左或右子节点）。根据节点的访问顺序可排列出 左父右、左右父、父左右、右父左、右左父、父右左6种情况，但是一般要求左子节点比右子节点先访问，因此剩下 左父右、左右父、父左右三种情况。</p><h5 id="①、中序遍历（左父右）"><a href="#①、中序遍历（左父右）" class="headerlink" title="①、中序遍历（左父右）"></a>①、中序遍历（左父右）</h5><p>  对于每个节点，先访问它的左子树，再访问本节点，最后访问它的右子树，对于左子树、右子树也符合这个规定（递归定义）。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407091405102.jpg" alt="20200407091405102"></p><h5 id="②、后序遍历（左右父）"><a href="#②、后序遍历（左右父）" class="headerlink" title="②、后序遍历（左右父）"></a>②、后序遍历（左右父）</h5><p>  对于每个节点，先访问它的左子树，再访问它的右子树，最后访问本节点，对于左子树、右子树也符合这个规定（递归定义）。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407093217486.jpg" alt="20200407093217486"></p><h5 id="③、前序遍历（父左右）"><a href="#③、前序遍历（父左右）" class="headerlink" title="③、前序遍历（父左右）"></a>③、前序遍历（父左右）</h5><p>  对于每个节点，先访问本节点，再访问它的左子树，最后访问它的右子树，对于左子树、右子树也符合这个规定（递归定义）。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020040709330051.jpg" alt="2020040709330051"><br><span style="color: red;">注：</span>其实还有一种遍历方式，层次遍历，即按层访问二叉树。</p><h4 id="2、二叉树的特例"><a href="#2、二叉树的特例" class="headerlink" title="2、二叉树的特例"></a>2、二叉树的特例</h4><h5 id="①、二叉搜索树"><a href="#①、二叉搜索树" class="headerlink" title="①、二叉搜索树"></a>①、二叉搜索树</h5><p>  二叉搜索树的定义是对于某二叉树的每个节点b，它的左子树A的所有节点的值都小于节点b的值，它的右子树B的所有节点的值都大于节点b的值，并且左子树A、右子树B同样符合这个定义（递归定义）。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407152634442.jpg" alt="20200407152634442"></p><p>对于值为10的节点，左子树的所有节点的值 &lt; 10，右子树的所有节点的值 &gt; 10，并且左子树、右子树中的所有节点同样 左 &lt; 父 &lt; 右 的定义。</p><p><span style="color: red;">表现特征：</span>二叉搜索树的定义简化一下就是左 &lt; 父 &lt; 右规则，还记先前介绍的中序遍历么，是不是发现了什么，中序遍历顺序不也是如此么。其实二叉搜索树的变现特征就是中序遍历得到的序列递增。（可能会有小伙伴问，为什么要引入这个特性呢？答案是查找方便。如果我们需要你在二叉树中查target = 7这个值是否存在，从根节点入手，如果target = root，查找成功，停止查找；若target &lt; root，转到左子树，否则target &gt; root，转到右子树。）</p><h5 id="②、平衡二叉树"><a href="#②、平衡二叉树" class="headerlink" title="②、平衡二叉树"></a>②、平衡二叉树</h5><p>  平衡二叉树定义是某二叉树的左、右两个子树的 高度差的绝对值不超过1，并且左、右两个子树也都是一棵平衡二叉树（递归定义）。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/2020040715495833.jpg" alt="2020040715495833"></p><p>那么问题来了，为啥又要引入平衡这个概念呢？<br>可以看出平衡主要是限制树的整体高度，将左、右子树的高度差缩减到1之内。</p><h5 id="③、平衡二叉搜索树-AVL树、红黑树"><a href="#③、平衡二叉搜索树-AVL树、红黑树" class="headerlink" title="③、平衡二叉搜索树(AVL树、红黑树)"></a>③、平衡二叉搜索树(AVL树、红黑树)</h5><p>  平衡二叉搜索树，顾名思义，是二叉树同时满足平衡二叉树以及二叉搜索树的定义，即二叉树不但中序遍历为递增序列，并且树还平衡。</p><p>问题又来了，引入平衡二叉搜索树又是为啥目的捏？看完下图你就明白了。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407191645970.jpg" alt="20200407191645970"></p><p>上图左边的树是平衡二叉搜索树，右边是一颗非平衡的二叉搜索树。如果给你这两颗树，让你搜索target = 15，你会选择那一颗？你肯定会选择左边的吧，因为它看起来更矮一些，根据上面介绍的二叉搜索树的查找规则，我们每次都大概能排除掉剩余节点中的一半（最优的情况下，搜索复杂度为log2n）。</p><h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，其实它就是上面介绍的平衡二叉搜索树。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>由于平衡二叉搜索树的定义比较苛刻，实际过程中生成并维持一颗平衡二叉搜索树是比较复杂的，而红黑树放宽了平衡条件的限制，引入弱平衡的概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">红黑树的定义：</span><br><span class="line">1.节点是红色或黑色。</span><br><span class="line">2.根是黑色。</span><br><span class="line">3.所有叶子都是黑色（叶子是NIL节点）。</span><br><span class="line">4.每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</span><br><span class="line">5.从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200425164845697.jpg" alt="20200425164845697"></p><h3 id="三、多叉树"><a href="#三、多叉树" class="headerlink" title="三、多叉树"></a>三、多叉树</h3><p>  根据先前树的划分，对于多叉树也有父节点、子节点、兄弟节点的概念。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407164449689.jpg" alt="20200407164449689"></p><h4 id="1、Trie树（前缀树）"><a href="#1、Trie树（前缀树）" class="headerlink" title="1、Trie树（前缀树）"></a>1、Trie树（前缀树）</h4><p>  Trie树其实就是前缀树，运用于大量字符串的存放。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407165308310.jpg" alt="20200407165308310"></p><p>其实Trie树的关键就是把每个字符串的前缀进行合并，也称前缀树。</p><p><span style="color: red;">注意：</span>在Trie树中，每个节点的子节点可能有26个，因为对于每个字符串的下一个字符可能是a ~ z中的任意字母。并且26个子节点需要保持有序。</p><h4 id="2、B树"><a href="#2、B树" class="headerlink" title="2、B树"></a>2、B树</h4><p>  B树是多路搜索树，对于树中的非叶子节点，如果放了m个关键字，就同时需要放m+1个指向子节点的指针，根节点的子节点数为[2, N]，其他节点的子节点数为[N/2,N]。并且所有关键字在整颗树中只出现一次，非叶子结点可以命中所有叶子结点位于同一层。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407170643924.jpg" alt="20200407170643924"></p><h4 id="3、B-树"><a href="#3、B-树" class="headerlink" title="3、B+树"></a>3、B+树</h4><p>  B+树是在B树上进行改造升级，把叶子节点层串成一个链表，并且父节点修改为每个子节点关键字序列的最大值。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407191943282.jpg" alt="20200407191943282"></p><p>MySQL数据库的表结构底层数据存储用的就是B+树。</p><h4 id="4、B-树"><a href="#4、B-树" class="headerlink" title="4、B*树"></a>4、B*树</h4><p>  B*树是在B+树的基础上再次进行升级，把非叶子节点层也用串成链表。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/18WantTobeSinger/PictureBed/20200407192112176.jpg" alt="20200407192112176"></p><p>个人总结：AVL树、红黑树都是二叉树，并且是平衡二叉搜索树，Trie树、B树、B+树、B*树都是多叉树，并且是多叉搜索树。一般编程算法题中，二叉树使用的较多。对于多叉树，除非是专业的数据结构设计人员，用的是比较少的，但是这并不说明多叉树没有用武之地，文章中多次提及MySQL数据库中的表中的数据就是用B+树存储。（本博客多叉树用的篇幅很少，但是B树、B+树等多叉树的插入、删除节点是比较复杂的，可能会涉及到节点的拆分、合并，但是博主能力有限啊）</p><p>以上就是数据结构之二叉树、红黑树、B树、B+树、Trie树浅析的主要内容。</p>]]></content>
    
    <summary type="html">
    
      数据结构之树
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://18wanttobesinger.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://18wanttobesinger.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>基本计算器</title>
    <link href="https://18wanttobesinger.github.io/2020/06/21/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>https://18wanttobesinger.github.io/2020/06/21/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</id>
    <published>2020-06-21T12:34:22.000Z</published>
    <updated>2020-06-22T00:00:20.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我真的接受不了有很多男闺蜜的女孩子。</span><br><span class="line"></span><br><span class="line">                                                                    ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器</h2><p>本文要使用栈结构来实现一个可以 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>以及包含<code>()</code>的运算。所给的表达式都是有效的（本文代码并未实现验证表达式是否合法），表达式中的数都是<strong>非负数</strong>，可包含<strong>空格</strong>。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: "1 + 1"</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: " 2-1 + 2 "</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: "(3+2)*2"</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h3 id="以下代码可解决LeetCode题目："><a href="#以下代码可解决LeetCode题目：" class="headerlink" title="以下代码可解决LeetCode题目："></a>以下代码可解决LeetCode题目：</h3><ul><li><p><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></p></li><li><p><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></p></li></ul><h3 id="整体代码思路："><a href="#整体代码思路：" class="headerlink" title="整体代码思路："></a>整体代码思路：</h3><p>以：<code>2 * (10 - 3) / 5</code>为例: </p><p>1、先给第一个数字加一个默认符号<code>+</code>，变成<code>+ 2 * (10 - 3) / 5</code>。 </p><p>2、把一个运算符和数字组合成一对儿，也就是三对儿<code>+2</code>，<code>(10 - 3)</code>, <code>5</code>，把它们转化成数字，然后放到一个栈中。 </p><p>3、当遇到<code>*</code>, <code>/</code>符号时, 取出栈中的数字和当前的数字，计算结果再存入栈中。</p><p>4、当遇到<code>(</code>，将<code>(</code>后面的部分运用递归调用本函数，遇到<code>)</code>就跳出循环，并将<code>(...)</code>中的结果存入栈中，计算结果返回。</p><p>5、 将栈中所有的数字求和，就是原算式的结果。 </p><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; length ) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">            num = num * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            num = calculate(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!Character.isDigit(ch) &amp;&amp; ch != <span class="string">' '</span>) || i == length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre;</span><br><span class="line">            <span class="keyword">switch</span> (sign) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    stack.add(num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    stack.add(-num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 只要拿出前一个数字做对应运算即可</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    pre = stack.pop();</span><br><span class="line">                    stack.add(pre * num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    pre = stack.pop();</span><br><span class="line">                    stack.add(pre / num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sign = ch;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">')'</span>) <span class="keyword">break</span>;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n: stack) &#123;</span><br><span class="line">        res += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加油！！！🧐"><a href="#加油！！！🧐" class="headerlink" title="加油！！！🧐"></a>加油！！！🧐</h3>]]></content>
    
    <summary type="html">
    
      使用Java语言设计一个计算器算法
    
    </summary>
    
    
    
      <category term="算法" scheme="https://18wanttobesinger.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://18wanttobesinger.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>倒数第N个字符串</title>
    <link href="https://18wanttobesinger.github.io/2020/06/21/%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://18wanttobesinger.github.io/2020/06/21/%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-06-21T03:34:10.000Z</published>
    <updated>2020-06-22T00:02:19.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"姑娘有心事？"书生抿嘴品茶问到。 </span><br><span class="line">少女："公子与王公子可是熟识？" </span><br><span class="line">书生："世交。" </span><br><span class="line">少女："那下次你与他一起来吧。" </span><br><span class="line">书生："他不喜品茶。" </span><br><span class="line">少女："没关系，那他喜欢什么，我可以慢慢学。" </span><br><span class="line">书生："他喜欢我。"</span><br><span class="line"></span><br><span class="line">                                                                    ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="倒数第N个字符串"><a href="#倒数第N个字符串" class="headerlink" title="倒数第N个字符串"></a>倒数第N个字符串</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为 { aaa, aab, aac, …, aaz, aba, abb, …, abz, …, zzz }。这个序列的倒数第27个字符串就是 zyz。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出两个正整数 L（2 ≤ L ≤ 6）和 N（≤105）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7417</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pat</span><br></pre></td></tr></table></figure><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;L, &amp;N);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">26</span>, L) - N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num[L];</span><br><span class="line">    <span class="keyword">int</span> ind = L;</span><br><span class="line">    <span class="keyword">while</span> (L -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num[L] = n % <span class="number">26</span>;</span><br><span class="line">        n = n / <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ind; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, num[i] + <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继续加油吧🤪"><a href="#继续加油吧🤪" class="headerlink" title="继续加油吧🤪"></a>继续加油吧🤪</h3>]]></content>
    
    <summary type="html">
    
      倒数第N个字符串
    
    </summary>
    
    
    
      <category term="算法" scheme="https://18wanttobesinger.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>倒数第N个字符串</title>
    <link href="https://18wanttobesinger.github.io/2020/06/21/hello-world/"/>
    <id>https://18wanttobesinger.github.io/2020/06/21/hello-world/</id>
    <published>2020-06-21T03:34:10.000Z</published>
    <updated>2020-06-21T04:32:48.364Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"姑娘有心事？"书生抿嘴品茶问到。 </span><br><span class="line">少女："公子与王公子可是熟识？" </span><br><span class="line">书生："世交。" </span><br><span class="line">少女："那下次你与他一起来吧。" </span><br><span class="line">书生："他不喜品茶。" </span><br><span class="line">少女："没关系，那他喜欢什么，我可以慢慢学。" </span><br><span class="line">书生："他喜欢我。"</span><br><span class="line"></span><br><span class="line">                                                                    ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="倒数第N个字符串"><a href="#倒数第N个字符串" class="headerlink" title="倒数第N个字符串"></a>倒数第N个字符串</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为 { aaa, aab, aac, …, aaz, aba, abb, …, abz, …, zzz }。这个序列的倒数第27个字符串就是 zyz。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出两个正整数 L（2 ≤ L ≤ 6）和 N（≤105）。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7417</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pat</span><br></pre></td></tr></table></figure><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;L, &amp;N);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">26</span>, L) - N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num[L];</span><br><span class="line">    <span class="keyword">int</span> ind = L;</span><br><span class="line">    <span class="keyword">while</span> (L -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num[L] = n % <span class="number">26</span>;</span><br><span class="line">        n = n / <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ind; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, num[i] + <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继续加油吧🤪"><a href="#继续加油吧🤪" class="headerlink" title="继续加油吧🤪"></a>继续加油吧🤪</h3>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&quot;姑娘有心事？&quot;书生抿嘴品茶问到。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;少女：&quot;公子与王公子可是熟识？&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;书生：&quot;世交。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;少女：&quot;那下次你与他一起来吧。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;书生：&quot;他不喜品茶。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;少女：&quot;没关系，那他喜欢什么，我可以慢慢学。&quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;书生：&quot;他喜欢我。&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                    ----- 网易云热评&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="https://18wanttobesinger.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>天梯赛座位分配</title>
    <link href="https://18wanttobesinger.github.io/2020/06/20/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/"/>
    <id>https://18wanttobesinger.github.io/2020/06/20/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D/</id>
    <published>2020-06-20T09:22:38.000Z</published>
    <updated>2020-06-22T00:02:49.273Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">倒啤酒时上面总有一层泡沫，看似庞大但抿一口全是空气。感情亦是如此。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>天梯赛每年有大量参赛队员，要保证同一所学校的所有队员都不能相邻，分配座位就成为一件比较麻烦的事情。为此我们制定如下策略：假设某赛场有 N 所学校参赛，第 i 所学校有 M[i] 支队伍，每队 10 位参赛选手。令每校选手排成一列纵队，第 i+1 队的选手排在第 i 队选手之后。从第 1 所学校开始，各校的第 1 位队员顺次入座，然后是各校的第 2 位队员…… 以此类推。如果最后只剩下 1 所学校的队伍还没有分配座位，则需要安排他们的队员隔位就坐。本题就要求你编写程序，自动为各校生成队员的座位号，从 1 开始编号。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出参赛的高校数 N （不超过100的正整数）；第二行给出 N 个不超过10的正整数，其中第 i 个数对应第 i 所高校的参赛队伍数，数字间以空格分隔。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>从第 1 所高校的第 1 支队伍开始，顺次输出队员的座位号。每队占一行，座位号间以 1 个空格分隔，行首尾不得有多余空格。另外，每所高校的第一行按“#X”输出该校的编号X，从 1 开始。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">1 4 7 10 13 16 19 22 25 28</span><br><span class="line">31 34 37 40 43 46 49 52 55 58</span><br><span class="line">61 63 65 67 69 71 73 75 77 79</span><br><span class="line">#2</span><br><span class="line">2 5 8 11 14 17 20 23 26 29</span><br><span class="line">32 35 38 41 44 47 50 53 56 59</span><br><span class="line">62 64 66 68 70 72 74 76 78 80</span><br><span class="line">82 84 86 88 90 92 94 96 98 100</span><br><span class="line">#3</span><br><span class="line">3 6 9 12 15 18 21 24 27 30</span><br><span class="line">33 36 39 42 45 48 51 54 57 60</span><br></pre></td></tr></table></figure><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> M[n];</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> maxM = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M[i]);</span><br><span class="line">        <span class="keyword">if</span> (M[i] &gt; maxM) maxM = M[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>, preM = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> * maxM; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; M[j] * <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (preM == j) </span><br><span class="line">                    num ++;</span><br><span class="line">                A[j][i] = num ++;</span><br><span class="line">                preM = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"#%d\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span> * M[i]; j ++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, A[i][j], (j + <span class="number">1</span>) % <span class="number">10</span> == <span class="number">0</span> ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="今天额外的累😭"><a href="#今天额外的累😭" class="headerlink" title="今天额外的累😭"></a>今天额外的累😭</h3>]]></content>
    
    <summary type="html">
    
      天梯赛座位分配
    
    </summary>
    
    
    
      <category term="算法" scheme="https://18wanttobesinger.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整除光棍</title>
    <link href="https://18wanttobesinger.github.io/2020/06/20/%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/"/>
    <id>https://18wanttobesinger.github.io/2020/06/20/%E6%95%B4%E9%99%A4%E5%85%89%E6%A3%8D/</id>
    <published>2020-06-20T05:16:57.000Z</published>
    <updated>2020-06-22T00:03:10.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">屏幕前的女孩 我不认识你 但我祝你坚强 祝你可爱 祝你善良 一生向前永不回头 加油哟！</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数<code>x</code>，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字<code>s</code>，表示<code>x</code>乘以<code>s</code>是一个光棍，第二个数字<code>n</code>是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p><p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除<code>x</code>为止。但难点在于，<code>s</code>可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p> 输入在一行中给出一个不以5结尾的正奇数<code>x</code>（&lt;1000）。 </p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p> 在一行中输出相应的最小的<code>s</code>和<code>n</code>，其间以1个空格分隔。 </p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3584229390681</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="程序代码："><a href="#程序代码：" class="headerlink" title="程序代码："></a>程序代码：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, s = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">5</span> == <span class="number">0</span> || x % <span class="number">2</span> == <span class="number">0</span> || x &gt;= <span class="number">1000</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x &gt; s) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, s / x);</span><br><span class="line">        s %= x;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        s = s * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        n ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="收藏一下本站吧！😁"><a href="#收藏一下本站吧！😁" class="headerlink" title="收藏一下本站吧！😁"></a>收藏一下本站吧！😁</h3>]]></content>
    
    <summary type="html">
    
      整除光棍
    
    </summary>
    
    
    
      <category term="算法" scheme="https://18wanttobesinger.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://18wanttobesinger.github.io/2020/06/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://18wanttobesinger.github.io/2020/06/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-17T14:04:16.000Z</published>
    <updated>2020-06-17T15:08:49.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">太过热情总是不被珍惜。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><hr><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="“对象性能”模式"><a href="#“对象性能”模式" class="headerlink" title="“对象性能”模式"></a>“对象性能”模式</h3><ul><li>面向对象很好解决了 “抽象” 的问题，但是必不可免地要付出一定的代价。对于同常来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。</li><li>典型模式<ul><li>Singleton</li><li>Flyweight</li></ul></li></ul><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>在软件系统中,经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例,才能确保它们的逻辑正确性、以及良好的效率。</li><li>如何绕过常规的构造器,提供种机制来保证一个类只有一个实例？</li><li>这应该是类设计者的责任,而不是使用者的责任。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实现一个只能创建一个对象的类。</p><p><strong>懒汉模式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instace=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁，安全但是锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.store(tmp, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Java中可以实现单例模式的方法有：饿汉、懒汉、静态内部类等</em></p><hr><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类仅有一个实例 ,并提供一个该实例的全局访问点。</p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul><li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li><li>Singleton模式一般不要支持拷贝构造函数和Clone接口 ，因为这有可能导致多个对象实例,与Singleton模式的初衷违背。</li><li>如何实现多线程环境下安全的Singleton ?注意对双检查锁的正确实现。.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://18wanttobesinger.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://18wanttobesinger.github.io/2020/06/16/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://18wanttobesinger.github.io/2020/06/16/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-16T08:49:23.000Z</published>
    <updated>2020-06-17T22:31:58.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">谁的新欢不是别人的旧爱？又有多少初恋可以到白头？</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>在软件系统中，有时候面临着<strong>“一个复杂对象”</strong>的创建工作，其通常由<strong>各个部分的子对象</strong>用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在 一起的算法却<strong>相对稳定</strong>。 </li><li>如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂 对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不 随着需求改变而改变？ </li></ul><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p> 将一个复杂对象的构建与其表示相分离，使得同样的构建过 程(稳定)可以创建不同的表示(变化)。 </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>构建一个房子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class House&#123;</span><br><span class="line">public:</span><br><span class="line">    void Init() &#123;</span><br><span class="line">        this-&gt;BuildPart1();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; i++)&#123;</span><br><span class="line">            this-&gt;BuildPart2();</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag&#x3D;this-&gt;BuildPart3();</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            this-&gt;BuildPart4();</span><br><span class="line">        &#125;</span><br><span class="line">        this-&gt;BuildPart5();</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    virtual void BuildPart1()&#x3D;0;</span><br><span class="line">    virtual void BuildPart2()&#x3D;0;</span><br><span class="line">    virtual void BuildPart3()&#x3D;0;</span><br><span class="line">    virtual void BuildPart4()&#x3D;0;</span><br><span class="line">    virtual void BuildPart5()&#x3D;0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来构建各种不同样式的房子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouse</span>:</span> <span class="keyword">public</span> House&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如何使用？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    House* sHouse = <span class="keyword">new</span> StoneHouse();</span><br><span class="line">    sHouse-&gt;Init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>&#123;</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">House* <span class="title">GetResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pHouse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~HouseBuilder()&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    House* pHouse;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouse</span>:</span> <span class="keyword">public</span> House&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouseBuilder</span>:</span> <span class="keyword">public</span> HouseBuilder&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//pHouse-&gt;Part1 = ...;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuildPart5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HouseBuilder* pHouseBuilder;</span><br><span class="line">    </span><br><span class="line">    HouseDirector(HouseBuilder* pHouseBuilder)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pHouseBuilder=pHouseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">House* <span class="title">Construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart1();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart2();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag=pHouseBuilder-&gt;BuildPart3();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            pHouseBuilder-&gt;BuildPart4();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pHouseBuilder-&gt;BuildPart5();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pHouseBuilder-&gt;GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul><li>Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中 “分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。 </li><li>变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对 象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建 算法”的需求变动。 </li><li>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别 （C++ vs. C#) 。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;谁的新欢不是别人的旧爱？又有多少初恋可以到白头？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                        ----- 网易云热评&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://18wanttobesinger.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>重新排列数组</title>
    <link href="https://18wanttobesinger.github.io/2020/06/16/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/"/>
    <id>https://18wanttobesinger.github.io/2020/06/16/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</id>
    <published>2020-06-16T08:25:48.000Z</published>
    <updated>2020-06-22T00:08:31.505Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">刚才在街上看见一个人很像你，我瞬间特别紧张，渴望是你又害怕是你，直到走近看清不是你，我庆幸不是你，</span><br><span class="line">又遗憾不是你。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1470-重新排列数组"><a href="#1470-重新排列数组" class="headerlink" title="1470. 重新排列数组"></a><a href="https://leetcode-cn.com/problems/shuffle-the-array/" target="_blank" rel="noopener">1470. 重新排列数组</a></h3><p>给你一个数组 nums ，数组中有 <strong>2n</strong> 个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p><p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p><h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3</span><br><span class="line">输出：[2,3,5,4,1,7] </span><br><span class="line">解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><ul><li><code>1 &lt;= n &lt;= 500</code></li><li><code>nums.length == 2n</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><hr><p>说实话这道题很简单，之所以我想把它记录下来的原因就是，一开始我就用<code>O(1)</code>的空间复杂度来解决，但是思考了很长时间都没有一个很好的思路。</p><p><em>关于时间复杂度，如果不懂可以百度一下。</em></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>我们看一下题目给出的提示，<code>nums[i]</code>最大为1000，那么我们可以使用这个条件下手。我们知道，一个int类型的数有 32 个bit，当<code>nums[i]</code>最大时，最多占据 10 个bit，那么我们可以利用剩下的 22 个bit存储点有用的信息。存储什么呢？我们可以利用剩下的 22 个bit存储当前下标最终需要存储的数。</p><p>我们来做个小小的算法，分别<strong>从小到大</strong>遍历 <strong>偶数下标、奇数下标</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i ++)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i &lt; n ? <span class="number">2</span> * i : <span class="number">2</span> * (i - n) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于测试用例 [2,5,1,3,4,7]</span></span><br><span class="line">我们可以打印一下每次循环 j 的值:</span><br><span class="line"><span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>,</span><br></pre></td></tr></table></figure><p>每次循环，我们都将当前 <code>i</code> 下标的值存储在 <code>j</code> 下标的数的前 22 个bit中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums[j] |= ((nums[i] &amp; <span class="number">1023</span>) &lt;&lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这样经过一次循环之后，每个数的前 22 个bit 中存储的就是该下标最终需要的数字，我们只需遍历一次，将其右移10位即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i ++) &#123;</span><br><span class="line">    nums[i] &gt;&gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shuffle(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i &lt; n ? <span class="number">2</span> * i : <span class="number">2</span> * (i - n) + <span class="number">1</span>;</span><br><span class="line">        nums[j] |= ((nums[i] &amp; <span class="number">1023</span>) &lt;&lt; <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i ++) &#123;</span><br><span class="line">        nums[i] &gt;&gt;= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      重新排列数组
    
    </summary>
    
    
    
      <category term="位运算" scheme="https://18wanttobesinger.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="算法" scheme="https://18wanttobesinger.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://18wanttobesinger.github.io/2020/06/15/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://18wanttobesinger.github.io/2020/06/15/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-15T08:03:57.000Z</published>
    <updated>2020-06-17T15:07:06.291Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“我自然不会试图揽月 我要他当空皎洁 同日而辉”</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>在软件系统中，经常面临着 “某些结构复杂的对象” 的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。</li><li>如何应对这种变化？如何向 “客户程序（使用这些对象的程序）”隔离出 “这些易变对象”，从而使得 “这些易变对象的客户程序” 不随着需求改变而改变？</li></ul><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>实现对象对自己的克隆（克隆自己）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过克隆自己创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span>:</span> <span class="keyword">public</span> ISplitter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝自己</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 拷贝自己</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TxtSplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>MainForm实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span>:</span> <span class="keyword">public</span> Form&#123;</span><br><span class="line">    ISplitter* prototype;    <span class="comment">// 原型对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainForm(ISplitter* prototype)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prototype = prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Button_Click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ISplitter* splitter = prototype-&gt;clone();</span><br><span class="line">        splitter-&gt;split();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul><li>Prototype 模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些 “易变类” 拥有 “稳定的接口”。</li><li>Prototype 模式对于 “如何创建易变类的实体对象” 采用 “原型” 克隆的方法来做，它使得我们可以非常灵活地动态创建 “拥有某些稳定接口” 的新对象—-所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。</li><li>Prototype 模式中的 Clone 方法可以利用某些框架中的序列化来实现深拷贝。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;“我自然不会试图揽月 我要他当空皎洁 同日而辉”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                        ----- 网易云热评&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://18wanttobesinger.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="https://18wanttobesinger.github.io/2020/06/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://18wanttobesinger.github.io/2020/06/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-13T09:19:33.000Z</published>
    <updated>2020-06-17T15:00:12.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请优先考虑那个优先考虑你的人。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="“对象创建”-模式"><a href="#“对象创建”-模式" class="headerlink" title="“对象创建” 模式"></a>“对象创建” 模式</h3><ul><li>通过“对象创建” 模式绕开new，来避免对象创建（new）过程 中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它 是接口抽象之后的第一步工作。 </li><li>典型模式<ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder  </li></ul></li></ul><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>在软件系统中，经常面临着“<strong>一系列相互依赖的对象</strong>”的创建工 作；同时，由于需求的变化，往往存在更多系列对象的创建工作。 </li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一 种“封装机制”来避免客户程序和这种“多系列具体对象创建工作” 的紧耦合？ </li></ul><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p> 提供一个接口，让该接口负责创建<strong>一系列“相关或者相互依 赖的对象”</strong>，无需指定它们具体的类。 </p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>根据不同的数据库版本创建不同的数据库连接；如：SQL Server、Mysql、Oracle等等。</p><p><strong>基础代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        SqlConnection* connection = <span class="keyword">new</span> SqlConnection();</span><br><span class="line">        connection-&gt;ConnectionString = <span class="string">"..."</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 植入sql</span></span><br><span class="line">        SqlCommand* command = <span class="keyword">new</span> SqlCommand();</span><br><span class="line">        command-&gt;CommandText=<span class="string">"..."</span>;</span><br><span class="line">        command-&gt;SetConnection(connection);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        SqlDataReader* reader = command-&gt;ExecuteReader();</span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据工厂方法模式，我们可以按照工厂方法模式来写，给每一种操作定义基类，然后使用相应的工厂类去创建他们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库访问有关的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnectionFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommandFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReaderFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们编写支持不同平台的实现：</p><p>以下支持SQL Server</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnectionFactory</span>:</span><span class="keyword">public</span> IDBConnectionFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommandFactory</span>:</span><span class="keyword">public</span> IDBCommandFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReaderFactory</span>:</span><span class="keyword">public</span> IDataReaderFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以下支持Oracle</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleConnectionFactory</span>:</span><span class="keyword">public</span> IDBConnectionFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleCommandFactory</span>:</span><span class="keyword">public</span> IDBCommandFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDataReaderFactory</span>:</span><span class="keyword">public</span> IDataReaderFactory&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建连接实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    IDBConnectionFactory* dbConnectionFactory;</span><br><span class="line">    IDBCommandFactory* dbCommandFactory;</span><br><span class="line">    IDataReaderFactory* dataReaderFactory;</span><br><span class="line">    <span class="comment">// ...构造方法省略</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection = dbConnectionFactory-&gt;CreateDBConnection();</span><br><span class="line">        connection-&gt;ConnectionString(<span class="string">"..."</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command = dbCommandFactory-&gt;CreateDBCommand();</span><br><span class="line">        command-&gt;CommandText(<span class="string">"..."</span>);</span><br><span class="line">        command-&gt;SetConnection(connection); <span class="comment">//关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码写到这里，你可能会问，这和工厂方法模式有区别吗？确实没有区别，但是这么写是有问题的，你想想看，每一种不同平台实现的连接、注入sql、执行都是不一样的，那么我们创建实例传入不同平台的连接、注入sql和执行的时候，后面肯定会报错的，因为如果传入参数不是一个平台的话，那么肯定无法执行的。</p><p>仔细想想，每个平台都有具体的实现，而这些实现对象都是有<strong>相互依赖</strong>、<strong>作用</strong>的。不同平台的对象实例之间没有相通性，那么我们是否可以设计出生产单个平台所需要的实例对象呢？</p><p>再次更改我们的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将这三个操作合并</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDBFactory</span>:</span> <span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDBFactory</span>:</span> <span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们需要支持SQL Server时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们需要支持Oracle时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    IDBFactory* dbFactory;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection = dbFactory-&gt;CreateDBConnection();</span><br><span class="line">        connection-&gt;ConnectionString(<span class="string">"..."</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command = dbFactory-&gt;CreateDBCommand();</span><br><span class="line">        command-&gt;CommandText(<span class="string">"..."</span>);</span><br><span class="line">        command-&gt;SetConnection(connection); <span class="comment">//关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;ExecuteReader(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;Read())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul><li>如果没有应对“<strong>多系列对象构建</strong>”的需求变化，则没有必要使用 Abstract Factory模式，这时候使用简单的工厂完全可以。 </li><li><strong>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、 或作用的关系。</strong>不同系列的对象之间不能相互依赖。 </li><li>Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;请优先考虑那个优先考虑你的人。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                        ----- 网易云热评&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://18wanttobesinger.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="https://18wanttobesinger.github.io/2020/06/12/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://18wanttobesinger.github.io/2020/06/12/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-06-12T13:24:20.000Z</published>
    <updated>2020-06-17T14:58:44.976Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">愿世间的美好，与你环环相扣。</span><br><span class="line"></span><br><span class="line">                                                                        ----- 网易云热评</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="”对象创建“-模式"><a href="#”对象创建“-模式" class="headerlink" title="”对象创建“ 模式"></a>”对象创建“ 模式</h3><ul><li>通过“对象创建” 模式绕开new，来避免对象创建（new）过程 中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它 是接口抽象之后的第一步工作。</li><li>典型模式<ul><li>Factory Method</li><li>Abstract Factory</li><li>Prototype</li><li>Builder  </li></ul></li></ul><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。</li><li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？</li></ul><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>还记得在讲<a href="https://18wanttobesinger.github.io/2020/06/08/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/#more">观察者模式</a>的时候，我们的需求是实现将大文件分割成若干的小文件。我们先看一下实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form, <span class="keyword">public</span> IProgress</span><br><span class="line">&#123;</span><br><span class="line">    TextBox* txtFilePath;</span><br><span class="line">    TextBox* txtFileNumber;</span><br><span class="line"></span><br><span class="line">    ProgressBar* progressBar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> filePath = txtFilePath-&gt;getText();</span><br><span class="line">        <span class="keyword">int</span> number = atoi(txtFileNumber-&gt;getText().c_str());</span><br><span class="line"></span><br><span class="line">        FileSplitter* splitter = <span class="keyword">new</span> FileSplitter(filePath, number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以观察到，我们创建对象的方式是直接new的这个对象。那么我们知道根据面向接口编程原则，当我们需要对一个类进行分类扩展时，对象的类型，我们应该将其声明为<strong>抽象类</strong>或者<strong>接口</strong>。接下来我们就这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个ISplitter的子类都有其具体的实现。那么我们应该这么创建对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ISplitter* splitter1 = <span class="keyword">new</span> BinarySplitter(filePath, number);</span><br><span class="line">ISplitter* splitter2 = <span class="keyword">new</span> TxtSplitter(filePath, number);</span><br><span class="line">ISplitter* splitter3 = <span class="keyword">new</span> PictureSplitter(filePath, number);</span><br><span class="line">ISplitter* splitter4 = <span class="keyword">new</span> VideoSplitter(filePath, number);</span><br></pre></td></tr></table></figure><p>那么根据<strong>依赖倒置原则</strong>：<strong>我们应该依赖抽象，不该依赖实现细节</strong>。可以看到上面的创建实例代码，左边我们定义的是抽象类型，但是右边我们还是要依赖实现细节。我们知道上面代码创建对象我们都使用的<code>new</code>关键字，那么我么如何绕开<code>new</code>，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定呢？</p><p>我们来定义一个工厂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ISplitter <span class="title">createSplitter</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">... </span><br><span class="line">SplitterFactory factory;</span><br><span class="line">SpliterFactory* sp = factory.createSplitter(...);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们试图以方法的形式创建对象，但是可以发现，还是无法脱离<code>new</code>的 “魔爪” 。我们还是依赖着具体实现… 那怎么办呢？仔细想想，我们上面直接创建对象都是编译时依赖，能不能将它转换成运行时依赖呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter <span class="title">createSplitter</span><span class="params">(...)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~SplitterFactory()&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 我们创建指针</span></span><br><span class="line">SplitterFactory* factory;</span><br><span class="line"><span class="comment">// 真正创建对象时交给未来 (factory)</span></span><br><span class="line">ISplitter* splitter = factory-&gt;createSplitter();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>针对要创建的具体对象，我们分别定义其生产该类型对象的工厂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter <span class="title">createSplitter</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 其他类和上述相似</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以看到，每一个具体的类，都有其对应的工厂。那么你看到这里也许很懵，这样解决了我们原先遇到的问题了吗？请继续看下面的代码改进：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form &#123;</span><br><span class="line">    SplitterFactory* factory;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 具体要创建对象的工厂是需要传入的，那么我们要什么对象就传该对象的工厂即可</span></span><br><span class="line">    MainForm(SplitterFactory* factory) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Button_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ISplitter* sp = factory-&gt;createSplitter(); <span class="comment">// 多态</span></span><br><span class="line">        sp-&gt;split();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，我们可以看到MainForm中已经极大程度的降低了依赖，我们可以观察里面的所有对象都是抽象的。依赖是不是已经降低了呢？</p><h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul><li>Factory Method模式用于隔离类对象的使用者和具体类型之间的 耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。</li><li>Factory Method模式通过面向对象的手法，将所要<strong>创建的具体对 象工作延迟到子类</strong>，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</li><li>Factory Method模式解决“单个对象”的需求变化。缺点在于要 求创建方法/参数相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;愿世间的美好，与你环环相扣。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                        ----- 网易云热评&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://18wanttobesinger.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
